/**
* Copyright (C) 2011, BMW AG
*
* GeniviAudioMananger DbusPlugin
*
* \file RoutingSender.h
*
* \date 20-Oct-2011 3:42:04 PM
* \author Christian Mueller (christian.ei.mueller@bmw.de)
*
* \section License
* GNU Lesser General Public License, version 2.1, with special exception (GENIVI clause)
* Copyright (C) 2011, BMW AG Christian Mueller  Christian.ei.mueller@bmw.de
*
* This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License, version 2.1, as published by the Free Software Foundation.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License, version 2.1, for more details.
* You should have received a copy of the GNU Lesser General Public License, version 2.1, along with this program; if not, see <http://www.gnu.org/licenses/lgpl-2.1.html>.
* Note that the copyright holders assume that the GNU Lesser General Public License, version 2.1, may also be applicable to programs even in cases in which the program is not a library in the technical sense.
* Linking AudioManager statically or dynamically with other modules is making a combined work based on AudioManager. You may license such other modules under the GNU Lesser General Public License, version 2.1. If you do not want to license your linked modules under the GNU Lesser General Public License, version 2.1, you may use the program under the following exception.
* As a special exception, the copyright holders of AudioManager give you permission to combine AudioManager with software programs or libraries that are released under any license unless such a combination is not permitted by the license of such a software program or library. You may copy and distribute such a system following the terms of the GNU Lesser General Public License, version 2.1, including this special exception, for AudioManager and the licenses of the other code concerned.
* Note that people who make modified versions of AudioManager are not obligated to grant this special exception for their modified versions; it is their choice whether to do so. The GNU Lesser General Public License, version 2.1, gives permission to release a modified version without this exception; this exception also makes it possible to release a modified version which carries forward this exception.
*
* THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN
*/

#ifndef ROUTINGSENDER_H_
#define ROUTINGSENDER_H_

#include <routing/RoutingSendInterface.h>
#include "RoutingReceiverAsyncShadow.h"
#include <semaphore.h>

namespace am {

class WorkerThreadPool;

/**
 * Base class for workers implements everything that is needed to implement a workerthread
 * inherit from this class when adding new workers
 */
class Worker
{
public:
	Worker(WorkerThreadPool* pool);
	virtual ~Worker(){};
	/**
	 * needs to be overwritten, this function is called when the worker should start to work
	 */
	void virtual start2work()=0;

	/**
	 * needs to be overwritten, this function is called when the worker thread is canceled. Should be used for
	 * clean up and sending important messages
	 */
	void virtual cancelWork()=0;
	/**
	 * waits for a semaphore with a timeout. This leaves the Threadpool the chance to interrupt the processing
	 * You should call whenever waiting on some event, even with time=0 in order to make sure that cancel events are
	 * received
	 * @param time time until timeout in timespec format
	 * @return true if thread is canceled. Then just return start2work function so that the thread is given back to the pool
	 */
	bool timedWait(timespec time);

	/**
	 * the semaphore for cancellation is set by the thread automatically...
	 * @param cancel
	 */
	void setCancelSempaphore(sem_t* cancel);
	WorkerThreadPool* pPool;
private:
	sem_t* mCancelSem; //<! semaphore for cancellation
};


/**
 * This class handles the threadpool
 */
class WorkerThreadPool
{
public:
	/**
	 * creates the pool. Give the max number of threads as argument
	 * @param numThreads max number of threads
	 */
	WorkerThreadPool(int numThreads);
	virtual ~WorkerThreadPool();

	/**
	 * assigns a thread to a worker class and starts working.
	 * @param worker
	 * @return the actual assigned workerID or -1 in case no thread is free
	 */
	int16_t startWork(Worker* worker);
	/**
	 * cancels a thread
	 * @param workerID thread to be canceled
	 * @return true if thread was found, false if not
	 */
	bool cancelWork(int workerID);

	/**
	 * the workers call this function upon completion of their task
	 * @param threadID
	 */
	void finishedWork(pthread_t threadID);


private:
	static void* WorkerThread (void* data);
	int mNumThreads;
	struct threadInfo_s
	{
		uint16_t workerID;
		pthread_t threadID;
		bool busy;
		sem_t block;
		sem_t cancel;
		Worker *worker;
	};
	std::vector<threadInfo_s> mListWorkers; //<! list of all workers
	static pthread_mutex_t mBlockingMutex;	//<! mutex to block the acces of the list
};

class AsyncRoutingSender: public RoutingSendInterface {
public:
	AsyncRoutingSender();
	virtual ~AsyncRoutingSender();
	void startupRoutingInterface(RoutingReceiveInterface* routingreceiveinterface) ;
	void routingInterfacesReady() ;
	void routingInterfacesRundown() ;
	am_Error_e asyncAbort(const am_Handle_s handle) ;
	am_Error_e asyncConnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_sourceID_t sourceID, const am_sinkID_t sinkID, const am_ConnectionFormat_e connectionFormat) ;
	am_Error_e asyncDisconnect(const am_Handle_s handle, const am_connectionID_t connectionID) ;
	am_Error_e asyncSetSinkVolume(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume, const am_RampType_e ramp, const am_time_t time) ;
	am_Error_e asyncSetSourceVolume(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume, const am_RampType_e ramp, const am_time_t time) ;
	am_Error_e asyncSetSourceState(const am_Handle_s handle, const am_sourceID_t sourceID, const am_SourceState_e state) ;
	am_Error_e asyncSetSinkSoundProperty(const am_Handle_s handle, const am_SoundProperty_s& soundProperty, const am_sinkID_t sinkID) ;
	am_Error_e asyncSetSourceSoundProperty(const am_Handle_s handle, const am_SoundProperty_s& soundProperty, const am_sourceID_t sourceID) ;
	am_Error_e asyncCrossFade(const am_Handle_s handle, const am_crossfaderID_t crossfaderID, const am_HotSink_e hotSink, const am_RampType_e rampType, const am_time_t time) ;
	am_Error_e setDomainState(const am_domainID_t domainID, const am_DomainState_e domainState) ;
	am_Error_e returnBusName(std::string& BusName) const ;

	/**
	 * threadafe insert of route and connectionID
	 * @param connectionID
	 * @param route
	 */
	void insertConnectionSafe(am_connectionID_t connectionID,am_RoutingElement_s route);

	/**
	 * threadsafe removal of a connection
	 * @param
	 */
	void removeConnectionSafe(am_connectionID_t);

	/**
	 * threadsafe remove of a handle
	 * @param handle
	 */
	void removeHandleSafe(uint16_t handle);

	/**
	 * threadsafe update of Sinkvolume
	 * @param sinkID
	 * @param volume
	 */
	void updateSinkVolumeSafe(am_sinkID_t sinkID,am_volume_t volume);

	/**
	 * threadsafe update of SourceVolume
	 * @param sourceID
	 * @param volume
	 */
	void updateSourceVolumeSafe(am_sourceID_t sourceID,am_volume_t volume);

	/**
	 * threadsafe update of sourceState
	 * @param sourceID
	 * @param state
	 */
	void updateSourceStateSafe(am_sourceID_t sourceID,am_SourceState_e state);

	/**
	 * threadsafe update of sinkSoundProperty
	 * @param sinkID
	 * @param soundProperty
	 */
	void updateSinkSoundPropertySafe(am_sinkID_t sinkID, am_SoundProperty_s soundProperty);

	/**
	 * threadsafe update of sourceSoundProperty
	 * @param sourceID
	 * @param soundProperty
	 */
	void updateSourceSoundPropertySafe(am_sourceID_t sourceID, am_SoundProperty_s soundProperty);

	/**
	 * threadsafe update of domainstate
	 * @param domainID
	 * @param domainState
	 */
	void updateDomainstateSafe(am_domainID_t domainID,am_DomainState_e domainState);

private:
	/**
	 * Extra thread that handles dbus stimulation for interrupt tests
	 * @param data
	 */
	static void* InterruptEvents (void* data);
	std::vector<am_Domain_s> createDomainTable();
	std::vector<am_Sink_s> createSinkTable();
	std::vector<am_Source_s> createSourceTable();
	std::vector<am_Gateway_s> createGatewayTable();
	RoutingReceiverAsyncShadow mShadow;
	RoutingReceiveInterface* mReceiveInterface;
	SocketHandler *mSocketHandler;
	std::vector<am_Domain_s> mDomains;
	std::vector<am_Sink_s> mSinks;
	std::vector<am_Source_s> mSources;
	std::vector<am_Gateway_s> mGateways;
	std::map<uint16_t,int16_t> mMapHandleWorker;
	std::map<am_connectionID_t,am_RoutingElement_s> mMapConnectionIDRoute;
	WorkerThreadPool mPool;
	pthread_t mInterruptThread;
	static pthread_mutex_t mMapConnectionMutex;
	static pthread_mutex_t mMapHandleWorkerMutex;
	static pthread_mutex_t mSinksMutex;
	static pthread_mutex_t mSourcesMutex;
	static pthread_mutex_t mDomainsMutex;
};


/**
 * worker to for connection
 */
class asycConnectWorker : public Worker
{
public:
	asycConnectWorker(AsyncRoutingSender * asyncSender,WorkerThreadPool* pool, RoutingReceiverAsyncShadow* shadow, const am_Handle_s handle, const am_connectionID_t connectionID, const am_sourceID_t sourceID, const am_sinkID_t sinkID, const am_ConnectionFormat_e connectionFormat);
	void start2work();
	void cancelWork();
private:
	AsyncRoutingSender * mAsyncSender;
	RoutingReceiverAsyncShadow *mShadow;
	am_Handle_s mHandle;
	am_connectionID_t mConnectionID;
	am_sourceID_t mSourceID;
	am_sinkID_t mSinkID;
	am_ConnectionFormat_e mConnectionFormat;
};

/**
 * worker for disconnecting
 */
class asycDisConnectWorker : public Worker
{
public:
	asycDisConnectWorker(AsyncRoutingSender * asyncSender,WorkerThreadPool* pool, RoutingReceiverAsyncShadow* shadow, const am_Handle_s handle, const am_connectionID_t connectionID);
	void start2work();
	void cancelWork();
private:
	AsyncRoutingSender * mAsyncSender;
	RoutingReceiverAsyncShadow *mShadow;
	am_Handle_s mHandle;
	am_connectionID_t mConnectionID;
	am_ConnectionFormat_e mConnectionFormat;
};

/**
 * worker to for connection
 */

#include <semaphore.h>
#include <sys/signalfd.h>
#include <signal.h>

class asyncSetSinkVolumeWorker : public Worker
{
public:
	asyncSetSinkVolumeWorker(AsyncRoutingSender * asyncSender,WorkerThreadPool* pool, RoutingReceiverAsyncShadow* shadow, const am_volume_t currentVolume,const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume, const am_RampType_e ramp, const am_time_t time);
	void start2work();
	void cancelWork();
private:
	AsyncRoutingSender * mAsyncSender;
	RoutingReceiverAsyncShadow *mShadow;
	am_volume_t mCurrentVolume;
	am_Handle_s mHandle;
	am_sinkID_t mSinkID;
	am_volume_t mVolume;
	am_RampType_e mRamp;
	am_time_t mTime;
};

class asyncSetSourceVolumeWorker : public Worker
{
public:
	asyncSetSourceVolumeWorker(AsyncRoutingSender * asyncSender,WorkerThreadPool* pool, RoutingReceiverAsyncShadow* shadow, const am_volume_t currentVolume,const am_Handle_s handle, const am_sourceID_t SourceID, const am_volume_t volume, const am_RampType_e ramp, const am_time_t time);
	void start2work();
	void cancelWork();
private:
	AsyncRoutingSender * mAsyncSender;
	RoutingReceiverAsyncShadow *mShadow;
	am_volume_t mCurrentVolume;
	am_Handle_s mHandle;
	am_sourceID_t mSourceID;
	am_volume_t mVolume;
	am_RampType_e mRamp;
	am_time_t mTime;
};

class asyncSetSourceStateWorker : public Worker
{
public:
	asyncSetSourceStateWorker(AsyncRoutingSender * asyncSender,WorkerThreadPool* pool, RoutingReceiverAsyncShadow* shadow, const am_Handle_s handle, const am_sourceID_t sourceID, const am_SourceState_e state);
	void start2work();
	void cancelWork();
private:
	AsyncRoutingSender * mAsyncSender;
	RoutingReceiverAsyncShadow *mShadow;
	am_Handle_s mHandle;
	am_sourceID_t mSourceID;
    am_SourceState_e mSourcestate;
};

class asyncSetSinkSoundPropertyWorker : public Worker
{
public:
	asyncSetSinkSoundPropertyWorker(AsyncRoutingSender * asyncSender,WorkerThreadPool* pool, RoutingReceiverAsyncShadow* shadow, const am_Handle_s handle, const am_SoundProperty_s soundProperty, const am_sinkID_t sinkID);
	void start2work();
	void cancelWork();
private:
	AsyncRoutingSender * mAsyncSender;
	RoutingReceiverAsyncShadow *mShadow;
	am_Handle_s mHandle;
	am_sinkID_t mSinkID;
    am_SoundProperty_s mSoundProperty;
};

class asyncSetSourceSoundPropertyWorker : public Worker
{
public:
	asyncSetSourceSoundPropertyWorker(AsyncRoutingSender * asyncSender,WorkerThreadPool* pool, RoutingReceiverAsyncShadow* shadow, const am_Handle_s handle, const am_SoundProperty_s soundProperty, const am_sourceID_t sourceID);
	void start2work();
	void cancelWork();
private:
	AsyncRoutingSender * mAsyncSender;
	RoutingReceiverAsyncShadow *mShadow;
	am_Handle_s mHandle;
	am_sourceID_t mSourceID;
    am_SoundProperty_s mSoundProperty;
};

class asyncDomainStateChangeWorker : public Worker
{
public:
	asyncDomainStateChangeWorker(AsyncRoutingSender * asyncSender,WorkerThreadPool* pool, RoutingReceiverAsyncShadow* shadow, const am_domainID_t domainID, const am_DomainState_e domainState);
	void start2work();
	void cancelWork();
private:
	AsyncRoutingSender * mAsyncSender;
	RoutingReceiverAsyncShadow *mShadow;
	am_domainID_t mDomainID;
	am_DomainState_e mDomainState;
};

}

#endif /* ROUTINGSENDER_H_ */

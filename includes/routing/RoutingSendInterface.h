/**
* Copyright (C) 2011, BMW AG
*
* GeniviAudioMananger
*
* \file  
*
* \date 20-Oct-2011 3:42:04 PM
* \author Christian Mueller (christian.ei.mueller@bmw.de)
*
* \section License
* GNU Lesser General Public License, version 2.1, with special exception (GENIVI clause)
* Copyright (C) 2011, BMW AG Christian M?ller  Christian.ei.mueller@bmw.de
*
* This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License, version 2.1, as published by the Free Software Foundation.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License, version 2.1, for more details.
* You should have received a copy of the GNU Lesser General Public License, version 2.1, along with this program; if not, see <http://www.gnu.org/licenses/lgpl-2.1.html>.
* Note that the copyright holders assume that the GNU Lesser General Public License, version 2.1, may also be applicable to programs even in cases in which the program is not a library in the technical sense.
* Linking AudioManager statically or dynamically with other modules is making a combined work based on AudioManager. You may license such other modules under the GNU Lesser General Public License, version 2.1. If you do not want to license your linked modules under the GNU Lesser General Public License, version 2.1, you may use the program under the following exception.
* As a special exception, the copyright holders of AudioManager give you permission to combine AudioManager with software programs or libraries that are released under any license unless such a combination is not permitted by the license of such a software program or library. You may copy and distribute such a system following the terms of the GNU Lesser General Public License, version 2.1, including this special exception, for AudioManager and the licenses of the other code concerned.
* Note that people who make modified versions of AudioManager are not obligated to grant this special exception for their modified versions; it is their choice whether to do so. The GNU Lesser General Public License, version 2.1, gives permission to release a modified version without this exception; this exception also makes it possible to release a modified version which carries forward this exception.
*
* THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN
*/
#if !defined(EA_BEE41204_65B8_46cf_BB6A_9953BE0EC53A__INCLUDED_)
#define EA_BEE41204_65B8_46cf_BB6A_9953BE0EC53A__INCLUDED_

#include <vector>
#include <string>
#include "../audiomanagertypes.h"


#include "RoutingReceiveInterface.h"

namespace am {
	/**
	 *  This class implements everything from Audiomanager -> RoutingAdapter
	 * @author christian
	 * @version 1.0
	 * @created 08-Dec-2011 1:05:14 PM
	 */
	class RoutingSendInterface
	{

	public:
		/**
		 * starts up the interface. In the implementations, here is the best place for init routines.
		 * 
		 * @param routingreceiveinterface    pointer to the receive interface
		 */
		virtual void startupRoutingInterface(RoutingReceiveInterface* routingreceiveinterface) =0;
		/**
		 * indicates that the interface is now ready to be used. Should be used as trigger to register all sinks, sources, etc...
		 */
		virtual void routingInterfacesReady() =0;
		/**
		 * is used to indicate the rundown of the system
		 */
		virtual void routingInterfacesRundown() =0;
		/**
		 * aborts an asynchronous action.
		 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if handle was not found
		 * 
		 * @param handle
		 */
		virtual am_Error_e asyncAbort(const am_Handle_s handle) =0;
		/**
		 * connects a source to a sink
		 * @return E_OK on success, E_UNKNOWN on error, E_WRONG_FORMAT in case am_ConnectionFormat_e does not match
		 * 
		 * @param handle
		 * @param connectionID
		 * @param sourceID
		 * @param sinkID
		 * @param connectionFormat
		 */
		virtual am_Error_e asyncConnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_sourceID_t sourceID, const am_sinkID_t sinkID, const am_ConnectionFormat_e connectionFormat) =0;
		/**
		 * disconnect a connection with given connectionID
		 * @return E_OK on success, E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
		 * 
		 * @param handle
		 * @param connectionID
		 */
		virtual am_Error_e asyncDisconnect(const am_Handle_s handle, const am_connectionID_t connectionID) =0;
		/**
		 * this method is used to set the volume of a sink. This function is used to drive ramps, to mute or unmute or directly set the value. The difference is made through the ramptype.
		 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE if new volume is out of range
		 * 
		 * @param handle
		 * @param sinkID
		 * @param volume
		 * @param ramp
		 * @param time
		 */
		virtual am_Error_e asyncSetSinkVolume(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume, const am_RampType_e ramp, const am_time_t time) =0;
		/**
		 * sets the volume of a source. This method is used to set the volume of a sink. This function is used to drive ramps, to mute or unmute or directly set the value. The difference is made through the ramptype.
		 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of range.
		 * triggers the acknowledge ackSourceVolumeChange
		 * 
		 * @param handle
		 * @param sourceID
		 * @param volume
		 * @param ramp
		 * @param time
		 */
		virtual am_Error_e asyncSetSourceVolume(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume, const am_RampType_e ramp, const am_time_t time) =0;
		/**
		 * This function is used to set the source state of a particular source.
		 * @return E_OK on success, E_UNKNOWN on error
		 * 
		 * @param handle
		 * @param sourceID
		 * @param state
		 */
		virtual am_Error_e asyncSetSourceState(const am_Handle_s handle, const am_sourceID_t sourceID, const am_SourceState_e state) =0;
		/**
		 * this function sets the sinksoundproperty.
		 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
		 * 
		 * @param handle
		 * @param soundProperty
		 * @param sinkID
		 */
		virtual am_Error_e asyncSetSinkSoundProperty(const am_Handle_s handle, const am_SoundProperty_s& soundProperty, const am_sinkID_t sinkID) =0;
		/**
		 * this function sets the sourcesoundproperty.
		 * @return E_OK on success, E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
		 * 
		 * @param handle
		 * @param soundProperty
		 * @param sourceID
		 */
		virtual am_Error_e asyncSetSourceSoundProperty(const am_Handle_s handle, const am_SoundProperty_s& soundProperty, const am_sourceID_t sourceID) =0;
		/**
		 * this function triggers crossfading.
		 * @return E_OK on success, E_UNKNOWN on error
		 * 
		 * @param handle
		 * @param crossfaderID
		 * @param hotSink
		 * @param rampType
		 * @param time
		 */
		virtual am_Error_e asyncCrossFade(const am_Handle_s handle, const am_crossfaderID_t crossfaderID, const am_HotSink_e hotSink, const am_RampType_e rampType, const am_time_t time) =0;
		/**
		 * this function is used for early and late audio functions to set the domain state
		 * @return E_OK on success, E_UNKNOWN on error
		 * 
		 * @param domainID
		 * @param domainState
		 */
		virtual am_Error_e setDomainState(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
		/**
		 * this method is used to retrieve the busname during startup of the plugin. Needs to be implemented
		 * @return E_OK on success, E_UNKNOWN on error
		 * 
		 * @param BusName
		 */
		virtual am_Error_e returnBusName(std::string& BusName) const =0;

	};
}
#endif // !defined(EA_BEE41204_65B8_46cf_BB6A_9953BE0EC53A__INCLUDED_)

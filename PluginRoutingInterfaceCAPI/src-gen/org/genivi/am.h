/*
* This file was generated by the CommonAPI Generators. 
* Used org.genivi.commonapi.core 2.1.2.201309301424.
* Used org.franca.core 0.8.9.201308271211.
*
*  Copyright (c) 2012 BMW
*  
*   \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
*  
*   \copyright
*   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
*   including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
*   subject to the following conditions:
*   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
*   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
*   THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*    For further information see http://www.genivi.org/.
*  
*/
/**
 * @author Christian Linke
 */
#ifndef ORG_GENIVI_am_H_
#define ORG_GENIVI_am_H_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/InputStream.h>
#include <CommonAPI/OutputStream.h>
#include <CommonAPI/SerializableStruct.h>
#include <CommonAPI/SerializableVariant.h>
#include <CommonAPI/types.h>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {

namespace am {
    /**
     * a source ID
     */
    /**
     * a source ID
     */
    typedef uint16_t am_sourceID_t;
    /**
     * a mainConnection ID
     */
    /**
     * a mainConnection ID
     */
    typedef uint16_t am_mainConnectionID_t;
    /**
     * offset time that is introduced in milli seconds.
     */
    /**
     * offset time that is introduced in milli seconds.
     */
    typedef int16_t am_timeSync_t;
    /**
     * a sink ID
     */
    /**
     * a sink ID
     */
    typedef uint16_t am_sinkID_t;
    /**
     * represents the connection state
     */
    enum class am_ConnectionState_e: int32_t {
        CS_UNKNOWN = 0,
        /**
         * This means the connection is just building up
         */
        CS_CONNECTING = 1,
        /**
         * the connection is ready to be used
         */
        CS_CONNECTED = 2,
        /**
         * the connection is in the course to be knocked down
         */
        CS_DISCONNECTING = 3,
        /**
         * only relevant for connectionStatechanged. Is send after the connection was
         *  removed
         */
        CS_DISCONNECTED = 4,
        /**
         * this means the connection is still build up but unused at the moment
         */
        CS_SUSPENDED = 5,
        CS_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_ConnectionState_eComparator;
    /**
     * this type holds all information of connections relevant to the HMI
     */
    /**
     * this type holds all information of connections relevant to the HMI
     */
    struct am_MainConnectionType_s: CommonAPI::SerializableStruct {
        /**
         * the ID of the mainconnection
         */
         am_mainConnectionID_t mainConnectionID;
        /**
         * the sourceID where the connection starts
         */
         am_sourceID_t sourceID;
        /**
         * the sinkID where the connection ends
         */
         am_sinkID_t sinkID;
        /**
         * the delay of the mainconnection
         */
         am_timeSync_t delay;
        /**
         * the current connection state
         */
         am_ConnectionState_e connectionState;
    
        am_MainConnectionType_s() = default;
        am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_ConnectionState_e& connectionState);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeInt32Type();
        }
    };
    typedef std::vector<am_MainConnectionType_s> am_MainConnection_L;
    /**
     * product specific identifier of property
     */
    /**
     * product specific identifier of property
     */
    typedef uint16_t am_ClassProperty_pe;
    /**
     * describes class properties
     */
    /**
     * describes class properties
     */
    struct am_ClassProperty_s: CommonAPI::SerializableStruct {
        /**
         * the property as enum
         */
         am_ClassProperty_pe classProperty;
        /**
         * the value of the property
         */
         int16_t value;
    
        am_ClassProperty_s() = default;
        am_ClassProperty_s(const am_ClassProperty_pe& classProperty, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    typedef std::vector<am_ClassProperty_s> am_ClassProperty_L;
    typedef uint16_t am_sinkClass_t;
    /**
     * struct describing sinkclasses
     */
    /**
     * struct describing sinkclasses
     */
    struct am_SinkClass_s: CommonAPI::SerializableStruct {
        /**
         * the ID of the sinkClass
         */
         am_sinkClass_t sinkClassID;
        /**
         * the name of the sinkClass - must be unique in the system
         */
         std::string name;
        /**
         * the list of the class properties. These are pairs of  a project specific enum
         *  describing the type of the value and an integer holding the real value.
         */
         am_ClassProperty_L listClassProperties;
    
        am_SinkClass_s() = default;
        am_SinkClass_s(const am_sinkClass_t& sinkClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    typedef std::vector<am_SinkClass_s> am_SinkClass_L;
    /**
     * This is the volume presented on the command interface. It is in the duty of the
     *  Controller to change the volumes given here into meaningful values on the
     *  routing interface.
    The range of this type is customer specific.
     */
    /**
     * This is the volume presented on the command interface. It is in the duty of the
     *  Controller to change the volumes given here into meaningful values on the
     *  routing interface.
    The range of this type is customer specific.
     */
    typedef int16_t am_mainVolume_t;
    /**
     * This  project specific value gives the information about reason for reason for
     *  Source/Sink change
     */
    /**
     * This  project specific value gives the information about reason for reason for
     *  Source/Sink change
     */
    typedef uint16_t am_AvailabilityReason_pe;
    /**
     * with the help of this enum, sinks and sources can report their availability
     *  state
     */
    enum class am_Availability_e: int32_t {
        /**
         * default
         */
        A_UNKNOWN = 0,
        /**
         * The source / sink is available
         */
        A_AVAILABLE = 1,
        /**
         * the source / sink is not available
         */
        A_UNAVAILABLE = 2,
        A_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Availability_eComparator;
    enum class am_MuteState_e: int32_t {
        /**
         * default
         */
        MS_UNKNOWN = 0,
        /**
         * the source / sink is muted
         */
        MS_MUTED = 1,
        /**
         * the source / sink is unmuted
         */
        MS_UNMUTED = 2,
        MS_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_MuteState_eComparator;
    /**
     * this describes the availability of a sink or a source together with the latest
     *  change
     */
    /**
     * this describes the availability of a sink or a source together with the latest
     *  change
     */
    struct am_Availability_s: CommonAPI::SerializableStruct {
        /**
         * the current availability state
         */
         am_Availability_e availability;
        /**
         * the reason for the last change. This can be used to trigger events that deal
         *  with state changes.
         */
         am_AvailabilityReason_pe availabilityReason;
    
        am_Availability_s() = default;
        am_Availability_s(const am_Availability_e& availability, const am_AvailabilityReason_pe& availabilityReason);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    /**
     * this type holds all information of sinks relevant to the HMI
     */
    /**
     * this type holds all information of sinks relevant to the HMI
     */
    struct am_SinkType_s: CommonAPI::SerializableStruct {
        /**
         * This is the ID of the sink, it is unique in the system. There are 2 ways, ID
         *  can be created: either it is assigned during the registration process (in a
         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
         *  is a fixed (the project has to ensure the uniqueness of the ID).
         */
         am_sinkID_t sinkID;
        /**
         * The name of the sink. Must be unique in the whole system.
         */
         std::string name;
        /**
         * This attribute reflects the availability of the sink. There are several reasons
         *  why a sink could be not available for the moment: for example the shutdown of
         *  a sink because of overtemperature or over- &amp; undervoltage. The
         *  availability consists of two pieces of information:
        
            Availablility: the
         *  status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
           
         *  AvailabilityReason: this informs about the last reason for a change in
         *  availability. The reasons itself are product specific.
         */
         am_Availability_s availability;
        /**
         * This is the representation of the Volume for the commandInterface. It is used
         *  by the HMI to set the volume of a sink, the AudioManagerController has to
         *  transform this into real source and sink volumes.
         */
         am_mainVolume_t volume;
         am_MuteState_e muteState;
        /**
         * The sinkClassID references to a sinkClass. With the help of classification,
         *  rules can be setup to define the system behaviour.
         */
         am_sinkClass_t sinkClassID;
    
        am_SinkType_s() = default;
        am_SinkType_s(const am_sinkID_t& sinkID, const std::string& name, const am_Availability_s& availability, const am_mainVolume_t& volume, const am_MuteState_e& muteState, const am_sinkClass_t& sinkClassID);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    typedef std::vector<am_SinkType_s> am_SinkType_L;
    typedef uint16_t am_sourceClass_t;
    /**
     * struct describing source classes
     */
    /**
     * struct describing source classes
     */
    struct am_SourceClass_s: CommonAPI::SerializableStruct {
        /**
         * the source ID
         */
         am_sourceClass_t sourceClassID;
        /**
         * the name of the sourceClass - must be unique in the system
         */
         std::string name;
        /**
         * the list of the class properties. These are pairs of  a project specific enum
         *  describing the type of the value and an integer holding the real value.
         */
         am_ClassProperty_L listClassProperties;
    
        am_SourceClass_s() = default;
        am_SourceClass_s(const am_sourceClass_t& sourceClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    typedef std::vector<am_SourceClass_s> am_SourceClass_L;
    /**
     * this type holds all information of sources relevant to the HMI
     */
    /**
     * this type holds all information of sources relevant to the HMI
     */
    struct am_SourceType_s: CommonAPI::SerializableStruct {
        /**
         * This is the ID of the source, it is unique in the system. There are 2 ways, ID
         *  can be created: either it is assigned during the registration process (in a
         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
         *  is a fixed (the project has to ensure the uniqueness of the ID).
         */
         am_sourceID_t sourceID;
        /**
         * The name of the source. Must be unique in the whole system.
         */
         std::string name;
        /**
         * the availability of the source
         */
         am_Availability_s availability;
        /**
         * the sourceClassID, indicates the class the source is in. This information can
         *  be used by the Controller to implement different behaviour for different
         *  classes.
         */
         am_sourceClass_t sourceClassID;
    
        am_SourceType_s() = default;
        am_SourceType_s(const am_sourceID_t& sourceID, const std::string& name, const am_Availability_s& availability, const am_sourceClass_t& sourceClassID);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeUInt16Type();
        }
    };
    typedef std::vector<am_SourceType_s> am_SourceType_L;
    /**
     * describes the different system properties. Project specific
     */
    /**
     * describes the different system properties. Project specific
     */
    typedef uint16_t am_SystemPropertyType_pe;
    /**
     * struct describing system properties
     */
    /**
     * struct describing system properties
     */
    struct am_SystemProperty_s: CommonAPI::SerializableStruct {
        /**
         * the type that is set
         */
         am_SystemPropertyType_pe type;
        /**
         * the value
         */
         int16_t value;
    
        am_SystemProperty_s() = default;
        am_SystemProperty_s(const am_SystemPropertyType_pe& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    typedef std::vector<am_SystemProperty_s> am_SystemProperty_L;
    /**
     * a connection ID
     */
    /**
     * a connection ID
     */
    typedef uint16_t am_connectionID_t;
    typedef std::vector<am_connectionID_t> am_ConnectionID_L;
    /**
     * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and
     *  maximum can be limited by actual project.
     */
    /**
     * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and
     *  maximum can be limited by actual project.
     */
    typedef int16_t am_volume_t;
    /**
     * Project specific sound properties.
     */
    /**
     * Project specific sound properties.
     */
    typedef uint16_t am_SoundPropertyType_pe;
    /**
     * This enum characterizes the data of the EarlyData_t
     */
    enum class am_EarlyDataType_e: int32_t {
        /**
         * default
         */
        ES_UNKNOWN = 0,
        /**
         * the source volume
         */
        ED_SOURCE_VOLUME = 1,
        /**
         * the sink volume
         */
        ED_SINK_VOLUME = 2,
        /**
         * a source property
         */
        ED_SOURCE_PROPERTY = 3,
        /**
         * a sink property
         */
        ED_SINK_PROPERTY = 4,
        ED_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_EarlyDataType_eComparator;
    /**
     * struct describing the sound property
     */
    /**
     * struct describing the sound property
     */
    struct am_SoundProperty_s: CommonAPI::SerializableStruct {
        /**
         * the type of the property - a project specific enum
         */
         am_SoundPropertyType_pe type;
        /**
         * the actual value of the property
         */
         int16_t value;
    
        am_SoundProperty_s() = default;
        am_SoundProperty_s(const am_SoundPropertyType_pe& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    /**
     * data type depends of am_EarlyDataType_e:
    volume_t in case of ED_SOURCE_VOLUME,
     *  ED_SINK_VOLUME 
    soundProperty_t in case of ED_SOURCE_PROPERTY,
     *  ED_SINK_PROPERTY
     */
    /**
     * data type depends of am_EarlyDataType_e:
    volume_t in case of ED_SOURCE_VOLUME,
     *  ED_SINK_VOLUME 
    soundProperty_t in case of ED_SOURCE_PROPERTY,
     *  ED_SINK_PROPERTY
     */
    typedef CommonAPI::Variant<am_volume_t, am_SoundProperty_s>  am_EarlyData_u;
    /**
     * data type depends of am_EarlyDataType_e:
    sourceID in case of ED_SOURCE_VOLUME,
     *  ED_SOURCE_PROPERTY
    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
     */
    /**
     * data type depends of am_EarlyDataType_e:
    sourceID in case of ED_SOURCE_VOLUME,
     *  ED_SOURCE_PROPERTY
    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
     */
    typedef CommonAPI::Variant<am_sinkID_t, am_sourceID_t>  am_DataType_u;
    struct am_EarlyData_s: CommonAPI::SerializableStruct {
         am_EarlyDataType_e type;
         am_DataType_u sinksource;
         am_EarlyData_u data;
    
        am_EarlyData_s() = default;
        am_EarlyData_s(const am_EarlyDataType_e& type, const am_DataType_u& sinksource, const am_EarlyData_u& data);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeVariantType();
            typeOutputStream.writeVariantType();
        }
    };
    typedef std::vector<am_EarlyData_s> am_EarlyData_L;
    /**
     * Here are all SoundProperties that can be set via the CommandInterface. Product
     *  specific
     */
    /**
     * Here are all SoundProperties that can be set via the CommandInterface. Product
     *  specific
     */
    typedef uint16_t am_MainSoundPropertyType_pe;
    /**
     * struct describung mainsound property
     */
    /**
     * struct describung mainsound property
     */
    struct am_MainSoundProperty_s: CommonAPI::SerializableStruct {
        /**
         * the type of the property
         */
         am_MainSoundPropertyType_pe type;
        /**
         * the actual value
         */
         int16_t value;
    
        am_MainSoundProperty_s() = default;
        am_MainSoundProperty_s(const am_MainSoundPropertyType_pe& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    typedef std::vector<am_MainSoundProperty_s> am_MainSoundProperty_L;
    /**
     * gives the type of the Notification.
     */
    /**
     * gives the type of the Notification.
     */
    typedef uint16_t am_NotificationType_pe;
    enum class am_NotificationStatus_e: int32_t {
        NS_UNKNOWN = 0,
        /**
         * No notification, the function is turned off
         */
        NS_OFF = 1,
        /**
         * Periodic notifications are sent out. The period in ms is given by
         *  am_NotificationParameter
         */
        NS_PERIODIC = 2,
        /**
         * The notification is sent out when the minimum given by am_NotificationParameter
         *  is reached.
         */
        NS_MINIMUM = 3,
        /**
         * The notification is sent out when the maximum given by am_NotificationParameter
         *  is reached.
         */
        NS_MAXIMUM = 4,
        /**
         * The notification is sent out when a change happened. The Resolution of the
         *  change is defined by am_NotificationParameter.
         */
        NS_CHANGE_ = 5,
        NS_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_NotificationStatus_eComparator;
    /**
     * This struct holds information about the configuration for notifications
     */
    /**
     * This struct holds information about the configuration for notifications
     */
    struct am_NotificationConfiguration_s: CommonAPI::SerializableStruct {
        /**
         * The notification type of the notification
         */
         am_NotificationType_pe type;
        /**
         * The Notification status. This can be periodic, min/max value based or even off
         *  for example
         */
         am_NotificationStatus_e status;
        /**
         * This gives additional information to the notification status. 
        Relation
         *  between notification status and the value:
        NS_PERIODIC - the period in
         *  ms
        NS_MINIMUM - the minimum value that triggers the notification
        NS_MAXIMUM
         *  - the maximum value that triggers the notifcation
        NS_CHANGE - the resolution
         *  of the change value
         */
         int16_t parameter;
    
        am_NotificationConfiguration_s() = default;
        am_NotificationConfiguration_s(const am_NotificationType_pe& type, const am_NotificationStatus_e& status, const int16_t& parameter);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    typedef std::vector<am_NotificationConfiguration_s> am_NotificationConfiguration_L;
    /**
     * a domain ID
     */
    /**
     * a domain ID
     */
    typedef uint16_t am_domainID_t;
    /**
     * This project specific value classifies the format in which data is exchanged
     *  within a connection.
     */
    /**
     * This project specific value classifies the format in which data is exchanged
     *  within a connection.
     */
    typedef uint16_t am_ConnectionFormat_pe;
    /**
     * This represents one "hopp" in a route
     */
    /**
     * This represents one "hopp" in a route
     */
    struct am_RoutingElement_s: CommonAPI::SerializableStruct {
        /**
         * the source ID
         */
         am_sourceID_t sourceID;
        /**
         * the sinkID
         */
         am_sinkID_t sinkID;
        /**
         * the domainID the routeElement is in
         */
         am_domainID_t domainID;
        /**
         * the connectionformat that is used for the route
         */
         am_ConnectionFormat_pe connectionFormat;
    
        am_RoutingElement_s() = default;
        am_RoutingElement_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_domainID_t& domainID, const am_ConnectionFormat_pe& connectionFormat);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    typedef std::vector<am_RoutingElement_s> am_RoutingElement_L;
    typedef std::vector<am_SoundProperty_s> am_SoundProperty_L;
    /**
     * time in ms!
     */
    /**
     * time in ms!
     */
    typedef int16_t am_time_t;
    /**
     * For products, different ramp types can be defined here.
    It is in the
     *  responsibility of the product to make sure that the routing plugins are aware
     *  of the ramp types used.
     */
    /**
     * For products, different ramp types can be defined here.
    It is in the
     *  responsibility of the product to make sure that the routing plugins are aware
     *  of the ramp types used.
     */
    typedef uint16_t am_RampType_pe;
    /**
     * This datatype determines if a sourceID or a sinkID is used in the union
     *  following
     */
    enum class am_VolumeType_e: int32_t {
        VT_UNKNOWN = 0,
        /**
         * the following type is a sink
         */
        VT_SINK = 1,
        /**
         * the following type is a source
         */
        VT_SOURCE = 2,
        VT_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_VolumeType_eComparator;
    /**
     * This types describe a mixed description for source and sinks volumes.
     */
    /**
     * This types describe a mixed description for source and sinks volumes.
     */
    struct am_Volumes_s: CommonAPI::SerializableStruct {
        /**
         * describes the type of the volume: source or sink.
         */
         am_VolumeType_e volumeType;
        /**
         * either sourceID or sinkID
         */
         am_DataType_u volumeID;
        /**
         * The volume
         */
         am_volume_t volume;
        /**
         * the ramp that shall be driven
         */
         am_RampType_pe ramp;
        /**
         * the time for the ramp
         */
         am_time_t time;
    
        am_Volumes_s() = default;
        am_Volumes_s(const am_VolumeType_e& volumeType, const am_DataType_u& volumeID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeVariantType();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    typedef std::vector<am_Volumes_s> am_Volumes_L;
    typedef std::vector<am_ConnectionFormat_pe> am_ConnectionFormat_L;
    typedef bool am_bool_t;
    typedef std::vector<am_bool_t> am_Convertion_L;
    /**
     * a gateway ID
     */
    /**
     * a gateway ID
     */
    typedef uint16_t am_gatewayID_t;
    /**
     * a crossfader ID
     */
    /**
     * a crossfader ID
     */
    typedef uint16_t am_crossfaderID_t;
    /**
     * speed
     */
    /**
     * speed
     */
    typedef uint16_t am_speed_t;
    /**
     * describes the active sink of a crossfader.
     */
    enum class am_HotSink_e: int32_t {
        /**
         * default
         */
        HS_UNKNOWN = 0,
        /**
         * sinkA is active
         */
        HS_SINKA = 1,
        /**
         * sinkB is active
         */
        HS_SINKB = 2,
        /**
         * the crossfader is in the transition state
         */
        HS_INTERMEDIATE = 3,
        HS_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_HotSink_eComparator;
    enum class am_DomainState_e: int32_t {
        /**
         * default
         */
        DS_UNKNOWN = 0,
        /**
         * the domain is controlled by the daemon
         */
        DS_CONTROLLED = 1,
        /**
         * the domain is independent starting up
         */
        DS_INDEPENDENT_STARTUP = 1,
        /**
         * the domain is independent running down
         */
        DS_INDEPENDENT_RUNDOWN = 2,
        DS_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_DomainState_eComparator;
    /**
     * the errors of the audiomanager. All possible errors are in here. This enum is
     *  used widely as return parameter.
     */
    enum class am_Error_e: int32_t {
        /**
         * no error - positive reply
         */
        E_OK = 0,
        /**
         * default
         */
        E_UNKNOWN = 1,
        /**
         * value out of range
         */
        E_OUT_OF_RANGE = 2,
        /**
         * not used
         */
        E_NOT_USED = 3,
        /**
         * a database error occurred
         */
        E_DATABASE_ERROR = 4,
        /**
         * the desired object already exists
         */
        E_ALREADY_EXISTS = 5,
        /**
         * there is no change
         */
        E_NO_CHANGE = 6,
        /**
         * the desired action is not possible
         */
        E_NOT_POSSIBLE = 7,
        /**
         * the desired object is non existent
         */
        E_NON_EXISTENT = 8,
        /**
         * the asynchronous action was aborted
         */
        E_ABORTED = 9,
        /**
         * This error is returned in case a connect is issued with a connectionFormat that
         *  cannot be selected for the connection. This could be either due to the
         *  capabilities of a source or a sink or gateway compatibilities for example
         */
        E_WRONG_FORMAT = 10,
        E_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Error_eComparator;
    enum class am_InterruptState_e: int32_t {
        /**
         * default
         */
        IS_UNKNOWN = 0,
        /**
         * the interrupt state is off - no interrupt
         */
        IS_OFF = 1,
        /**
         * the interrupt state is interrupted - the interrupt is active
         */
        IS_INTERRUPTED = 2,
        IS_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_InterruptState_eComparator;
    /**
     * This enumeration is used to define the type of the action that is correlated to
     *  a handle.
     */
    enum class am_Handle_e: int32_t {
        H_UNKNOWN = 0,
        H_CONNECT = 1,
        H_DISCONNECT = 2,
        H_SETSOURCESTATE = 3,
        H_SETSINKVOLUME = 4,
        H_SETSOURCEVOLUME = 5,
        H_SETSINKSOUNDPROPERTY = 6,
        H_SETSOURCESOUNDPROPERTY = 7,
        H_SETSINKSOUNDPROPERTIES = 8,
        H_SETSOURCESOUNDPROPERTIES = 9,
        H_CROSSFADE = 10,
        H_SETVOLUMES = 11,
        H_SETSINKNOTIFICATION = 12,
        H_SETSOURCENOTIFICATION = 13,
        H_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Handle_eComparator;
    /**
     * The source state reflects the state of the source
     */
    enum class am_SourceState_e: int32_t {
        SS_UNKNNOWN = 0,
        /**
         * The source can be activly heared
         */
        SS_ON = 1,
        /**
         * The source cannot be heared
         */
        SS_OFF = 2,
        /**
         * The source is paused. Meaning it cannot be heared but should be prepared to
         *  play again soon.
         */
        SS_PAUSED = 3,
        SS_MAX
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_SourceState_eComparator;
    /**
     * This enum describes the ready state of the routing part
     */
    enum class am_RoutingReady_e: int32_t {
        RR_UNKNOWN = 0,
        RR_READY = 1,
        RR_RUNDOWN = 2
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_RoutingReady_eComparator;
    /**
     * a list of routing elements that lead from source to sink
     */
    /**
     * a list of routing elements that lead from source to sink
     */
    struct am_Route_s: CommonAPI::SerializableStruct {
        /**
         * the sourceID where the route starts
         */
         am_sourceID_t sourceID;
        /**
         * the sinkID where the route ends
         */
         am_sinkID_t sinkID;
        /**
         * the actual route as list of routing elements
         */
         am_RoutingElement_L route;
    
        am_Route_s() = default;
        am_Route_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_RoutingElement_L& route);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * This struct describes the attribiutes of a crossfader.
     */
    /**
     * This struct describes the attribiutes of a crossfader.
     */
    struct am_Crossfader_s: CommonAPI::SerializableStruct {
        /**
         * This is the ID of the crossfader, it is unique in the system. There are 2 ways,
         *  ID can be created: either it is assigned during the registration process (in a
         *  dynamic context, uniqueness will be ensured by the AudioManager daemon), or it
         *  is a fixed (the project has to ensure the uniqueness of the ID).
         */
         am_crossfaderID_t crossfaderID;
        /**
         * The name of the crossfader. Must be unique in the whole system.
         */
         std::string name;
        /**
         * The sinkID of the SinkA. Sinks shall be registered before registering the
         *  crossfader.
         */
         am_sinkID_t sinkID_A;
        /**
         * The sinkID of the SinkB. Sinks shall be registered before registering the
         *  crossfader.
         */
         am_sinkID_t sinkID_B;
        /**
         * The sourceID of the crossfader source. The source shall be registered before
         *  the crossfader.
         */
         am_sourceID_t sourceID;
        /**
         * This enum can have 3 states:
        
            HS_SINKA sinkA is the current hot one,
         *  sinkB is not audible
            HS_SINKB sinkB is the current hot one, sinkB is not
         *  audible
            HS_INTERMEDIATE the fader is stuck in between a cross-fading
         *  action. This could be due to an abort or an error. Before using the
         *  crossfader, it must be set to either HS_SINKA or HS_SINKB.
         */
         am_HotSink_e hotSink;
    
        am_Crossfader_s() = default;
        am_Crossfader_s(const am_crossfaderID_t& crossfaderID, const std::string& name, const am_sinkID_t& sinkID_A, const am_sinkID_t& sinkID_B, const am_sourceID_t& sourceID, const am_HotSink_e& hotSink);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
        }
    };
    /**
     * This struct describes the attributes of a gateway.
     */
    /**
     * This struct describes the attributes of a gateway.
     */
    struct am_Gateway_s: CommonAPI::SerializableStruct {
        /**
         * This is the ID of the gateway, it is unique in the system. There are 2 ways, ID
         *  can be created: either it is assigned during the registration process (in a
         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
         *  is a fixed (the project has to ensure the uniqueness of the ID).
         */
         am_gatewayID_t gatewayID;
        /**
         * The name of the gateway. Must be unique in the whole system.
         */
         std::string name;
        /**
         * The sinkID of the gateway sink-end. The sink is a full blown sink with
         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sinks of
         *  a gateway as non-visible. Care needs to be taken that the connectionsFormats
         *  match with the ones in the conversionMatrix. If the sink is located in the
         *  controllingDomain, the ID needs to be retrieved by registering the sink before
         *  registering the gateway. In case the sink is in a different domain, the ID
         *  needs to be retrieved via peeking.
         */
         am_sinkID_t sinkID;
        /**
         * The sourceID of the gateway sink-end. The sink is a full blown source with
         *  connectionFormats, sinkClassIDs etc... It makes sense to register the sources
         *  of a gateway as non-visible. Care needs to be taken that the
         *  connectionsFormats match with the ones in the conversionMatrix. If the source
         *  is located in the controllingDomain, the ID needs to be retrieved by
         *  registering the source before registering the gateway. In case the source is
         *  in a different domain, the ID needs to be retrieved via peeking.
         */
         am_sourceID_t sourceID;
        /**
         * The ID of the sink. If the domain is the same like the controlling domain, the
         *  ID is known due to registration. If the domain is different, the ID needs to
         *  be retrieved via peeking.
         */
         am_domainID_t domainSinkID;
        /**
         * The ID of the source. If the domain is the same like the controlling domain,
         *  the ID is known due to registration. If the domain is different, the ID needs
         *  to be retrieved via peeking.
         */
         am_domainID_t domainSourceID;
        /**
         * This is the ID of the domain that registers the gateway.
         */
         am_domainID_t controlDomainID;
        /**
         * This is the list of available formats on the source side of the gateway. It is
         *  not defined during the gateway registration but copied from the source
         *  registration.
         */
         am_ConnectionFormat_L listSourceFormats;
        /**
         * This is the list of available formats on the sink side of the gateway. It is
         *  not defined during the gateway registration but copied from the sink
         *  registration.
         */
         am_ConnectionFormat_L listSinkFormats;
        /**
         * This is matrix holding information about the conversion capability of the
         *  gateway, it's length is defined by the length(listSinkFormats) x
         *  length(listSourceFormats).
        If a SinkFormat can be converted into a
         *  SourceFormat, the vector will hold a 1, if no conversion is possible, a
         *  0.
        The data is stored row orientated, where the rows are related to the
         *  sinksFormats and the columns to the sourceFormats. The first value will hold
         *  the conversion information from the first sourceFormat to the first sinkFormat
         *  for example and the seventh value the information about the 3rd sinkFormat to
         *  the 1st sourceFormat in case we would have 3 sourceFormats.
         */
         am_Convertion_L convertionMatrix;
    
        am_Gateway_s() = default;
        am_Gateway_s(const am_gatewayID_t& gatewayID, const std::string& name, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_domainID_t& domainSinkID, const am_domainID_t& domainSourceID, const am_domainID_t& controlDomainID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeBoolType();
            typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * a handle is used for asynchronous operations and is uniquely assigned for each
     *  of this operations
     */
    /**
     * a handle is used for asynchronous operations and is uniquely assigned for each
     *  of this operations
     */
    struct am_Handle_s: CommonAPI::SerializableStruct {
        /**
         * the handletype
         */
         am_Handle_e handleType;
        /**
         * the handle as value
         */
         uint16_t handle;
    
        am_Handle_s() = default;
        am_Handle_s(const am_Handle_e& handleType, const uint16_t& handle);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    /**
     * struct that holds attribiutes of a mainconnection
     */
    /**
     * struct that holds attribiutes of a mainconnection
     */
    struct am_MainConnection_s: CommonAPI::SerializableStruct {
        /**
         * the assigned ID
         */
         am_mainConnectionID_t mainConnectionID;
        /**
         * the current connection state
         */
         am_ConnectionState_e connectionState;
        /**
         * the sinkID
         */
         am_sinkID_t sinkID;
        /**
         * the sourceID
         */
         am_sourceID_t sourceID;
        /**
         * the delay of the connection
         */
         am_timeSync_t delay;
        /**
         * the list of sub connection IDs the mainconnection consists of
         */
         am_ConnectionID_L listConnectionID;
    
        am_MainConnection_s() = default;
        am_MainConnection_s(const am_mainConnectionID_t& mainConnectionID, const am_ConnectionState_e& connectionState, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_timeSync_t& delay, const am_ConnectionID_L& listConnectionID);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * This struct holds the payload of a notification.
     */
    /**
     * This struct holds the payload of a notification.
     */
    struct am_NotificationPayload_s: CommonAPI::SerializableStruct {
        /**
         * This defines the notification type
         */
         am_NotificationType_pe type;
        /**
         * This is finally the value of the notification. It's meaning depends on the
         *  notificationType
         */
         int16_t value;
    
        am_NotificationPayload_s() = default;
        am_NotificationPayload_s(const am_NotificationType_pe& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    /**
     * This struct describes the attribiutes of a sink
     */
    /**
     * This struct describes the attribiutes of a sink
     */
    struct am_Sink_s: CommonAPI::SerializableStruct {
        /**
         * This is the ID of the sink, it is unique in the system. There are 2 ways, ID
         *  can be created: either it is assigned during the registration process (in a
         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
         *  is a fixed (the project has to ensure the uniqueness of the ID).
         */
         am_sinkID_t sinkID;
        /**
         * The name of the sink. Must be unique in the whole system.
         */
         std::string name;
        /**
         * The domainID is the domain the sink belongs to. A sink can only be in one
         *  domain.
         */
         am_domainID_t domainID;
        /**
         * The sinkClassID references to a sinkClass. With the help of classification,
         *  rules can be setup to define the system behaviour.
         */
         am_sinkClass_t sinkClassID;
        /**
         * This is the volume of the sink. It is set by the AudioManagerController.
         */
         am_volume_t volume;
        /**
         * This Boolean flag indicates whether a sink is visible to the commandInterface
         *  or not. If the User must have the possibility to choose the source in the HMI,
         *  it must be visible. But there are also good reasons for invisible sinks, for
         *  example if the sink is part of a crossfader or gateway. HMI relevant changes
         *  in visible sinks will be automatically reported by the daemon to the
         *  commandInterface.
         */
         bool visible;
        /**
         * This attribute reflects the availability of the sink. There are several reasons
         *  why a sink could be not available for the moment: for example the shutdown of
         *  a sink because of overtemperature or over- &amp; undervoltage. The
         *  availability consists of two pieces of information:
        
            Availablility: the
         *  status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
           
         *  AvailabilityReason: this informs about the last reason for a change in
         *  availability. The reasons itself are product specific.
         */
         am_Availability_s available;
        /**
         * This attribute reflects the muteState of the sink. The information is not the
         *  "real" state of the sink, but the HMI representation for he commandInterface
         *  controlled by the AudioManagerController.
         */
         am_MuteState_e muteState;
        /**
         * This is the representation of the Volume for the commandInterface. It is used
         *  by the HMI to set the volume of a sink, the AudioManagerController has to
         *  transform this into real source and sink volumes.
         */
         am_mainVolume_t mainVolume;
        /**
         * This is the list of soundProperties, that the sink is capable of. The
         *  soundProperties itself are project specific. For sinks, a possible
         *  soundProperty could be for example settings.
         */
         am_SoundProperty_L listSoundProperties;
        /**
         * This list holds information about the formats that the Source is capable of
         *  supporting when delivering audio.
         */
         am_ConnectionFormat_L listConnectionFormats;
        /**
         * This is the list of the available mainSoundProperties. The principle is the
         *  same than with soundProperties, but they are only visible to the
         *  CommandInterface.
         */
         am_MainSoundProperty_L listMainSoundProperties;
        /**
         * This is the list of the MainNotificationConfigurations. These notifications
         *  work on the level of command interface.
         */
         am_NotificationConfiguration_L listMainNotificationConfigurations;
        /**
         * This is the list of the NotificationConfigurations. These notifications work on
         *  the level of RoutingPlugins.
         */
         am_NotificationConfiguration_L listNotificationConfigurations;
    
        am_Sink_s() = default;
        am_Sink_s(const am_sinkID_t& sinkID, const std::string& name, const am_domainID_t& domainID, const am_sinkClass_t& sinkClassID, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_MuteState_e& muteState, const am_mainVolume_t& mainVolume, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeBoolType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * This struct describes the attribiutes of a source
     */
    /**
     * This struct describes the attribiutes of a source
     */
    struct am_Source_s: CommonAPI::SerializableStruct {
        /**
         * This is the ID of the source, it is unique in the system. There are 2 ways, ID
         *  can be created: either it is assigned during the registration process (in a
         *  dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
         *  is a fixed (the project has to ensure the uniqueness of the ID).
         */
         am_sourceID_t sourceID;
        /**
         * The domainID is the domain the source belongs to. A source can only be in one
         *  domain.
         */
         am_domainID_t domainID;
        /**
         * The name of the source. Must be unique in the whole system.
         */
         std::string name;
        /**
         * the sourceClassID, indicates the class the source is in. This information can
         *  be used by the Controller to implement different behaviour for different
         *  classes.
         */
         am_sourceClass_t sourceClassID;
        /**
         * The source state is an indication towards the source if it is actively heard or
         *  not. The source can use this information to implement features like automatic
         *  spin down of CD's in case the CD is not the active source or AF following of a
         *  tuner that is not actively heard. The source state is set by the
         *  AudioManagerController.There are 3 possible states:
        
            SS_ON: the source
         *  is active
            SS_OFF: the source is off
            SS_PAUSED: the source is paused
         *  and not active.
         */
         am_SourceState_e sourceState;
        /**
         * This is the volume of the source. It is set by the AudioManagerController. It
         *  is used to adopt different audiolevels in a system and mixing of sources (e.g.
         *  navigation hints &amp; music).
         */
         am_volume_t volume;
        /**
         * This Boolean flag indicates whether a source is visible to the commandInterface
         *  or not. If the User must have the possibility to choose the source in the HMI,
         *  it must be visible. But there are also good reasons for invisible sources, for
         *  example if the source is part of a crossfader or gateway. HMI relevant changes
         *  in visible sources will be automatically reported by the daemon to the
         *  commandInterface.
         */
         bool visible;
        /**
         * This attribute reflects the availability of the source. There are several
         *  reasons why a source could be not available for the moment. For example a CD
         *  player which has no CD entered in the slot can be unavailable, or a USB player
         *  with no or unreadable stick attached. Other scenarios involve the shutdown of
         *  a source because of overtemperature or over- &amp; undervoltage. The
         *  availability consists of two informations:
        
            Availablility: the status
         *  itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
           
         *  AvailabilityReason: this informs about the last reason for a change in
         *  availability. The reasons itself are product specific.
         */
         am_Availability_s available;
        /**
         * Some special sources can have special behaviors, the are so called "Low Level
         *  Interrupts". Here the current status is documented. The information can be
         *  used by the AudioManagerController to react to the changes by for example
         *  lowering the volume of the mainSources. The two states are
        
            IS_OFF: the
         *  interrupt is not active at the moment
            IS_INTERRUPTED: the interrupt is
         *  playing at the moment.
         */
         am_InterruptState_e interruptState;
        /**
         * This is the list of soundProperties, that the source is capable of. The
         *  soundProperties itself are project specific. For sources, a possible
         *  soundProperty could be navigation volume offset, for example.
         */
         am_SoundProperty_L listSoundProperties;
        /**
         * This list holds information about the formats that the Source is capable of
         *  supporting when delivering audio.
         */
         am_ConnectionFormat_L listConnectionFormats;
        /**
         * This is the list of the available mainSoundProperties. The principle is the
         *  same than with soundProperties, but they are only visible to the
         *  CommandInterface.
         */
         am_MainSoundProperty_L listMainSoundProperties;
        /**
         * The list of MainNotificationConfigurations. These notifications work on the
         *  level of CommandInterface.
         */
         am_NotificationConfiguration_L listMainNotificationConfigurations;
        /**
         * The list of MainNotificationConfigurations. These notifications work on the
         *  level of RoutingInterface.
         */
         am_NotificationConfiguration_L listNotificationConfigurations;
    
        am_Source_s() = default;
        am_Source_s(const am_sourceID_t& sourceID, const am_domainID_t& domainID, const std::string& name, const am_sourceClass_t& sourceClassID, const am_SourceState_e& sourceState, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_InterruptState_e& interruptState, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeBoolType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * This struct describes the attribiutes of a domain
     */
    /**
     * This struct describes the attribiutes of a domain
     */
    struct am_Domain_s: CommonAPI::SerializableStruct {
        /**
         * the domain ID
         */
         am_domainID_t domainID;
        /**
         * the name of the domain
         */
         std::string name;
        /**
         * the busname. This is equal to a plugin name and is used to dispatch messages to
         *  the elements of a plugin
         */
         std::string busname;
        /**
         * the name of the node
         */
         std::string nodename;
        /**
         * indicated if the domain is independent at startup or not
         */
         bool early;
        /**
         * indicates if the domain registration is complete or not
         */
         bool complete;
        /**
         * the current domain state
         */
         am_DomainState_e state;
    
        am_Domain_s() = default;
        am_Domain_s(const am_domainID_t& domainID, const std::string& name, const std::string& busname, const std::string& nodename, const bool& early, const bool& complete, const am_DomainState_e& state);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeBoolType();
            typeOutputStream.writeBoolType();
            typeOutputStream.writeInt32Type();
        }
    };
    /**
     * a connection
     */
    /**
     * a connection
     */
    struct am_Connection_s: CommonAPI::SerializableStruct {
        /**
         * the assigned ID
         */
         am_connectionID_t connectionID;
        /**
         * the source the audio flows from
         */
         am_sourceID_t sourceID;
        /**
         * the sink the audio flows to
         */
         am_sinkID_t sinkID;
        /**
         * the delay of the conneciton
         */
         am_timeSync_t delay;
        /**
         * the used connectionformat
         */
         am_ConnectionFormat_pe connectionFormat;
    
        am_Connection_s() = default;
        am_Connection_s(const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_ConnectionFormat_pe& connectionFormat);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeUInt16Type();
        }
    };

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Availability_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Availability_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_Availability_eComparator {
    inline bool operator()(const am_Availability_e& lhs, const am_Availability_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_HotSink_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_HotSink_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_HotSink_eComparator {
    inline bool operator()(const am_HotSink_e& lhs, const am_HotSink_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_ConnectionState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_ConnectionState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_ConnectionState_eComparator {
    inline bool operator()(const am_ConnectionState_e& lhs, const am_ConnectionState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_DomainState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_DomainState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_DomainState_eComparator {
    inline bool operator()(const am_DomainState_e& lhs, const am_DomainState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_EarlyDataType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_EarlyDataType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_EarlyDataType_eComparator {
    inline bool operator()(const am_EarlyDataType_e& lhs, const am_EarlyDataType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Error_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Error_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_Error_eComparator {
    inline bool operator()(const am_Error_e& lhs, const am_Error_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_MuteState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_MuteState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_MuteState_eComparator {
    inline bool operator()(const am_MuteState_e& lhs, const am_MuteState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_InterruptState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_InterruptState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_InterruptState_eComparator {
    inline bool operator()(const am_InterruptState_e& lhs, const am_InterruptState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_VolumeType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_VolumeType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_VolumeType_eComparator {
    inline bool operator()(const am_VolumeType_e& lhs, const am_VolumeType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_NotificationStatus_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_NotificationStatus_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_NotificationStatus_eComparator {
    inline bool operator()(const am_NotificationStatus_e& lhs, const am_NotificationStatus_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Handle_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Handle_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_Handle_eComparator {
    inline bool operator()(const am_Handle_e& lhs, const am_Handle_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_SourceState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_SourceState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_SourceState_eComparator {
    inline bool operator()(const am_SourceState_e& lhs, const am_SourceState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_RoutingReady_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_RoutingReady_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_RoutingReady_eComparator {
    inline bool operator()(const am_RoutingReady_e& lhs, const am_RoutingReady_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

bool operator==(const am_Route_s& lhs, const am_Route_s& rhs);
inline bool operator!=(const am_Route_s& lhs, const am_Route_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs);
inline bool operator!=(const am_Availability_s& lhs, const am_Availability_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs);
inline bool operator!=(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs);
inline bool operator!=(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs);
inline bool operator!=(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs);
inline bool operator!=(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs);
inline bool operator!=(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs);
inline bool operator!=(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs);
inline bool operator!=(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs);
inline bool operator!=(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs);
inline bool operator!=(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs);
inline bool operator!=(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs);
inline bool operator!=(const am_Handle_s& lhs, const am_Handle_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs);
inline bool operator!=(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs);
inline bool operator!=(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs);
inline bool operator!=(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs);
inline bool operator!=(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs);
inline bool operator!=(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs);
inline bool operator!=(const am_Sink_s& lhs, const am_Sink_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Source_s& lhs, const am_Source_s& rhs);
inline bool operator!=(const am_Source_s& lhs, const am_Source_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs);
inline bool operator!=(const am_Domain_s& lhs, const am_Domain_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs);
inline bool operator!=(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs);
inline bool operator!=(const am_Connection_s& lhs, const am_Connection_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs);
inline bool operator!=(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
    return !(lhs == rhs);
}


static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.genivi.am";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

} // namespace am

} // namespace genivi
} // namespace org

namespace CommonAPI {

    template<>
    struct BasicTypeWriter<org::genivi::am::am_Availability_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_Availability_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_Availability_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_HotSink_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_ConnectionState_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_DomainState_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_EarlyDataType_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_Error_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_Error_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_Error_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_MuteState_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_InterruptState_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_VolumeType_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_NotificationStatus_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_Handle_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_Handle_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_Handle_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_SourceState_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::am::am_RoutingReady_e> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };

}


namespace std {
    //Hash for am_Availability_e
    template<>
    struct hash<org::genivi::am::am_Availability_e> {
        inline size_t operator()(const org::genivi::am::am_Availability_e& am_Availability_e) const {
            return static_cast<int32_t>(am_Availability_e);
        }
    };
    //Hash for am_HotSink_e
    template<>
    struct hash<org::genivi::am::am_HotSink_e> {
        inline size_t operator()(const org::genivi::am::am_HotSink_e& am_HotSink_e) const {
            return static_cast<int32_t>(am_HotSink_e);
        }
    };
    //Hash for am_ConnectionState_e
    template<>
    struct hash<org::genivi::am::am_ConnectionState_e> {
        inline size_t operator()(const org::genivi::am::am_ConnectionState_e& am_ConnectionState_e) const {
            return static_cast<int32_t>(am_ConnectionState_e);
        }
    };
    //Hash for am_DomainState_e
    template<>
    struct hash<org::genivi::am::am_DomainState_e> {
        inline size_t operator()(const org::genivi::am::am_DomainState_e& am_DomainState_e) const {
            return static_cast<int32_t>(am_DomainState_e);
        }
    };
    //Hash for am_EarlyDataType_e
    template<>
    struct hash<org::genivi::am::am_EarlyDataType_e> {
        inline size_t operator()(const org::genivi::am::am_EarlyDataType_e& am_EarlyDataType_e) const {
            return static_cast<int32_t>(am_EarlyDataType_e);
        }
    };
    //Hash for am_Error_e
    template<>
    struct hash<org::genivi::am::am_Error_e> {
        inline size_t operator()(const org::genivi::am::am_Error_e& am_Error_e) const {
            return static_cast<int32_t>(am_Error_e);
        }
    };
    //Hash for am_MuteState_e
    template<>
    struct hash<org::genivi::am::am_MuteState_e> {
        inline size_t operator()(const org::genivi::am::am_MuteState_e& am_MuteState_e) const {
            return static_cast<int32_t>(am_MuteState_e);
        }
    };
    //Hash for am_InterruptState_e
    template<>
    struct hash<org::genivi::am::am_InterruptState_e> {
        inline size_t operator()(const org::genivi::am::am_InterruptState_e& am_InterruptState_e) const {
            return static_cast<int32_t>(am_InterruptState_e);
        }
    };
    //Hash for am_VolumeType_e
    template<>
    struct hash<org::genivi::am::am_VolumeType_e> {
        inline size_t operator()(const org::genivi::am::am_VolumeType_e& am_VolumeType_e) const {
            return static_cast<int32_t>(am_VolumeType_e);
        }
    };
    //Hash for am_NotificationStatus_e
    template<>
    struct hash<org::genivi::am::am_NotificationStatus_e> {
        inline size_t operator()(const org::genivi::am::am_NotificationStatus_e& am_NotificationStatus_e) const {
            return static_cast<int32_t>(am_NotificationStatus_e);
        }
    };
    //Hash for am_Handle_e
    template<>
    struct hash<org::genivi::am::am_Handle_e> {
        inline size_t operator()(const org::genivi::am::am_Handle_e& am_Handle_e) const {
            return static_cast<int32_t>(am_Handle_e);
        }
    };
    //Hash for am_SourceState_e
    template<>
    struct hash<org::genivi::am::am_SourceState_e> {
        inline size_t operator()(const org::genivi::am::am_SourceState_e& am_SourceState_e) const {
            return static_cast<int32_t>(am_SourceState_e);
        }
    };
    //Hash for am_RoutingReady_e
    template<>
    struct hash<org::genivi::am::am_RoutingReady_e> {
        inline size_t operator()(const org::genivi::am::am_RoutingReady_e& am_RoutingReady_e) const {
            return static_cast<int32_t>(am_RoutingReady_e);
        }
    };
}

#endif // ORG_GENIVI_am_H_

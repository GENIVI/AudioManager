/*
* This file was generated by the CommonAPI Generators.
*
 * Copyright (C) 2013, BMW AG
 *
 * \author Christian Linke, christian.linke@bmw.de BMW 2012,2013
*/
#ifndef ORG_GENIVI_am_H_
#define ORG_GENIVI_am_H_



#define COMMONAPI_INTERNAL_COMPILATION

#include <CommonAPI/InputStream.h>
#include <CommonAPI/OutputStream.h>
#include <CommonAPI/SerializableStruct.h>
#include <CommonAPI/SerializableVariant.h>
#include <CommonAPI/types.h>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {

namespace am {
    typedef uint16_t am_sourceID_t;
    
    typedef uint16_t am_mainConnectionID_t;
    
    typedef int16_t am_timeSync_t;
    
    typedef uint16_t am_sinkID_t;
    
    enum class am_ConnectionState_e: int32_t {
        CS_UNKNOWN = 0,
        CS_CONNECTING = 1,
        CS_CONNECTED = 2,
        CS_DISCONNECTING = 3,
        CS_DISCONNECTED = 4,
        CS_SUSPENDED = 5,
        CS_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_ConnectionState_eComparator;
    
    struct am_MainConnectionType_s: CommonAPI::SerializableStruct {
        am_mainConnectionID_t mainConnectionID;
        am_sourceID_t sourceID;
        am_sinkID_t sinkID;
        am_timeSync_t delay;
        am_ConnectionState_e connectionState;
    
        am_MainConnectionType_s() = default;
        am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_ConnectionState_e& connectionState);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeInt32Type();
        }
    };
    
    typedef std::vector<am_MainConnectionType_s> am_MainConnection_L;
    
    typedef uint16_t am_ClassProperty_pe;
    
    struct am_ClassProperty_s: CommonAPI::SerializableStruct {
        am_ClassProperty_pe classProperty;
        int16_t value;
    
        am_ClassProperty_s() = default;
        am_ClassProperty_s(const am_ClassProperty_pe& classProperty, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_ClassProperty_s> am_ClassProperty_L;
    
    typedef uint16_t am_sinkClass_t;
    
    struct am_SinkClass_s: CommonAPI::SerializableStruct {
        am_sinkClass_t sinkClassID;
        std::string name;
        am_ClassProperty_L listClassProperties;
    
        am_SinkClass_s() = default;
        am_SinkClass_s(const am_sinkClass_t& sinkClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    typedef std::vector<am_SinkClass_s> am_SinkClass_L;
    
    typedef int16_t am_mainVolume_t;
    
    typedef uint16_t am_AvailabilityReason_pe;
    
    enum class am_Availability_e: int32_t {
        A_UNKNOWN = 0,
        A_AVAILABLE = 1,
        A_UNAVAILABLE = 2,
        A_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Availability_eComparator;
    
    enum class am_MuteState_e: int32_t {
        MS_UNKNOWN = 0,
        MS_MUTED = 1,
        MS_UNMUTED = 2,
        MS_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_MuteState_eComparator;
    
    struct am_Availability_s: CommonAPI::SerializableStruct {
        am_Availability_e availability;
        am_AvailabilityReason_pe availabilityReason;
    
        am_Availability_s() = default;
        am_Availability_s(const am_Availability_e& availability, const am_AvailabilityReason_pe& availabilityReason);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    
    struct am_SinkType_s: CommonAPI::SerializableStruct {
        am_sinkID_t sinkID;
        std::string name;
        am_Availability_s availability;
        am_mainVolume_t volume;
        am_MuteState_e muteState;
        am_sinkClass_t sinkClassID;
    
        am_SinkType_s() = default;
        am_SinkType_s(const am_sinkID_t& sinkID, const std::string& name, const am_Availability_s& availability, const am_mainVolume_t& volume, const am_MuteState_e& muteState, const am_sinkClass_t& sinkClassID);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    
    typedef std::vector<am_SinkType_s> am_SinkType_L;
    
    typedef uint16_t am_sourceClass_t;
    
    struct am_SourceClass_s: CommonAPI::SerializableStruct {
        am_sourceClass_t sourceClassID;
        std::string name;
        am_ClassProperty_L listClassProperties;
    
        am_SourceClass_s() = default;
        am_SourceClass_s(const am_sourceClass_t& sourceClassID, const std::string& name, const am_ClassProperty_L& listClassProperties);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    typedef std::vector<am_SourceClass_s> am_SourceClass_L;
    
    struct am_SourceType_s: CommonAPI::SerializableStruct {
        am_sourceID_t sourceID;
        std::string name;
        am_Availability_s availability;
        am_sourceClass_t sourceClassID;
    
        am_SourceType_s() = default;
        am_SourceType_s(const am_sourceID_t& sourceID, const std::string& name, const am_Availability_s& availability, const am_sourceClass_t& sourceClassID);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeUInt16Type();
        }
    };
    
    typedef std::vector<am_SourceType_s> am_SourceType_L;
    
    typedef uint16_t am_SystemPropertyType_pe;
    
    struct am_SystemProperty_s: CommonAPI::SerializableStruct {
        am_SystemPropertyType_pe type;
        int16_t value;
    
        am_SystemProperty_s() = default;
        am_SystemProperty_s(const am_SystemPropertyType_pe& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_SystemProperty_s> am_SystemProperty_L;
    
    typedef uint16_t am_connectionID_t;
    
    typedef std::vector<am_connectionID_t> am_ConnectionID_L;
    
    typedef int16_t am_volume_t;
    
    typedef uint16_t am_SoundPropertyType_pe;
    
    enum class am_EarlyDataType_e: int32_t {
        ES_UNKNOWN = 0,
        ED_SOURCE_VOLUME = 1,
        ED_SINK_VOLUME = 2,
        ED_SOURCE_PROPERTY = 3,
        ED_SINK_PROPERTY = 4,
        ED_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_EarlyDataType_eComparator;
    
    struct am_SoundProperty_s: CommonAPI::SerializableStruct {
        am_SoundPropertyType_pe type;
        int16_t value;
    
        am_SoundProperty_s() = default;
        am_SoundProperty_s(const am_SoundPropertyType_pe& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef CommonAPI::Variant<am_volume_t, am_SoundProperty_s>  am_EarlyData_u;
    
    typedef CommonAPI::Variant<am_sinkID_t, am_sourceID_t>  am_DataType_u;
    
    struct am_EarlyData_s: CommonAPI::SerializableStruct {
        am_EarlyDataType_e type;
        am_DataType_u sinksource;
        am_EarlyData_u data;
    
        am_EarlyData_s() = default;
        am_EarlyData_s(const am_EarlyDataType_e& type, const am_DataType_u& sinksource, const am_EarlyData_u& data);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeVariantType();
            typeOutputStream.writeVariantType();
        }
    };
    
    typedef std::vector<am_EarlyData_s> am_EarlyData_L;
    
    typedef uint16_t am_MainSoundPropertyType_pe;
    
    struct am_MainSoundProperty_s: CommonAPI::SerializableStruct {
        am_MainSoundPropertyType_pe type;
        int16_t value;
    
        am_MainSoundProperty_s() = default;
        am_MainSoundProperty_s(const am_MainSoundPropertyType_pe& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_MainSoundProperty_s> am_MainSoundProperty_L;
    
    typedef uint16_t am_NotificationType_pe;
    
    enum class am_NotificationStatus_e: int32_t {
        NS_UNKNOWN = 0,
        NS_OFF = 1,
        NS_PERIODIC = 2,
        NS_MINIMUM = 3,
        NS_MAXIMUM = 4,
        NS_CHANGE_ = 5,
        NS_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_NotificationStatus_eComparator;
    
    struct am_NotificationConfiguration_s: CommonAPI::SerializableStruct {
        am_NotificationType_pe type;
        am_NotificationStatus_e status;
        int16_t parameter;
    
        am_NotificationConfiguration_s() = default;
        am_NotificationConfiguration_s(const am_NotificationType_pe& type, const am_NotificationStatus_e& status, const int16_t& parameter);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_NotificationConfiguration_s> am_NotificationConfiguration_L;
    
    typedef uint16_t am_domainID_t;
    
    typedef uint16_t am_ConnectionFormat_pe;
    
    struct am_RoutingElement_s: CommonAPI::SerializableStruct {
        am_sourceID_t sourceID;
        am_sinkID_t sinkID;
        am_domainID_t domainID;
        am_ConnectionFormat_pe connectionFormat;
    
        am_RoutingElement_s() = default;
        am_RoutingElement_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_domainID_t& domainID, const am_ConnectionFormat_pe& connectionFormat);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    
    typedef std::vector<am_RoutingElement_s> am_RoutingElement_L;
    
    typedef std::vector<am_SoundProperty_s> am_SoundProperty_L;
    
    typedef int16_t am_time_t;
    
    typedef uint16_t am_RampType_pe;
    
    enum class am_VolumeType_e: int32_t {
        VT_UNKNOWN = 0,
        VT_SINK = 1,
        VT_SOURCE = 2,
        VT_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_VolumeType_eComparator;
    
    struct am_Volumes_s: CommonAPI::SerializableStruct {
        am_VolumeType_e volumeType;
        am_DataType_u volumeID;
        am_volume_t volume;
        am_RampType_pe ramp;
        am_time_t time;
    
        am_Volumes_s() = default;
        am_Volumes_s(const am_VolumeType_e& volumeType, const am_DataType_u& volumeID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeVariantType();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_Volumes_s> am_Volumes_L;
    
    typedef std::vector<am_ConnectionFormat_pe> am_ConnectionFormat_L;
    
    typedef bool am_bool_t;
    
    typedef std::vector<am_bool_t> am_Convertion_L;
    
    typedef uint16_t am_gatewayID_t;
    
    typedef uint16_t am_crossfaderID_t;
    
    typedef uint16_t am_speed_t;
    
    enum class am_HotSink_e: int32_t {
        HS_UNKNOWN = 0,
        HS_SINKA = 1,
        HS_SINKB = 2,
        HS_INTERMEDIATE = 3,
        HS_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_HotSink_eComparator;
    
    enum class am_DomainState_e: int32_t {
        DS_UNKNOWN = 0,
        DS_CONTROLLED = 1,
        DS_INDEPENDENT_STARTUP = 1,
        DS_INDEPENDENT_RUNDOWN = 2,
        DS_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_DomainState_eComparator;
    
    enum class am_Error_e: int32_t {
        E_OK = 0,
        E_UNKNOWN = 1,
        E_OUT_OF_RANGE = 2,
        E_NOT_USED = 3,
        E_DATABASE_ERROR = 4,
        E_ALREADY_EXISTS = 5,
        E_NO_CHANGE = 6,
        E_NOT_POSSIBLE = 7,
        E_NON_EXISTENT = 8,
        E_ABORTED = 9,
        E_WRONG_FORMAT = 10,
        E_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Error_eComparator;
    
    enum class am_InterruptState_e: int32_t {
        IS_UNKNOWN = 0,
        IS_OFF = 1,
        IS_INTERRUPTED = 2,
        IS_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_InterruptState_eComparator;
    
    enum class am_Handle_e: int32_t {
        H_UNKNOWN = 0,
        H_CONNECT = 1,
        H_DISCONNECT = 2,
        H_SETSOURCESTATE = 3,
        H_SETSINKVOLUME = 4,
        H_SETSOURCEVOLUME = 5,
        H_SETSINKSOUNDPROPERTY = 6,
        H_SETSOURCESOUNDPROPERTY = 7,
        H_SETSINKSOUNDPROPERTIES = 8,
        H_SETSOURCESOUNDPROPERTIES = 9,
        H_CROSSFADE = 10,
        H_SETVOLUMES = 11,
        H_SETSINKNOTIFICATION = 12,
        H_SETSOURCENOTIFICATION = 13,
        H_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Handle_eComparator;
    
    enum class am_SourceState_e: int32_t {
        SS_UNKNNOWN = 0,
        SS_ON = 1,
        SS_OFF = 2,
        SS_PAUSED = 3,
        SS_MAX
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_SourceState_eComparator;
    
    enum class am_RoutingReady_e: int32_t {
        RR_UNKNOWN = 0,
        RR_READY = 1,
        RR_RUNDOWN = 2
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_RoutingReady_eComparator;
    
    struct am_Route_s: CommonAPI::SerializableStruct {
        am_sourceID_t sourceID;
        am_sinkID_t sinkID;
        am_RoutingElement_L route;
    
        am_Route_s() = default;
        am_Route_s(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_RoutingElement_L& route);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    struct am_Crossfader_s: CommonAPI::SerializableStruct {
        am_crossfaderID_t crossfaderID;
        std::string name;
        am_sinkID_t sinkID_A;
        am_sinkID_t sinkID_B;
        am_sourceID_t sourceID;
        am_HotSink_e hotSink;
    
        am_Crossfader_s() = default;
        am_Crossfader_s(const am_crossfaderID_t& crossfaderID, const std::string& name, const am_sinkID_t& sinkID_A, const am_sinkID_t& sinkID_B, const am_sourceID_t& sourceID, const am_HotSink_e& hotSink);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
        }
    };
    
    struct am_Gateway_s: CommonAPI::SerializableStruct {
        am_gatewayID_t gatewayID;
        std::string name;
        am_sinkID_t sinkID;
        am_sourceID_t sourceID;
        am_domainID_t domainSinkID;
        am_domainID_t domainSourceID;
        am_domainID_t controlDomainID;
        am_ConnectionFormat_L listSourceFormats;
        am_ConnectionFormat_L listSinkFormats;
        am_Convertion_L convertionMatrix;
    
        am_Gateway_s() = default;
        am_Gateway_s(const am_gatewayID_t& gatewayID, const std::string& name, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_domainID_t& domainSinkID, const am_domainID_t& domainSourceID, const am_domainID_t& controlDomainID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeBoolType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    struct am_Handle_s: CommonAPI::SerializableStruct {
        am_Handle_e handleType;
        uint16_t handle;
    
        am_Handle_s() = default;
        am_Handle_s(const am_Handle_e& handleType, const uint16_t& handle);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    
    struct am_MainConnection_s: CommonAPI::SerializableStruct {
        am_mainConnectionID_t mainConnectionID;
        am_ConnectionState_e connectionState;
        am_sinkID_t sinkID;
        am_sourceID_t sourceID;
        am_timeSync_t delay;
        am_ConnectionID_L listConnectionID;
    
        am_MainConnection_s() = default;
        am_MainConnection_s(const am_mainConnectionID_t& mainConnectionID, const am_ConnectionState_e& connectionState, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_timeSync_t& delay, const am_ConnectionID_L& listConnectionID);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    struct am_NotificationPayload_s: CommonAPI::SerializableStruct {
        am_NotificationType_pe type;
        int16_t value;
    
        am_NotificationPayload_s() = default;
        am_NotificationPayload_s(const am_NotificationType_pe& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    struct am_Sink_s: CommonAPI::SerializableStruct {
        am_sinkID_t sinkID;
        std::string name;
        am_domainID_t domainID;
        am_sinkClass_t sinkClassID;
        am_volume_t volume;
        bool visible;
        am_Availability_s available;
        am_MuteState_e muteState;
        am_mainVolume_t mainVolume;
        am_SoundProperty_L listSoundProperties;
        am_ConnectionFormat_L listConnectionFormats;
        am_MainSoundProperty_L listMainSoundProperties;
        am_NotificationConfiguration_L listMainNotificationConfigurations;
        am_NotificationConfiguration_L listNotificationConfigurations;
    
        am_Sink_s() = default;
        am_Sink_s(const am_sinkID_t& sinkID, const std::string& name, const am_domainID_t& domainID, const am_sinkClass_t& sinkClassID, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_MuteState_e& muteState, const am_mainVolume_t& mainVolume, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeBoolType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    struct am_Source_s: CommonAPI::SerializableStruct {
        am_sourceID_t sourceID;
        am_domainID_t domainID;
        std::string name;
        am_sourceClass_t sourceClassID;
        am_SourceState_e sourceState;
        am_volume_t volume;
        bool visible;
        am_Availability_s available;
        am_InterruptState_e interruptState;
        am_SoundProperty_L listSoundProperties;
        am_ConnectionFormat_L listConnectionFormats;
        am_MainSoundProperty_L listMainSoundProperties;
        am_NotificationConfiguration_L listMainNotificationConfigurations;
        am_NotificationConfiguration_L listNotificationConfigurations;
    
        am_Source_s() = default;
        am_Source_s(const am_sourceID_t& sourceID, const am_domainID_t& domainID, const std::string& name, const am_sourceClass_t& sourceClassID, const am_SourceState_e& sourceState, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_InterruptState_e& interruptState, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeBoolType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt16Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    struct am_Domain_s: CommonAPI::SerializableStruct {
        am_domainID_t domainID;
        std::string name;
        std::string busname;
        std::string nodename;
        bool early;
        bool complete;
        am_DomainState_e state;
    
        am_Domain_s() = default;
        am_Domain_s(const am_domainID_t& domainID, const std::string& name, const std::string& busname, const std::string& nodename, const bool& early, const bool& complete, const am_DomainState_e& state);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeBoolType();
            typeOutputStream.writeBoolType();
            typeOutputStream.writeInt32Type();
        }
    };
    
    struct am_Connection_s: CommonAPI::SerializableStruct {
        am_connectionID_t connectionID;
        am_sourceID_t sourceID;
        am_sinkID_t sinkID;
        am_timeSync_t delay;
        am_ConnectionFormat_pe connectionFormat;
    
        am_Connection_s() = default;
        am_Connection_s(const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_ConnectionFormat_pe& connectionFormat);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Availability_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Availability_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_Availability_eComparator {
    inline bool operator()(const am_Availability_e& lhs, const am_Availability_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_HotSink_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_HotSink_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_HotSink_eComparator {
    inline bool operator()(const am_HotSink_e& lhs, const am_HotSink_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_ConnectionState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_ConnectionState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_ConnectionState_eComparator {
    inline bool operator()(const am_ConnectionState_e& lhs, const am_ConnectionState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_DomainState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_DomainState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_DomainState_eComparator {
    inline bool operator()(const am_DomainState_e& lhs, const am_DomainState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_EarlyDataType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_EarlyDataType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_EarlyDataType_eComparator {
    inline bool operator()(const am_EarlyDataType_e& lhs, const am_EarlyDataType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Error_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Error_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_Error_eComparator {
    inline bool operator()(const am_Error_e& lhs, const am_Error_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_MuteState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_MuteState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_MuteState_eComparator {
    inline bool operator()(const am_MuteState_e& lhs, const am_MuteState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_InterruptState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_InterruptState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_InterruptState_eComparator {
    inline bool operator()(const am_InterruptState_e& lhs, const am_InterruptState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_VolumeType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_VolumeType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_VolumeType_eComparator {
    inline bool operator()(const am_VolumeType_e& lhs, const am_VolumeType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_NotificationStatus_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_NotificationStatus_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_NotificationStatus_eComparator {
    inline bool operator()(const am_NotificationStatus_e& lhs, const am_NotificationStatus_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Handle_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Handle_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_Handle_eComparator {
    inline bool operator()(const am_Handle_e& lhs, const am_Handle_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_SourceState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_SourceState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_SourceState_eComparator {
    inline bool operator()(const am_SourceState_e& lhs, const am_SourceState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_RoutingReady_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_RoutingReady_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_RoutingReady_eComparator {
    inline bool operator()(const am_RoutingReady_e& lhs, const am_RoutingReady_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

bool operator==(const am_Route_s& lhs, const am_Route_s& rhs);
inline bool operator!=(const am_Route_s& lhs, const am_Route_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs);
inline bool operator!=(const am_Availability_s& lhs, const am_Availability_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs);
inline bool operator!=(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs);
inline bool operator!=(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs);
inline bool operator!=(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs);
inline bool operator!=(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs);
inline bool operator!=(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs);
inline bool operator!=(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs);
inline bool operator!=(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs);
inline bool operator!=(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs);
inline bool operator!=(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs);
inline bool operator!=(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs);
inline bool operator!=(const am_Handle_s& lhs, const am_Handle_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs);
inline bool operator!=(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs);
inline bool operator!=(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs);
inline bool operator!=(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs);
inline bool operator!=(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs);
inline bool operator!=(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs);
inline bool operator!=(const am_Sink_s& lhs, const am_Sink_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Source_s& lhs, const am_Source_s& rhs);
inline bool operator!=(const am_Source_s& lhs, const am_Source_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs);
inline bool operator!=(const am_Domain_s& lhs, const am_Domain_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs);
inline bool operator!=(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs);
inline bool operator!=(const am_Connection_s& lhs, const am_Connection_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs);
inline bool operator!=(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
    return !(lhs == rhs);
}


static inline const char* getTypeCollectionName() {
    return "org.genivi.am";
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

} // namespace am

} // namespace genivi
} // namespace org

namespace CommonAPI {
	
	template<>
	struct BasicTypeWriter<org::genivi::am::am_Availability_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_Availability_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_Availability_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Availability_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_HotSink_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_HotSink_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_HotSink_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_ConnectionState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_ConnectionState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_ConnectionState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_DomainState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_DomainState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_DomainState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_EarlyDataType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_EarlyDataType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_EarlyDataType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_Error_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_Error_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_Error_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Error_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_MuteState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_MuteState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_MuteState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_InterruptState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_InterruptState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_InterruptState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_VolumeType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_VolumeType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_VolumeType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_NotificationStatus_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_NotificationStatus_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_NotificationStatus_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_Handle_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_Handle_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_Handle_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_Handle_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_SourceState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_SourceState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_SourceState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::am::am_RoutingReady_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::am::am_RoutingReady_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::am::am_RoutingReady_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	
}


namespace std {
    //Hash for am_Availability_e
    template<>
    struct hash<org::genivi::am::am_Availability_e> {
        inline size_t operator()(const org::genivi::am::am_Availability_e& am_Availability_e) const {
            return static_cast<int32_t>(am_Availability_e);
        }
    };
    //Hash for am_HotSink_e
    template<>
    struct hash<org::genivi::am::am_HotSink_e> {
        inline size_t operator()(const org::genivi::am::am_HotSink_e& am_HotSink_e) const {
            return static_cast<int32_t>(am_HotSink_e);
        }
    };
    //Hash for am_ConnectionState_e
    template<>
    struct hash<org::genivi::am::am_ConnectionState_e> {
        inline size_t operator()(const org::genivi::am::am_ConnectionState_e& am_ConnectionState_e) const {
            return static_cast<int32_t>(am_ConnectionState_e);
        }
    };
    //Hash for am_DomainState_e
    template<>
    struct hash<org::genivi::am::am_DomainState_e> {
        inline size_t operator()(const org::genivi::am::am_DomainState_e& am_DomainState_e) const {
            return static_cast<int32_t>(am_DomainState_e);
        }
    };
    //Hash for am_EarlyDataType_e
    template<>
    struct hash<org::genivi::am::am_EarlyDataType_e> {
        inline size_t operator()(const org::genivi::am::am_EarlyDataType_e& am_EarlyDataType_e) const {
            return static_cast<int32_t>(am_EarlyDataType_e);
        }
    };
    //Hash for am_Error_e
    template<>
    struct hash<org::genivi::am::am_Error_e> {
        inline size_t operator()(const org::genivi::am::am_Error_e& am_Error_e) const {
            return static_cast<int32_t>(am_Error_e);
        }
    };
    //Hash for am_MuteState_e
    template<>
    struct hash<org::genivi::am::am_MuteState_e> {
        inline size_t operator()(const org::genivi::am::am_MuteState_e& am_MuteState_e) const {
            return static_cast<int32_t>(am_MuteState_e);
        }
    };
    //Hash for am_InterruptState_e
    template<>
    struct hash<org::genivi::am::am_InterruptState_e> {
        inline size_t operator()(const org::genivi::am::am_InterruptState_e& am_InterruptState_e) const {
            return static_cast<int32_t>(am_InterruptState_e);
        }
    };
    //Hash for am_VolumeType_e
    template<>
    struct hash<org::genivi::am::am_VolumeType_e> {
        inline size_t operator()(const org::genivi::am::am_VolumeType_e& am_VolumeType_e) const {
            return static_cast<int32_t>(am_VolumeType_e);
        }
    };
    //Hash for am_NotificationStatus_e
    template<>
    struct hash<org::genivi::am::am_NotificationStatus_e> {
        inline size_t operator()(const org::genivi::am::am_NotificationStatus_e& am_NotificationStatus_e) const {
            return static_cast<int32_t>(am_NotificationStatus_e);
        }
    };
    //Hash for am_Handle_e
    template<>
    struct hash<org::genivi::am::am_Handle_e> {
        inline size_t operator()(const org::genivi::am::am_Handle_e& am_Handle_e) const {
            return static_cast<int32_t>(am_Handle_e);
        }
    };
    //Hash for am_SourceState_e
    template<>
    struct hash<org::genivi::am::am_SourceState_e> {
        inline size_t operator()(const org::genivi::am::am_SourceState_e& am_SourceState_e) const {
            return static_cast<int32_t>(am_SourceState_e);
        }
    };
    //Hash for am_RoutingReady_e
    template<>
    struct hash<org::genivi::am::am_RoutingReady_e> {
        inline size_t operator()(const org::genivi::am::am_RoutingReady_e& am_RoutingReady_e) const {
            return static_cast<int32_t>(am_RoutingReady_e);
        }
    };
}

#endif // ORG_GENIVI_am_H_

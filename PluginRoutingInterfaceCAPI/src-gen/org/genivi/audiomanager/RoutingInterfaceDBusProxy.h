/*
* This file was generated by the CommonAPI Generators.
*
 *  Copyright (c) 2012 BMW
 *
 *  \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
 *
 *  \copyright
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
 *  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  For further information see http://www.genivi.org/.
*/
#ifndef ORG_GENIVI_AUDIOMANAGER_Routing_Interface_DBUS_PROXY_H_
#define ORG_GENIVI_AUDIOMANAGER_Routing_Interface_DBUS_PROXY_H_

#include <org/genivi/audiomanager/RoutingInterfaceProxyBase.h>

#define COMMONAPI_INTERNAL_COMPILATION

#include <CommonAPI/DBus/DBusFactory.h>
#include <CommonAPI/DBus/DBusProxy.h>
#include <CommonAPI/DBus/DBusEvent.h>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace org {
namespace genivi {
namespace audiomanager {

class RoutingInterfaceDBusProxy: virtual public RoutingInterfaceProxyBase, virtual public CommonAPI::DBus::DBusProxy {
 public:
    RoutingInterfaceDBusProxy(
                    const std::string& commonApiAddress,
                    const std::string& interfaceName,
                    const std::string& busName,
                    const std::string& objectPath,
                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);

    virtual ~RoutingInterfaceDBusProxy() { }


    virtual SetRoutingReadyEvent& getSetRoutingReadyEvent();
    virtual SetRoutingRundownEvent& getSetRoutingRundownEvent();


    virtual void ackConnect(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, AckConnectAsyncCallback callback);

    virtual void ackDisconnect(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, AckDisconnectAsyncCallback callback);

    virtual void ackSetSinkVolume(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeAsync(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, AckSetSinkVolumeAsyncCallback callback);

    virtual void ackSetSourceVolume(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeAsync(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, AckSetSourceVolumeAsyncCallback callback);

    virtual void ackSetSourceState(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceStateAsyncCallback callback);

    virtual void ackSetSinkSoundProperties(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const uint16_t& handle, const uint16_t& error, AckSetSinkSoundPropertiesAsyncCallback callback);

    virtual void ackSetSinkSoundProperty(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const uint16_t& handle, const uint16_t& error, AckSetSinkSoundPropertyAsyncCallback callback);

    virtual void ackSetSourceSoundProperties(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceSoundPropertiesAsyncCallback callback);

    virtual void ackSetSourceSoundProperty(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceSoundPropertyAsyncCallback callback);

    virtual void ackSourceVolumeTick(const uint16_t& handle, const am_gen::am_sourceID_t& source, const am_gen::am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const uint16_t& handle, const am_gen::am_sourceID_t& source, const am_gen::am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback);

    virtual void ackSinkVolumeTick(const uint16_t& handle, const am_gen::am_sinkID_t& sink, const am_gen::am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const uint16_t& handle, const am_gen::am_sinkID_t& sink, const am_gen::am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback);

    virtual void ackCrossFading(const uint16_t& handle, const am_gen::am_HotSink_e& hotSink, const am_gen::am_Error_e& returnError, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const uint16_t& handle, const am_gen::am_HotSink_e& hotSink, const am_gen::am_Error_e& returnError, AckCrossFadingAsyncCallback callback);

    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_domainID_t& domainID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback);

    virtual void registerDomain(const am_gen::am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnPath, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_gen::am_domainID_t& domainID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_gen::am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnPath, const std::string& returnInterface, RegisterDomainAsyncCallback callback);

    virtual void deregisterDomain(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_gen::am_domainID_t& domainID, DeregisterDomainAsyncCallback callback);

    virtual void registerGateway(const am_gen::am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gen::am_gatewayID_t& gatewayID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_gen::am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback);

    virtual void deregisterGateway(const am_gen::am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gen::am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback);

    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sinkID_t& sinkID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback);

    virtual void registerSink(const am_gen::sinkData_s& sinkData, CommonAPI::CallStatus& callStatus, am_gen::am_sinkID_t& sinkID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_gen::sinkData_s& sinkData, RegisterSinkAsyncCallback callback);

    virtual void deregisterSink(const am_gen::am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_gen::am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback);

    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sourceID_t& sourceID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback);

    virtual void registerSource(const am_gen::sourceData_s& sourceData, CommonAPI::CallStatus& callStatus, am_gen::am_sourceID_t& sourceID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_gen::sourceData_s& sourceData, RegisterSourceAsyncCallback callback);

    virtual void deregisterSource(const am_gen::am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_gen::am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback);

    virtual void registerCrossfader(const am_gen::crossfaderData_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_gen::am_crossfaderID_t& crossfaderID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_gen::crossfaderData_s& crossfaderData, RegisterCrossfaderAsyncCallback callback);

    virtual void deregisterCrossfader(const am_gen::am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_gen::am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback);

    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sourceClass_t& sourceClassID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback);

    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sinkClass_t& sinkClassID, am_gen::am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback);

    virtual void hookInterruptStatusChange(const am_gen::am_sourceID_t& sourceID, const uint16_t& interruptState, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_gen::am_sourceID_t& sourceID, const uint16_t& interruptState, HookInterruptStatusChangeAsyncCallback callback);

    virtual void hookDomainRegistrationComplete(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_gen::am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback);

    virtual void hookSinkAvailablityStatusChange(const am_gen::am_sinkID_t& sinkID, const am_gen::am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback);

    virtual void hookSourceAvailablityStatusChange(const am_gen::am_sourceID_t& sourceID, const am_gen::am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback);

    virtual void hookDomainStateChange(const am_gen::am_domainID_t& domainID, const am_gen::am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_gen::am_domainID_t& domainID, const am_gen::am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback);

    virtual void hookTimingInformationChanged(const am_gen::am_connectionID_t& connectionID, const int16_t& delay, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_gen::am_connectionID_t& connectionID, const int16_t& delay, HookTimingInformationChangedAsyncCallback callback);

    virtual void sendChangedData(const am_gen::am_EarlyData_l& earlyData_volumes, const am_gen::am_EarlyData_l& earlyData_soundproperties, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_gen::am_EarlyData_l& earlyData_volumes, const am_gen::am_EarlyData_l& earlyData_soundproperties, SendChangedDataAsyncCallback callback);

    virtual void confirmRoutingReady(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> confirmRoutingReadyAsync(const am_gen::am_domainID_t& domainID, ConfirmRoutingReadyAsyncCallback callback);

    virtual void confirmRoutingRundown(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const am_gen::am_domainID_t& domainID, ConfirmRoutingRundownAsyncCallback callback);

    virtual void updateGateway(const am_gen::am_gatewayID_t& gatewayID, const am_gen::am_ConnectionFormat_L& listSourceFormats, const am_gen::am_ConnectionFormat_L& listSinkFormats, const am_gen::bool_L& convertionMatrix, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gen::am_gatewayID_t& gatewayID, const am_gen::am_ConnectionFormat_L& listSourceFormats, const am_gen::am_ConnectionFormat_L& listSinkFormats, const am_gen::bool_L& convertionMatrix, UpdateGatewayAsyncCallback callback);

    virtual void updateSink(const am_gen::am_sinkID_t& sinkID, const am_gen::am_sinkClass_t& sinkClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::am_sinkClass_t& sinkClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback);

    virtual void updateSource(const am_gen::am_sourceID_t& sourceID, const am_gen::am_sourceClass_t& sourceClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::am_sourceClass_t& sourceClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback);

    virtual void ackSetVolumes(const uint16_t& handle, const am_gen::am_Volumes_l& listVolumes, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const uint16_t& handle, const am_gen::am_Volumes_l& listVolumes, const uint16_t& error, AckSetVolumesAsyncCallback callback);

    virtual void ackSinkNotificationConfiguration(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const uint16_t& handle, const uint16_t& error, AckSinkNotificationConfigurationAsyncCallback callback);

    virtual void ackSourceNotificationConfiguration(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const uint16_t& handle, const uint16_t& error, AckSourceNotificationConfigurationAsyncCallback callback);

    virtual void hookSinkNotificationDataChange(const am_gen::am_sinkID_t& sinkID, const am_gen::notificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::notificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback);

    virtual void hookSourceNotificationDataChange(const am_gen::am_sourceID_t& sourceID, const am_gen::notificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::notificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback);

    virtual void getRoutingReadyState(CommonAPI::CallStatus& callStatus, bool& readyState);
    virtual std::future<CommonAPI::CallStatus> getRoutingReadyStateAsync(GetRoutingReadyStateAsyncCallback callback);
    
    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

 private:

    CommonAPI::DBus::DBusEvent<SetRoutingReadyEvent> setRoutingReady_;
    CommonAPI::DBus::DBusEvent<SetRoutingRundownEvent> setRoutingRundown_;
};

} // namespace audiomanager
} // namespace genivi
} // namespace org

#endif // ORG_GENIVI_AUDIOMANAGER_Routing_Interface_DBUS_PROXY_H_

/*
* This file was generated by the CommonAPI Generators.
*
 *  Copyright (c) 2012 BMW
 *
 *  \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
 *
 *  \copyright
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
 *  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  For further information see http://www.genivi.org/.
*/
#ifndef ORG_GENIVI_AUDIOMANAGER_Routing_Interface_PROXY_H_
#define ORG_GENIVI_AUDIOMANAGER_Routing_Interface_PROXY_H_

#include "RoutingInterfaceProxyBase.h"

#define COMMONAPI_INTERNAL_COMPILATION


#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace audiomanager {

template <typename ... _AttributeExtensions>
class RoutingInterfaceProxy: virtual public RoutingInterface, virtual public RoutingInterfaceProxyBase, public _AttributeExtensions... {
 public:
    RoutingInterfaceProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~RoutingInterfaceProxy();


    /// Returns the wrapper class that provides access to the broadcast setRoutingReady.
    virtual SetRoutingReadyEvent& getSetRoutingReadyEvent() {
        return delegate_->getSetRoutingReadyEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast setRoutingRundown.
    virtual SetRoutingRundownEvent& getSetRoutingRundownEvent() {
        return delegate_->getSetRoutingRundownEvent();
    }



    /**
     * Calls ackConnect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackConnect(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackConnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, AckConnectAsyncCallback callback);

    /**
     * Calls ackDisconnect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackDisconnect(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackDisconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, AckDisconnectAsyncCallback callback);

    /**
     * Calls ackSetSinkVolume with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSinkVolume(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeAsync(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, AckSetSinkVolumeAsyncCallback callback);

    /**
     * Calls ackSetSourceVolume with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSourceVolume(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeAsync(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, AckSetSourceVolumeAsyncCallback callback);

    /**
     * Calls ackSetSourceState with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSourceState(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceStateAsyncCallback callback);

    /**
     * Calls ackSetSinkSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSinkSoundProperties(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const uint16_t& handle, const uint16_t& error, AckSetSinkSoundPropertiesAsyncCallback callback);

    /**
     * Calls ackSetSinkSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSinkSoundProperty(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const uint16_t& handle, const uint16_t& error, AckSetSinkSoundPropertyAsyncCallback callback);

    /**
     * Calls ackSetSourceSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSourceSoundProperties(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceSoundPropertiesAsyncCallback callback);

    /**
     * Calls ackSetSourceSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSourceSoundProperty(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceSoundPropertyAsyncCallback callback);

    /**
     * Calls ackSourceVolumeTick with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSourceVolumeTick(const uint16_t& handle, const am_gen::am_sourceID_t& source, const am_gen::am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSourceVolumeTick with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const uint16_t& handle, const am_gen::am_sourceID_t& source, const am_gen::am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback);

    /**
     * Calls ackSinkVolumeTick with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSinkVolumeTick(const uint16_t& handle, const am_gen::am_sinkID_t& sink, const am_gen::am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSinkVolumeTick with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const uint16_t& handle, const am_gen::am_sinkID_t& sink, const am_gen::am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback);

    /**
     * Calls ackCrossFading with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackCrossFading(const uint16_t& handle, const am_gen::am_HotSink_e& hotSink, const am_gen::am_Error_e& returnError, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackCrossFading with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const uint16_t& handle, const am_gen::am_HotSink_e& hotSink, const am_gen::am_Error_e& returnError, AckCrossFadingAsyncCallback callback);

    /**
     * Calls peekDomain with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_domainID_t& domainID, am_gen::am_Error_e& error);
    /**
     * Calls peekDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback);

    /**
     * Calls registerDomain with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerDomain(const am_gen::am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnPath, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_gen::am_domainID_t& domainID, am_gen::am_Error_e& error);
    /**
     * Calls registerDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_gen::am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnPath, const std::string& returnInterface, RegisterDomainAsyncCallback callback);

    /**
     * Calls deregisterDomain with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterDomain(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    /**
     * Calls deregisterDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_gen::am_domainID_t& domainID, DeregisterDomainAsyncCallback callback);

    /**
     * Calls registerGateway with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerGateway(const am_gen::am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gen::am_gatewayID_t& gatewayID, am_gen::am_Error_e& error);
    /**
     * Calls registerGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_gen::am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback);

    /**
     * Calls deregisterGateway with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterGateway(const am_gen::am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    /**
     * Calls deregisterGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gen::am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback);

    /**
     * Calls peekSink with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sinkID_t& sinkID, am_gen::am_Error_e& error);
    /**
     * Calls peekSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback);

    /**
     * Calls registerSink with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerSink(const am_gen::sinkData_s& sinkData, CommonAPI::CallStatus& callStatus, am_gen::am_sinkID_t& sinkID, am_gen::am_Error_e& error);
    /**
     * Calls registerSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_gen::sinkData_s& sinkData, RegisterSinkAsyncCallback callback);

    /**
     * Calls deregisterSink with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterSink(const am_gen::am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    /**
     * Calls deregisterSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_gen::am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback);

    /**
     * Calls peekSource with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sourceID_t& sourceID, am_gen::am_Error_e& error);
    /**
     * Calls peekSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback);

    /**
     * Calls registerSource with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerSource(const am_gen::sourceData_s& sourceData, CommonAPI::CallStatus& callStatus, am_gen::am_sourceID_t& sourceID, am_gen::am_Error_e& error);
    /**
     * Calls registerSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_gen::sourceData_s& sourceData, RegisterSourceAsyncCallback callback);

    /**
     * Calls deregisterSource with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterSource(const am_gen::am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    /**
     * Calls deregisterSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_gen::am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback);

    /**
     * Calls registerCrossfader with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerCrossfader(const am_gen::crossfaderData_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_gen::am_crossfaderID_t& crossfaderID, am_gen::am_Error_e& error);
    /**
     * Calls registerCrossfader with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_gen::crossfaderData_s& crossfaderData, RegisterCrossfaderAsyncCallback callback);

    /**
     * Calls deregisterCrossfader with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterCrossfader(const am_gen::am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError);
    /**
     * Calls deregisterCrossfader with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_gen::am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback);

    /**
     * Calls peekSourceClassID with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sourceClass_t& sourceClassID, am_gen::am_Error_e& error);
    /**
     * Calls peekSourceClassID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback);

    /**
     * Calls peekSinkClassID with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sinkClass_t& sinkClassID, am_gen::am_Error_e& error);
    /**
     * Calls peekSinkClassID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback);

    /**
     * Calls hookInterruptStatusChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookInterruptStatusChange(const am_gen::am_sourceID_t& sourceID, const uint16_t& interruptState, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookInterruptStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_gen::am_sourceID_t& sourceID, const uint16_t& interruptState, HookInterruptStatusChangeAsyncCallback callback);

    /**
     * Calls hookDomainRegistrationComplete with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookDomainRegistrationComplete(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookDomainRegistrationComplete with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_gen::am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback);

    /**
     * Calls hookSinkAvailablityStatusChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookSinkAvailablityStatusChange(const am_gen::am_sinkID_t& sinkID, const am_gen::am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSinkAvailablityStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback);

    /**
     * Calls hookSourceAvailablityStatusChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookSourceAvailablityStatusChange(const am_gen::am_sourceID_t& sourceID, const am_gen::am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSourceAvailablityStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback);

    /**
     * Calls hookDomainStateChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookDomainStateChange(const am_gen::am_domainID_t& domainID, const am_gen::am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookDomainStateChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_gen::am_domainID_t& domainID, const am_gen::am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback);

    /**
     * Calls hookTimingInformationChanged with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookTimingInformationChanged(const am_gen::am_connectionID_t& connectionID, const int16_t& delay, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookTimingInformationChanged with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_gen::am_connectionID_t& connectionID, const int16_t& delay, HookTimingInformationChangedAsyncCallback callback);

    /**
     * Calls sendChangedData with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void sendChangedData(const am_gen::am_EarlyData_l& earlyData_volumes, const am_gen::am_EarlyData_l& earlyData_soundproperties, CommonAPI::CallStatus& callStatus);
    /**
     * Calls sendChangedData with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_gen::am_EarlyData_l& earlyData_volumes, const am_gen::am_EarlyData_l& earlyData_soundproperties, SendChangedDataAsyncCallback callback);

    /**
     * Calls confirmRoutingReady with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void confirmRoutingReady(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    /**
     * Calls confirmRoutingReady with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> confirmRoutingReadyAsync(const am_gen::am_domainID_t& domainID, ConfirmRoutingReadyAsyncCallback callback);

    /**
     * Calls confirmRoutingRundown with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void confirmRoutingRundown(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    /**
     * Calls confirmRoutingRundown with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const am_gen::am_domainID_t& domainID, ConfirmRoutingRundownAsyncCallback callback);

    /**
     * Calls updateGateway with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void updateGateway(const am_gen::am_gatewayID_t& gatewayID, const am_gen::am_ConnectionFormat_L& listSourceFormats, const am_gen::am_ConnectionFormat_L& listSinkFormats, const am_gen::bool_L& convertionMatrix, CommonAPI::CallStatus& callStatus);
    /**
     * Calls updateGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gen::am_gatewayID_t& gatewayID, const am_gen::am_ConnectionFormat_L& listSourceFormats, const am_gen::am_ConnectionFormat_L& listSinkFormats, const am_gen::bool_L& convertionMatrix, UpdateGatewayAsyncCallback callback);

    /**
     * Calls updateSink with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void updateSink(const am_gen::am_sinkID_t& sinkID, const am_gen::am_sinkClass_t& sinkClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus);
    /**
     * Calls updateSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::am_sinkClass_t& sinkClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback);

    /**
     * Calls updateSource with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void updateSource(const am_gen::am_sourceID_t& sourceID, const am_gen::am_sourceClass_t& sourceClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus);
    /**
     * Calls updateSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::am_sourceClass_t& sourceClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback);

    /**
     * Calls ackSetVolumes with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetVolumes(const uint16_t& handle, const am_gen::am_Volumes_l& listVolumes, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetVolumes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const uint16_t& handle, const am_gen::am_Volumes_l& listVolumes, const uint16_t& error, AckSetVolumesAsyncCallback callback);

    /**
     * Calls ackSinkNotificationConfiguration with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSinkNotificationConfiguration(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSinkNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const uint16_t& handle, const uint16_t& error, AckSinkNotificationConfigurationAsyncCallback callback);

    /**
     * Calls ackSourceNotificationConfiguration with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSourceNotificationConfiguration(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSourceNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const uint16_t& handle, const uint16_t& error, AckSourceNotificationConfigurationAsyncCallback callback);

    /**
     * Calls hookSinkNotificationDataChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookSinkNotificationDataChange(const am_gen::am_sinkID_t& sinkID, const am_gen::notificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSinkNotificationDataChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::notificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback);

    /**
     * Calls hookSourceNotificationDataChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookSourceNotificationDataChange(const am_gen::am_sourceID_t& sourceID, const am_gen::notificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSourceNotificationDataChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::notificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback);

    /**
     * Calls getRoutingReadyState with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getRoutingReadyState(CommonAPI::CallStatus& callStatus, bool& readyState);
    /**
     * Calls getRoutingReadyState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRoutingReadyStateAsync(GetRoutingReadyStateAsyncCallback callback);

    /// Returns the CommonAPI address of the remote partner this proxy communicates with.
    virtual std::string getAddress() const;

    /// Returns the domain of the remote partner this proxy communicates with.
    virtual const std::string& getDomain() const;

    /// Returns the service ID of the remote partner this proxy communicates with.
    virtual const std::string& getServiceId() const;

    /// Returns the instance ID of the remote partner this proxy communicates with.
    virtual const std::string& getInstanceId() const;

    /// Returns true if the remote partner for this proxy is available.
    virtual bool isAvailable() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<RoutingInterfaceProxyBase> delegate_;
};


//
// RoutingInterfaceProxy Implementation
//
template <typename ... _AttributeExtensions>
RoutingInterfaceProxy<_AttributeExtensions...>::RoutingInterfaceProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        delegate_(std::dynamic_pointer_cast<RoutingInterfaceProxyBase>(delegate)),
        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingInterfaceProxyBase>(delegate)))... {
}

template <typename ... _AttributeExtensions>
RoutingInterfaceProxy<_AttributeExtensions...>::~RoutingInterfaceProxy() {
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackConnect(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackConnect(handle, connectionID, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackConnectAsync(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, AckConnectAsyncCallback callback) {
    return delegate_->ackConnectAsync(handle, connectionID, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackDisconnect(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackDisconnect(handle, connectionID, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackDisconnectAsync(const uint16_t& handle, const am_gen::am_connectionID_t& connectionID, const uint16_t& error, AckDisconnectAsyncCallback callback) {
    return delegate_->ackDisconnectAsync(handle, connectionID, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSinkVolume(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkVolume(handle, volume, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSinkVolumeAsync(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, AckSetSinkVolumeAsyncCallback callback) {
    return delegate_->ackSetSinkVolumeAsync(handle, volume, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSourceVolume(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceVolume(handle, volume, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSourceVolumeAsync(const uint16_t& handle, const am_gen::am_volume_t& volume, const uint16_t& error, AckSetSourceVolumeAsyncCallback callback) {
    return delegate_->ackSetSourceVolumeAsync(handle, volume, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSourceState(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceState(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSourceStateAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceStateAsyncCallback callback) {
    return delegate_->ackSetSourceStateAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSinkSoundProperties(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkSoundProperties(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSinkSoundPropertiesAsync(const uint16_t& handle, const uint16_t& error, AckSetSinkSoundPropertiesAsyncCallback callback) {
    return delegate_->ackSetSinkSoundPropertiesAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSinkSoundProperty(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkSoundProperty(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSinkSoundPropertyAsync(const uint16_t& handle, const uint16_t& error, AckSetSinkSoundPropertyAsyncCallback callback) {
    return delegate_->ackSetSinkSoundPropertyAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSourceSoundProperties(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceSoundProperties(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSourceSoundPropertiesAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceSoundPropertiesAsyncCallback callback) {
    return delegate_->ackSetSourceSoundPropertiesAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSourceSoundProperty(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceSoundProperty(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSetSourceSoundPropertyAsync(const uint16_t& handle, const uint16_t& error, AckSetSourceSoundPropertyAsyncCallback callback) {
    return delegate_->ackSetSourceSoundPropertyAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSourceVolumeTick(const uint16_t& handle, const am_gen::am_sourceID_t& source, const am_gen::am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSourceVolumeTick(handle, source, volume, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSourceVolumeTickAsync(const uint16_t& handle, const am_gen::am_sourceID_t& source, const am_gen::am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback) {
    return delegate_->ackSourceVolumeTickAsync(handle, source, volume, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSinkVolumeTick(const uint16_t& handle, const am_gen::am_sinkID_t& sink, const am_gen::am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSinkVolumeTick(handle, sink, volume, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSinkVolumeTickAsync(const uint16_t& handle, const am_gen::am_sinkID_t& sink, const am_gen::am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback) {
    return delegate_->ackSinkVolumeTickAsync(handle, sink, volume, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackCrossFading(const uint16_t& handle, const am_gen::am_HotSink_e& hotSink, const am_gen::am_Error_e& returnError, CommonAPI::CallStatus& callStatus) {
    delegate_->ackCrossFading(handle, hotSink, returnError, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackCrossFadingAsync(const uint16_t& handle, const am_gen::am_HotSink_e& hotSink, const am_gen::am_Error_e& returnError, AckCrossFadingAsyncCallback callback) {
    return delegate_->ackCrossFadingAsync(handle, hotSink, returnError, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_domainID_t& domainID, am_gen::am_Error_e& error) {
    delegate_->peekDomain(name, callStatus, domainID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) {
    return delegate_->peekDomainAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::registerDomain(const am_gen::am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnPath, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_gen::am_domainID_t& domainID, am_gen::am_Error_e& error) {
    delegate_->registerDomain(domainData, returnBusname, returnPath, returnInterface, callStatus, domainID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::registerDomainAsync(const am_gen::am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnPath, const std::string& returnInterface, RegisterDomainAsyncCallback callback) {
    return delegate_->registerDomainAsync(domainData, returnBusname, returnPath, returnInterface, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::deregisterDomain(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError) {
    delegate_->deregisterDomain(domainID, callStatus, returnError);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::deregisterDomainAsync(const am_gen::am_domainID_t& domainID, DeregisterDomainAsyncCallback callback) {
    return delegate_->deregisterDomainAsync(domainID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::registerGateway(const am_gen::am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gen::am_gatewayID_t& gatewayID, am_gen::am_Error_e& error) {
    delegate_->registerGateway(gatewayData, callStatus, gatewayID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::registerGatewayAsync(const am_gen::am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback) {
    return delegate_->registerGatewayAsync(gatewayData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::deregisterGateway(const am_gen::am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError) {
    delegate_->deregisterGateway(gatewayID, callStatus, returnError);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::deregisterGatewayAsync(const am_gen::am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback) {
    return delegate_->deregisterGatewayAsync(gatewayID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sinkID_t& sinkID, am_gen::am_Error_e& error) {
    delegate_->peekSink(name, callStatus, sinkID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback) {
    return delegate_->peekSinkAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::registerSink(const am_gen::sinkData_s& sinkData, CommonAPI::CallStatus& callStatus, am_gen::am_sinkID_t& sinkID, am_gen::am_Error_e& error) {
    delegate_->registerSink(sinkData, callStatus, sinkID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::registerSinkAsync(const am_gen::sinkData_s& sinkData, RegisterSinkAsyncCallback callback) {
    return delegate_->registerSinkAsync(sinkData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::deregisterSink(const am_gen::am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError) {
    delegate_->deregisterSink(sinkID, callStatus, returnError);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::deregisterSinkAsync(const am_gen::am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback) {
    return delegate_->deregisterSinkAsync(sinkID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sourceID_t& sourceID, am_gen::am_Error_e& error) {
    delegate_->peekSource(name, callStatus, sourceID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) {
    return delegate_->peekSourceAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::registerSource(const am_gen::sourceData_s& sourceData, CommonAPI::CallStatus& callStatus, am_gen::am_sourceID_t& sourceID, am_gen::am_Error_e& error) {
    delegate_->registerSource(sourceData, callStatus, sourceID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::registerSourceAsync(const am_gen::sourceData_s& sourceData, RegisterSourceAsyncCallback callback) {
    return delegate_->registerSourceAsync(sourceData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::deregisterSource(const am_gen::am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError) {
    delegate_->deregisterSource(sourceID, callStatus, returnError);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::deregisterSourceAsync(const am_gen::am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback) {
    return delegate_->deregisterSourceAsync(sourceID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::registerCrossfader(const am_gen::crossfaderData_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_gen::am_crossfaderID_t& crossfaderID, am_gen::am_Error_e& error) {
    delegate_->registerCrossfader(crossfaderData, callStatus, crossfaderID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::registerCrossfaderAsync(const am_gen::crossfaderData_s& crossfaderData, RegisterCrossfaderAsyncCallback callback) {
    return delegate_->registerCrossfaderAsync(crossfaderData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::deregisterCrossfader(const am_gen::am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_gen::am_Error_e& returnError) {
    delegate_->deregisterCrossfader(crossfaderID, callStatus, returnError);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::deregisterCrossfaderAsync(const am_gen::am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback) {
    return delegate_->deregisterCrossfaderAsync(crossfaderID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sourceClass_t& sourceClassID, am_gen::am_Error_e& error) {
    delegate_->peekSourceClassID(name, callStatus, sourceClassID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback) {
    return delegate_->peekSourceClassIDAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_gen::am_sinkClass_t& sinkClassID, am_gen::am_Error_e& error) {
    delegate_->peekSinkClassID(name, callStatus, sinkClassID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback) {
    return delegate_->peekSinkClassIDAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::hookInterruptStatusChange(const am_gen::am_sourceID_t& sourceID, const uint16_t& interruptState, CommonAPI::CallStatus& callStatus) {
    delegate_->hookInterruptStatusChange(sourceID, interruptState, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::hookInterruptStatusChangeAsync(const am_gen::am_sourceID_t& sourceID, const uint16_t& interruptState, HookInterruptStatusChangeAsyncCallback callback) {
    return delegate_->hookInterruptStatusChangeAsync(sourceID, interruptState, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::hookDomainRegistrationComplete(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) {
    delegate_->hookDomainRegistrationComplete(domainID, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::hookDomainRegistrationCompleteAsync(const am_gen::am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback) {
    return delegate_->hookDomainRegistrationCompleteAsync(domainID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChange(const am_gen::am_sinkID_t& sinkID, const am_gen::am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSinkAvailablityStatusChange(sinkID, availability, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChangeAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback) {
    return delegate_->hookSinkAvailablityStatusChangeAsync(sinkID, availability, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChange(const am_gen::am_sourceID_t& sourceID, const am_gen::am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSourceAvailablityStatusChange(sourceID, availability, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChangeAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback) {
    return delegate_->hookSourceAvailablityStatusChangeAsync(sourceID, availability, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::hookDomainStateChange(const am_gen::am_domainID_t& domainID, const am_gen::am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus) {
    delegate_->hookDomainStateChange(domainID, domainState, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::hookDomainStateChangeAsync(const am_gen::am_domainID_t& domainID, const am_gen::am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback) {
    return delegate_->hookDomainStateChangeAsync(domainID, domainState, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::hookTimingInformationChanged(const am_gen::am_connectionID_t& connectionID, const int16_t& delay, CommonAPI::CallStatus& callStatus) {
    delegate_->hookTimingInformationChanged(connectionID, delay, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::hookTimingInformationChangedAsync(const am_gen::am_connectionID_t& connectionID, const int16_t& delay, HookTimingInformationChangedAsyncCallback callback) {
    return delegate_->hookTimingInformationChangedAsync(connectionID, delay, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::sendChangedData(const am_gen::am_EarlyData_l& earlyData_volumes, const am_gen::am_EarlyData_l& earlyData_soundproperties, CommonAPI::CallStatus& callStatus) {
    delegate_->sendChangedData(earlyData_volumes, earlyData_soundproperties, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::sendChangedDataAsync(const am_gen::am_EarlyData_l& earlyData_volumes, const am_gen::am_EarlyData_l& earlyData_soundproperties, SendChangedDataAsyncCallback callback) {
    return delegate_->sendChangedDataAsync(earlyData_volumes, earlyData_soundproperties, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::confirmRoutingReady(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) {
    delegate_->confirmRoutingReady(domainID, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::confirmRoutingReadyAsync(const am_gen::am_domainID_t& domainID, ConfirmRoutingReadyAsyncCallback callback) {
    return delegate_->confirmRoutingReadyAsync(domainID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::confirmRoutingRundown(const am_gen::am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) {
    delegate_->confirmRoutingRundown(domainID, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::confirmRoutingRundownAsync(const am_gen::am_domainID_t& domainID, ConfirmRoutingRundownAsyncCallback callback) {
    return delegate_->confirmRoutingRundownAsync(domainID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::updateGateway(const am_gen::am_gatewayID_t& gatewayID, const am_gen::am_ConnectionFormat_L& listSourceFormats, const am_gen::am_ConnectionFormat_L& listSinkFormats, const am_gen::bool_L& convertionMatrix, CommonAPI::CallStatus& callStatus) {
    delegate_->updateGateway(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::updateGatewayAsync(const am_gen::am_gatewayID_t& gatewayID, const am_gen::am_ConnectionFormat_L& listSourceFormats, const am_gen::am_ConnectionFormat_L& listSinkFormats, const am_gen::bool_L& convertionMatrix, UpdateGatewayAsyncCallback callback) {
    return delegate_->updateGatewayAsync(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::updateSink(const am_gen::am_sinkID_t& sinkID, const am_gen::am_sinkClass_t& sinkClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus) {
    delegate_->updateSink(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::updateSinkAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::am_sinkClass_t& sinkClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback) {
    return delegate_->updateSinkAsync(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::updateSource(const am_gen::am_sourceID_t& sourceID, const am_gen::am_sourceClass_t& sourceClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus) {
    delegate_->updateSource(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::updateSourceAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::am_sourceClass_t& sourceClassID, const am_gen::am_SoundProperty_L& listSoundProperties, const am_gen::am_ConnectionFormat_L& listConnectionFormats, const am_gen::am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback) {
    return delegate_->updateSourceAsync(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSetVolumes(const uint16_t& handle, const am_gen::am_Volumes_l& listVolumes, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetVolumes(handle, listVolumes, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSetVolumesAsync(const uint16_t& handle, const am_gen::am_Volumes_l& listVolumes, const uint16_t& error, AckSetVolumesAsyncCallback callback) {
    return delegate_->ackSetVolumesAsync(handle, listVolumes, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSinkNotificationConfiguration(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSinkNotificationConfiguration(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSinkNotificationConfigurationAsync(const uint16_t& handle, const uint16_t& error, AckSinkNotificationConfigurationAsyncCallback callback) {
    return delegate_->ackSinkNotificationConfigurationAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::ackSourceNotificationConfiguration(const uint16_t& handle, const uint16_t& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSourceNotificationConfiguration(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::ackSourceNotificationConfigurationAsync(const uint16_t& handle, const uint16_t& error, AckSourceNotificationConfigurationAsyncCallback callback) {
    return delegate_->ackSourceNotificationConfigurationAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::hookSinkNotificationDataChange(const am_gen::am_sinkID_t& sinkID, const am_gen::notificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSinkNotificationDataChange(sinkID, payload, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::hookSinkNotificationDataChangeAsync(const am_gen::am_sinkID_t& sinkID, const am_gen::notificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback) {
    return delegate_->hookSinkNotificationDataChangeAsync(sinkID, payload, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::hookSourceNotificationDataChange(const am_gen::am_sourceID_t& sourceID, const am_gen::notificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSourceNotificationDataChange(sourceID, payload, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::hookSourceNotificationDataChangeAsync(const am_gen::am_sourceID_t& sourceID, const am_gen::notificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback) {
    return delegate_->hookSourceNotificationDataChangeAsync(sourceID, payload, callback);
}

template <typename ... _AttributeExtensions>
void RoutingInterfaceProxy<_AttributeExtensions...>::getRoutingReadyState(CommonAPI::CallStatus& callStatus, bool& readyState) {
    delegate_->getRoutingReadyState(callStatus, readyState);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingInterfaceProxy<_AttributeExtensions...>::getRoutingReadyStateAsync(GetRoutingReadyStateAsyncCallback callback) {
    return delegate_->getRoutingReadyStateAsync(callback);
}


template <typename ... _AttributeExtensions>
std::string RoutingInterfaceProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingInterfaceProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingInterfaceProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingInterfaceProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool RoutingInterfaceProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& RoutingInterfaceProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& RoutingInterfaceProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}

} // namespace audiomanager
} // namespace genivi
} // namespace org



#endif // ORG_GENIVI_AUDIOMANAGER_Routing_Interface_PROXY_H_

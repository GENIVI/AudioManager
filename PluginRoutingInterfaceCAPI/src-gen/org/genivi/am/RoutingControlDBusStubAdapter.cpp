/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.5.201312121915.
* Used org.franca.core 0.8.11.201401091023.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include "RoutingControlDBusStubAdapter.h"
#include <org/genivi/am/RoutingControl.h>

namespace org {
namespace genivi {
namespace am {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createRoutingControlDBusStubAdapter(
                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                   const std::string& commonApiAddress,
                   const std::string& interfaceName,
                   const std::string& busName,
                   const std::string& objectPath,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
    return std::make_shared<RoutingControlDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
}

__attribute__((constructor)) void registerRoutingControlDBusStubAdapter(void) {
    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(RoutingControl::getInterfaceId(),
                                                               &createRoutingControlDBusStubAdapter);
}



RoutingControlDBusStubAdapterInternal::~RoutingControlDBusStubAdapterInternal() {
    deactivateManagedInstances();
    RoutingControlDBusStubAdapterHelper::deinit();
}

void RoutingControlDBusStubAdapterInternal::deactivateManagedInstances() {
}

const char* RoutingControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        /**
         * aborts an asynchronous action.
        (at)return E_OK on success, E_UNKNOWN on error,
         *  E_NON_EXISTENT if handle was not found
         */
        "<method name=\"asyncAbort\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * connects a source to a sink
        (at)return E_OK on success, E_UNKNOWN on error,
         *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
         */
        "<method name=\"asyncConnect\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"connectionFormat\" type=\"q\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * disconnect a connection with given connectionID
        (at)return E_OK on success,
         *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
         */
        "<method name=\"asyncDisconnect\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * this method is used to set the volume of a sink. This function is used to drive
         *  ramps, to mute or unmute or directly set the value. The difference is made
         *  through the ramptype.
        (at)return E_OK on success, E_UNKNOWN on error,
         *  E_OUT_OF_RANGE if new volume is out of range
         */
        "<method name=\"asyncSetSinkVolume\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
            "<arg name=\"ramp\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"time\" type=\"n\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * sets the volume of a source. This method is used to set the volume of a sink.
         *  This function is used to drive ramps, to mute or unmute or directly set the
         *  value. The difference is made through the ramptype.
        (at)return E_OK on
         *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
         *  range.
        triggers the acknowledge ackSourceVolumeChange
         */
        "<method name=\"asyncSetSourceVolume\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
            "<arg name=\"ramp\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"time\" type=\"n\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * This function is used to set the source state of a particular
         *  source.
        (at)return E_OK on success, E_UNKNOWN on error
         */
        "<method name=\"asyncSetSourceState\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"state\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * this function sets the sinksoundproperty.
        (at)return E_OK on success,
         *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
         */
        "<method name=\"asyncSetSinkSoundProperties\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * this function sets the sinksoundproperty.
        (at)return E_OK on success,
         *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
         */
        "<method name=\"asyncSetSinkSoundProperty\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"soundProperty\" type=\"(qn)\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * this function sets the sourcesoundproperty.
        (at)return E_OK on success,
         *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
         */
        "<method name=\"asyncSetSourceSoundProperties\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * this function sets the sourcesoundproperty.
        (at)return E_OK on success,
         *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
         */
        "<method name=\"asyncSetSourceSoundProperty\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"soundProperty\" type=\"(qn)\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * this function triggers crossfading.
        (at)return E_OK on success, E_UNKNOWN on
         *  error
         */
        "<method name=\"asyncCrossFade\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"crossfaderID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"hotSink\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"rampType\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"time\" type=\"n\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * this function is used for early and late audio functions to set the domain
         *  state
        (at)return E_OK on success, E_UNKNOWN on error
         */
        "<method name=\"setDomainState\">\n"
            "<arg name=\"domainID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"domainState\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<method name=\"asyncSetVolumes\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"volumes\" type=\"a(i(yv)nqn)\" direction=\"in\" />\n"
        "</method>\n"
        "<method name=\"asyncSetSinkNotificationConfiguration\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"notificationConfiguration\" type=\"(qin)\" direction=\"in\" />\n"
        "</method>\n"
        "<method name=\"asyncSetSourceNotificationConfiguration\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"notificationConfiguration\" type=\"(qin)\" direction=\"in\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        RoutingControlStub,
        CommonAPI::Version
        > getRoutingControlInterfaceVersionStubDispatcher(&RoutingControlStub::getInterfaceVersion, "uu");


/**
 * aborts an asynchronous action.
(at)return E_OK on success, E_UNKNOWN on error,
 *  E_NON_EXISTENT if handle was not found
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s>,
    std::tuple<>
    > asyncAbortStubDispatcher(&RoutingControlStub::asyncAbort, "");
/**
 * connects a source to a sink
(at)return E_OK on success, E_UNKNOWN on error,
 *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_connectionID_t, am_sourceID_t, am_sinkID_t, am_CustomConnectionFormat_t>,
    std::tuple<>
    > asyncConnectStubDispatcher(&RoutingControlStub::asyncConnect, "");
/**
 * disconnect a connection with given connectionID
(at)return E_OK on success,
 *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_connectionID_t>,
    std::tuple<>
    > asyncDisconnectStubDispatcher(&RoutingControlStub::asyncDisconnect, "");
/**
 * this method is used to set the volume of a sink. This function is used to drive
 *  ramps, to mute or unmute or directly set the value. The difference is made
 *  through the ramptype.
(at)return E_OK on success, E_UNKNOWN on error,
 *  E_OUT_OF_RANGE if new volume is out of range
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sinkID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
    std::tuple<>
    > asyncSetSinkVolumeStubDispatcher(&RoutingControlStub::asyncSetSinkVolume, "");
/**
 * sets the volume of a source. This method is used to set the volume of a sink.
 *  This function is used to drive ramps, to mute or unmute or directly set the
 *  value. The difference is made through the ramptype.
(at)return E_OK on
 *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
 *  range.
triggers the acknowledge ackSourceVolumeChange
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sourceID_t, am_volume_t, am_CustomRampType_t, am_time_t>,
    std::tuple<>
    > asyncSetSourceVolumeStubDispatcher(&RoutingControlStub::asyncSetSourceVolume, "");
/**
 * This function is used to set the source state of a particular
 *  source.
(at)return E_OK on success, E_UNKNOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sourceID_t, am_SourceState_e>,
    std::tuple<>
    > asyncSetSourceStateStubDispatcher(&RoutingControlStub::asyncSetSourceState, "");
/**
 * this function sets the sinksoundproperty.
(at)return E_OK on success,
 *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_L>,
    std::tuple<>
    > asyncSetSinkSoundPropertiesStubDispatcher(&RoutingControlStub::asyncSetSinkSoundProperties, "");
/**
 * this function sets the sinksoundproperty.
(at)return E_OK on success,
 *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sinkID_t, am_SoundProperty_s>,
    std::tuple<>
    > asyncSetSinkSoundPropertyStubDispatcher(&RoutingControlStub::asyncSetSinkSoundProperty, "");
/**
 * this function sets the sourcesoundproperty.
(at)return E_OK on success,
 *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_L>,
    std::tuple<>
    > asyncSetSourceSoundPropertiesStubDispatcher(&RoutingControlStub::asyncSetSourceSoundProperties, "");
/**
 * this function sets the sourcesoundproperty.
(at)return E_OK on success,
 *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sourceID_t, am_SoundProperty_s>,
    std::tuple<>
    > asyncSetSourceSoundPropertyStubDispatcher(&RoutingControlStub::asyncSetSourceSoundProperty, "");
/**
 * this function triggers crossfading.
(at)return E_OK on success, E_UNKNOWN on
 *  error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_crossfaderID_t, am_HotSink_e, am_CustomRampType_t, am_time_t>,
    std::tuple<>
    > asyncCrossFadeStubDispatcher(&RoutingControlStub::asyncCrossFade, "");
/**
 * this function is used for early and late audio functions to set the domain
 *  state
(at)return E_OK on success, E_UNKNOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_domainID_t, am_DomainState_e>,
    std::tuple<am_Error_e>
    > setDomainStateStubDispatcher(&RoutingControlStub::setDomainState, "i");
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_Volumes_L>,
    std::tuple<>
    > asyncSetVolumesStubDispatcher(&RoutingControlStub::asyncSetVolumes, "");
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sinkID_t, am_NotificationConfiguration_s>,
    std::tuple<>
    > asyncSetSinkNotificationConfigurationStubDispatcher(&RoutingControlStub::asyncSetSinkNotificationConfiguration, "");
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlStub,
    std::tuple<am_Handle_s, am_sourceID_t, am_NotificationConfiguration_s>,
    std::tuple<>
    > asyncSetSourceNotificationConfigurationStubDispatcher(&RoutingControlStub::asyncSetSourceNotificationConfiguration, "");



const RoutingControlDBusStubAdapterHelper::StubDispatcherTable& RoutingControlDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}


RoutingControlDBusStubAdapterInternal::RoutingControlDBusStubAdapterInternal(
        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
        const std::string& commonApiAddress,
        const std::string& dbusInterfaceName,
        const std::string& dbusBusName,
        const std::string& dbusObjectPath,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
        const std::shared_ptr<CommonAPI::StubBase>& stub):
        CommonAPI::DBus::DBusStubAdapter(
                factory,
                commonApiAddress,
                dbusInterfaceName,
                dbusBusName,
                dbusObjectPath,
                dbusConnection,
                false),
        RoutingControlDBusStubAdapterHelper(
            factory,
            commonApiAddress,
            dbusInterfaceName,
            dbusBusName,
            dbusObjectPath,
            dbusConnection,
            std::dynamic_pointer_cast<RoutingControlStub>(stub),
            false),
        stubDispatcherTable_({
            /**
             * aborts an asynchronous action.
            (at)return E_OK on success, E_UNKNOWN on error,
             *  E_NON_EXISTENT if handle was not found
             */
            { { "asyncAbort", "(iq)" }, &org::genivi::am::asyncAbortStubDispatcher },
            /**
             * connects a source to a sink
            (at)return E_OK on success, E_UNKNOWN on error,
             *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
             */
            { { "asyncConnect", "(iq)qqqq" }, &org::genivi::am::asyncConnectStubDispatcher },
            /**
             * disconnect a connection with given connectionID
            (at)return E_OK on success,
             *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
             */
            { { "asyncDisconnect", "(iq)q" }, &org::genivi::am::asyncDisconnectStubDispatcher },
            /**
             * this method is used to set the volume of a sink. This function is used to drive
             *  ramps, to mute or unmute or directly set the value. The difference is made
             *  through the ramptype.
            (at)return E_OK on success, E_UNKNOWN on error,
             *  E_OUT_OF_RANGE if new volume is out of range
             */
            { { "asyncSetSinkVolume", "(iq)qnqn" }, &org::genivi::am::asyncSetSinkVolumeStubDispatcher },
            /**
             * sets the volume of a source. This method is used to set the volume of a sink.
             *  This function is used to drive ramps, to mute or unmute or directly set the
             *  value. The difference is made through the ramptype.
            (at)return E_OK on
             *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
             *  range.
            triggers the acknowledge ackSourceVolumeChange
             */
            { { "asyncSetSourceVolume", "(iq)qnqn" }, &org::genivi::am::asyncSetSourceVolumeStubDispatcher },
            /**
             * This function is used to set the source state of a particular
             *  source.
            (at)return E_OK on success, E_UNKNOWN on error
             */
            { { "asyncSetSourceState", "(iq)qi" }, &org::genivi::am::asyncSetSourceStateStubDispatcher },
            /**
             * this function sets the sinksoundproperty.
            (at)return E_OK on success,
             *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
             */
            { { "asyncSetSinkSoundProperties", "(iq)qa(qn)" }, &org::genivi::am::asyncSetSinkSoundPropertiesStubDispatcher },
            /**
             * this function sets the sinksoundproperty.
            (at)return E_OK on success,
             *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
             */
            { { "asyncSetSinkSoundProperty", "(iq)q(qn)" }, &org::genivi::am::asyncSetSinkSoundPropertyStubDispatcher },
            /**
             * this function sets the sourcesoundproperty.
            (at)return E_OK on success,
             *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
             */
            { { "asyncSetSourceSoundProperties", "(iq)qa(qn)" }, &org::genivi::am::asyncSetSourceSoundPropertiesStubDispatcher },
            /**
             * this function sets the sourcesoundproperty.
            (at)return E_OK on success,
             *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
             */
            { { "asyncSetSourceSoundProperty", "(iq)q(qn)" }, &org::genivi::am::asyncSetSourceSoundPropertyStubDispatcher },
            /**
             * this function triggers crossfading.
            (at)return E_OK on success, E_UNKNOWN on
             *  error
             */
            { { "asyncCrossFade", "(iq)qiqn" }, &org::genivi::am::asyncCrossFadeStubDispatcher },
            /**
             * this function is used for early and late audio functions to set the domain
             *  state
            (at)return E_OK on success, E_UNKNOWN on error
             */
            { { "setDomainState", "qi" }, &org::genivi::am::setDomainStateStubDispatcher },
            { { "asyncSetVolumes", "(iq)a(i(yv)nqn)" }, &org::genivi::am::asyncSetVolumesStubDispatcher },
            { { "asyncSetSinkNotificationConfiguration", "(iq)q(qin)" }, &org::genivi::am::asyncSetSinkNotificationConfigurationStubDispatcher },
            { { "asyncSetSourceNotificationConfiguration", "(iq)q(qin)" }, &org::genivi::am::asyncSetSourceNotificationConfigurationStubDispatcher }
            }) {

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::getRoutingControlInterfaceVersionStubDispatcher });
}

} // namespace am
} // namespace genivi
} // namespace org

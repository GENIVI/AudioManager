/*
* This file was generated by the CommonAPI Generators. 
* Used org.genivi.commonapi.core 2.1.1.201309251246.
* Used org.franca.core 0.8.9.201308271211.
*
* Copyright (c) 2012 BMW
* 
* \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
* 
* \copyright
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
* subject to the following conditions:
* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
* THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* 
* For further information see http://www.genivi.org/.
*/
/**
 * Routing Receive sendInterface description.
 * @author Christian Mueller
 */
#ifndef ORG_GENIVI_AM_Routing_Control_Observer_STUB_DEFAULT_H_
#define ORG_GENIVI_AM_Routing_Control_Observer_STUB_DEFAULT_H_

#include <org/genivi/am/RoutingControlObserverStub.h>
#include <sstream>

namespace org {
namespace genivi {
namespace am {

/**
 * Provides a default implementation for RoutingControlObserverStubRemoteEvent and
 * RoutingControlObserverStub. Method callbacks have an empty implementation,
 * remote set calls on attributes will always change the value of the attribute
 * to the one received.
 *
 * Override this stub if you only want to provide a subset of the functionality
 * that would be defined for this service, and/or if you do not need any non-default
 * behaviour.
 */
class RoutingControlObserverStubDefault : public RoutingControlObserverStub {
 public:
    RoutingControlObserverStubDefault();

    RoutingControlObserverStubRemoteEvent* initStubAdapter(const std::shared_ptr<RoutingControlObserverStubAdapter>& stubAdapter);

    virtual const am_RoutingReady_e& getRoutingReadyAttribute();
    virtual const am_RoutingReady_e& getRoutingReadyAttribute(const std::shared_ptr<CommonAPI::ClientId> clientId);
    virtual void setRoutingReadyAttribute(am_RoutingReady_e value);

    /**
     * acknowledges a asyncConnect
     */
    virtual void ackConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error);
    virtual void ackConnect(am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error);

    /**
     * acknowledges a asyncDisconnect
     */
    virtual void ackDisconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error);
    virtual void ackDisconnect(am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error);

    /**
     * acknowledges a asyncsetSinkVolume
     */
    virtual void ackSetSinkVolumeChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_volume_t volume, am_Error_e error);
    virtual void ackSetSinkVolumeChange(am_Handle_s handle, am_volume_t volume, am_Error_e error);

    /**
     * acknowledges a asyncsetSourceVolume
     */
    virtual void ackSetSourceVolumeChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_volume_t volume, am_Error_e error);
    virtual void ackSetSourceVolumeChange(am_Handle_s handle, am_volume_t volume, am_Error_e error);

    /**
     * acknowlegde for asyncSetSourceState
     */
    virtual void ackSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
    virtual void ackSetSourceState(am_Handle_s handle, am_Error_e error);

    /**
     * acknowledges asyncSetSinkSoundProperties
     */
    virtual void ackSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
    virtual void ackSetSinkSoundProperties(am_Handle_s handle, am_Error_e error);

    /**
     * acknowledges asyncSetSinkSoundProperty
     */
    virtual void ackSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
    virtual void ackSetSinkSoundProperty(am_Handle_s handle, am_Error_e error);

    /**
     * acknowledges asyncSetSourceSoundProperties
     */
    virtual void ackSetSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
    virtual void ackSetSourceSoundProperties(am_Handle_s handle, am_Error_e error);

    /**
     * acknowledges asyncSetSourceSoundProperty
     */
    virtual void ackSetSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
    virtual void ackSetSourceSoundProperty(am_Handle_s handle, am_Error_e error);

    /**
     * acknowledges asyncCrossFade
     */
    virtual void ackCrossFading(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_HotSink_e hotSink, am_Error_e error);
    virtual void ackCrossFading(am_Handle_s handle, am_HotSink_e hotSink, am_Error_e error);

    /**
     * acknowledges a volume tick. This can be used to display volumechanges during
     *  ramps
     */
    virtual void ackSourceVolumeTick(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume);
    virtual void ackSourceVolumeTick(am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume);

    /**
     * acknowledges a volume tick. This can be used to display volumechanges during
     *  ramps
     */
    virtual void ackSinkVolumeTick(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume);
    virtual void ackSinkVolumeTick(am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume);

    /**
     * This function returns the ID to the given domainName. If already a domain is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the domain. The other parameters of the domain
     *  will be overwritten when the domain is registered.
    (at)return E_OK on
     *  success, E_UNKNOWN on error
     */
    virtual void peekDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_domainID_t& domainID, am_Error_e& error);
    virtual void peekDomain(std::string name, am_domainID_t& domainID, am_Error_e& error);

    /**
     * registers a domain
    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
     *  registered E_UNKOWN on error
     */
    virtual void registerDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Domain_s domainData, std::string returnBusname, std::string returnInterface, am_domainID_t& domainID, am_Error_e& error);
    virtual void registerDomain(am_Domain_s domainData, std::string returnBusname, std::string returnInterface, am_domainID_t& domainID, am_Error_e& error);

    /**
     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
     *  domain will be removed as well.
    (at)return E_OK on succes, E_NON_EXISTENT if
     *  not found E_UNKOWN on error
     */
    virtual void deregisterDomain(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_Error_e& error);
    virtual void deregisterDomain(am_domainID_t domainID, am_Error_e& error);

    /**
     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
     *  registered E_UNKOWN on error
     */
    virtual void registerGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Gateway_s gatewayData, am_gatewayID_t& gatewayID, am_Error_e& error);
    virtual void registerGateway(am_Gateway_s gatewayData, am_gatewayID_t& gatewayID, am_Error_e& error);

    /**
     * deregisters a gateway. Also removes all sinks and sources of the controlling
     *  domain.
    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
     *  error
     */
    virtual void deregisterGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_gatewayID_t gatewayID, am_Error_e& error);
    virtual void deregisterGateway(am_gatewayID_t gatewayID, am_Error_e& error);

    /**
     * This function returns the ID to the given sinkName. If already a sink is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the sink. The other parameters of the sink will
     *  be overwritten when the sink is registered.
    (at)return E_OK on success,
     *  E_UNKNOWN on error
     */
    virtual void peekSink(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sinkID_t& sinkID, am_Error_e& error);
    virtual void peekSink(std::string name, am_sinkID_t& sinkID, am_Error_e& error);

    /**
     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
     *  is copied to the gatewayInformation
    (at)return E_OK on succes,
     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
     */
    virtual void registerSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Sink_s sinkData, am_sinkID_t& sinkID, am_Error_e& error);
    virtual void registerSink(am_Sink_s sinkData, am_sinkID_t& sinkID, am_Error_e& error);

    /**
     * deregisters a sink.
    (at)return E_OK on succes, E_NON_EXISTENT if not found
     *  E_UNKOWN on error
     */
    virtual void deregisterSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_Error_e& error);
    virtual void deregisterSink(am_sinkID_t sinkID, am_Error_e& error);

    /**
     * This function returns the ID to the given sourceName. If already a source is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the source. The other parameters of the source
     *  will be overwritten when the source is registered.
    (at)return E_OK on
     *  success, E_UNKNOWN on error
     */
    virtual void peekSource(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceID_t& sourceID, am_Error_e& error);
    virtual void peekSource(std::string name, am_sourceID_t& sourceID, am_Error_e& error);

    /**
     * registers a source.  If the source is part of a gateway, the
     *  listconnectionFormats is copied to the gatewayInformation
    (at)return E_OK on
     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
     *  already exists
     */
    virtual void registerSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Source_s sourceData, am_sourceID_t& sourceID, am_Error_e& error);
    virtual void registerSource(am_Source_s sourceData, am_sourceID_t& sourceID, am_Error_e& error);

    /**
     * deregisters a source
    (at)return E_OK on succes, E_NON_EXISTENT if not found
     *  E_UNKOWN on error
     */
    virtual void deregisterSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_Error_e& error);
    virtual void deregisterSource(am_sourceID_t sourceID, am_Error_e& error);

    /**
     * this function registers a crossfader.
    (at)return E_OK on succes,
     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
     */
    virtual void registerCrossfader(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Crossfader_s crossfaderData, am_crossfaderID_t& crossfaderID, am_Error_e& error);
    virtual void registerCrossfader(am_Crossfader_s crossfaderData, am_crossfaderID_t& crossfaderID, am_Error_e& error);

    /**
     * this function deregisters a crossfader. removes all sources and sinks assiated
     *  as well.
    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
     *  error
     */
    virtual void deregisterCrossfader(const std::shared_ptr<CommonAPI::ClientId> clientId, am_crossfaderID_t crossfaderID, am_Error_e& error);
    virtual void deregisterCrossfader(am_crossfaderID_t crossfaderID, am_Error_e& error);

    /**
     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
     *  determine the SinkClassIDs of a sinkClass.
    (at)return E_OK on succes,
     *  E_DATABASE_ERROR on error
     */
    virtual void peekSourceClassID(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sourceClass_t& sourceClassID, am_Error_e& error);
    virtual void peekSourceClassID(std::string name, am_sourceClass_t& sourceClassID, am_Error_e& error);

    /**
     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
     *  determine the SinkClassIDs of a sinkClass.
    (at)return E_OK on succes,
     *  E_DATABASE_ERROR on error
     */
    virtual void peekSinkClassID(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string name, am_sinkClass_t& sinkClassID, am_Error_e& error);
    virtual void peekSinkClassID(std::string name, am_sinkClass_t& sinkClassID, am_Error_e& error);

    /**
     * is called when a low level interrupt changes it status.
     */
    virtual void hookInterruptStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_InterruptState_e interruptState);
    virtual void hookInterruptStatusChange(am_sourceID_t sourceID, am_InterruptState_e interruptState);

    /**
     * This hook is called when all elements from a domain are registered.
    Is used by
     *  the Controller to know when all expected domains are finally registered
     */
    virtual void hookDomainRegistrationComplete(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID);
    virtual void hookDomainRegistrationComplete(am_domainID_t domainID);

    /**
     * is called when a sink changes its availability
     */
    virtual void hookSinkAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_Availability_s availability);
    virtual void hookSinkAvailablityStatusChange(am_sinkID_t sinkID, am_Availability_s availability);

    /**
     * is called when a source changes its availability
     */
    virtual void hookSourceAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_Availability_s availability);
    virtual void hookSourceAvailablityStatusChange(am_sourceID_t sourceID, am_Availability_s availability);

    /**
     * is called when a domain changes its status. This used for early domains only
     */
    virtual void hookDomainStateChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_DomainState_e domainState);
    virtual void hookDomainStateChange(am_domainID_t domainID, am_DomainState_e domainState);

    /**
     * is called when the timinginformation (delay) changed for a connection.
     */
    virtual void hookTimingInformationChanged(const std::shared_ptr<CommonAPI::ClientId> clientId, am_connectionID_t connectionID, am_timeSync_t delay);
    virtual void hookTimingInformationChanged(am_connectionID_t connectionID, am_timeSync_t delay);

    /**
     * this function is used to send out all data that has been changed in an early
     *  state.
    (at)return E_OK on success, E_UNKNOWN on error
     */
    virtual void sendChangedData(const std::shared_ptr<CommonAPI::ClientId> clientId, am_EarlyData_L earlyData);
    virtual void sendChangedData(am_EarlyData_L earlyData);

    /**
     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
     *  gatewayID is not valid.
     */
    virtual void updateGateway(const std::shared_ptr<CommonAPI::ClientId> clientId, am_gatewayID_t gatewayID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error);
    virtual void updateGateway(am_gatewayID_t gatewayID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error);

    /**
     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
     *  sinkID is not valid.
     */
    virtual void updateSink(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_sinkClass_t sinkClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error);
    virtual void updateSink(am_sinkID_t sinkID, am_sinkClass_t sinkClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error);

    /**
     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
     *  sourceID in the struct is not valid. 
    Please note that only the following
     *  data out of am_Source_s have effect when they are
     *  changed:
    sourceClassID,
    listSoundProperties,
    listConnectionFormats,
     * 
    listMainSoundProperties
     */
    virtual void updateSource(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_sourceClass_t sourceClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error);
    virtual void updateSource(am_sourceID_t sourceID, am_sourceClass_t sourceClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error);

    /**
     * acknowledges a asyncSetSinkVolumes
     */
    virtual void ackSetVolumes(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Volumes_L listvolumes, am_Error_e error);
    virtual void ackSetVolumes(am_Handle_s handle, am_Volumes_L listvolumes, am_Error_e error);

    /**
     * The acknowledge of the SinkNotificationConfiguration
     */
    virtual void ackSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
    virtual void ackSinkNotificationConfiguration(am_Handle_s handle, am_Error_e error);

    /**
     * The acknowledge of the SourceNotificationConfiguration
     */
    virtual void ackSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Error_e error);
    virtual void ackSourceNotificationConfiguration(am_Handle_s handle, am_Error_e error);

    /**
     * is called whenever a notified value needs to be send
     */
    virtual void hookSinkNotificationDataChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sinkID_t sinkID, am_NotificationPayload_s payload);
    virtual void hookSinkNotificationDataChange(am_sinkID_t sinkID, am_NotificationPayload_s payload);

    /**
     * is called whenever a notified value needs to be send
     */
    virtual void hookSourceNotificationDataChange(const std::shared_ptr<CommonAPI::ClientId> clientId, am_sourceID_t sourceID, am_NotificationPayload_s payload);
    virtual void hookSourceNotificationDataChange(am_sourceID_t sourceID, am_NotificationPayload_s payload);

    virtual void confirmRoutingRundown(const std::shared_ptr<CommonAPI::ClientId> clientId, std::string domainName);
    virtual void confirmRoutingRundown(std::string domainName);


    

 protected:
    /**
     * This attribute signals to the clients the current routing state.
    A client
     *  should notify himself to this attribute in order to know the current state and
     *  act accordingly.
     */
    virtual bool trySetRoutingReadyAttribute(am_RoutingReady_e value);
    virtual bool validateRoutingReadyAttributeRequestedValue(const am_RoutingReady_e& value);
    std::shared_ptr<RoutingControlObserverStubAdapter> stubAdapter_;
 private:
    class RemoteEventHandler: public RoutingControlObserverStubRemoteEvent {
     public:
        RemoteEventHandler(RoutingControlObserverStubDefault* defaultStub);

        /**
         * This attribute signals to the clients the current routing state.
        A client
         *  should notify himself to this attribute in order to know the current state and
         *  act accordingly.
         */


     private:
        RoutingControlObserverStubDefault* defaultStub_;
    };

    RemoteEventHandler remoteEventHandler_;

    /**
     * This attribute signals to the clients the current routing state.
    A client
     *  should notify himself to this attribute in order to know the current state and
     *  act accordingly.
     */
    am_RoutingReady_e routingReadyAttributeValue_;
};

} // namespace am
} // namespace genivi
} // namespace org

#endif // ORG_GENIVI_AM_Routing_Control_Observer_STUB_DEFAULT_H_

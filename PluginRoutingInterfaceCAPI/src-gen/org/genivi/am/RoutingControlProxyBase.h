 /*
 * This file was generated by the CommonAPI Generators.
 *
 * This file was generated by the CommonAPI Generators.
 *
 * This file was generated by the CommonAPI Generators.
 *
 * Copyright (C) 2012, BMW AG
 *
 * This file is part of GENIVI Project AudioManager.
 *
 * Contributions are licensed to the GENIVI Alliance under one or more
 * Contribution License Agreements.
 *
 * \copyright
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
 * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 *
 * \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
 * \author Christian Linke christian.linke@bmw.de BMW 2013
 *
 * For further information see http://www.genivi.org/.
 */
 #ifndef ORG_GENIVI_AM_Routing_Control_PROXY_BASE_H_
 #define ORG_GENIVI_AM_Routing_Control_PROXY_BASE_H_
 
 #include "RoutingControl.h"
 
 
 #include <org/genivi/am.h>
 
 #define COMMONAPI_INTERNAL_COMPILATION
 
 #include <CommonAPI/InputStream.h>
 #include <CommonAPI/OutputStream.h>
 #include <CommonAPI/SerializableStruct.h>
 #include <cstdint>
 #include <vector>

 #include <CommonAPI/Proxy.h>
 #include <functional>
 #include <future>
 
 #undef COMMONAPI_INTERNAL_COMPILATION

 namespace org {
 namespace genivi {
 namespace am {

 class RoutingControlProxyBase: virtual public CommonAPI::Proxy {
  public:
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncAbortAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncConnectAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncDisconnectAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSinkVolumeAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceVolumeAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceStateAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSinkSoundPropertiesAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSinkSoundPropertyAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceSoundPropertiesAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceSoundPropertyAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncCrossFadeAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> SetDomainStateAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetVolumesAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSinkNotificationConfigurationAsyncCallback;
     typedef std::function<void(const CommonAPI::CallStatus&)> AsyncSetSourceNotificationConfigurationAsyncCallback;




     virtual void asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback) = 0;

     virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_ConnectionFormat_pe& connectionFormat, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_ConnectionFormat_pe& connectionFormat, AsyncConnectAsyncCallback callback) = 0;

     virtual void asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback) = 0;

     virtual void asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback) = 0;

     virtual void asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback) = 0;

     virtual void asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback) = 0;

     virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback) = 0;

     virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback) = 0;

     virtual void asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback) = 0;

     virtual void asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback) = 0;

     virtual void asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_RampType_pe& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_RampType_pe& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback) = 0;

     virtual void setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
     virtual std::future<CommonAPI::CallStatus> setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback) = 0;

     virtual void asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback) = 0;

     virtual void asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback) = 0;

     virtual void asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) = 0;
     virtual std::future<CommonAPI::CallStatus> asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback) = 0;
 };

 } // namespace am
 } // namespace genivi
 } // namespace org

 #endif // ORG_GENIVI_AM_Routing_Control_PROXY_BASE_H_

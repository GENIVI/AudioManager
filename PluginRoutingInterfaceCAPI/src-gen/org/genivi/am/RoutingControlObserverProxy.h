/*
* This file was generated by the CommonAPI Generators.
*
* This file was generated by the CommonAPI Generators.
*
* This file was generated by the CommonAPI Generators.
*
* Copyright (C) 2012, BMW AG
*
* This file is part of GENIVI Project AudioManager.
*
* Contributions are licensed to the GENIVI Alliance under one or more
* Contribution License Agreements.
*
* \copyright
* This Source Code Form is subject to the terms of the
* Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
* this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
*
* \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
* \author Christian Linke christian.linke@bmw.de BMW 2013
*
* For further information see http://www.genivi.org/.
*/
#ifndef ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_
#define ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_

#include "RoutingControlObserverProxyBase.h"

#define COMMONAPI_INTERNAL_COMPILATION

#include <CommonAPI/AttributeExtension.h>
#include <CommonAPI/Factory.h>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace am {

template <typename ... _AttributeExtensions>
class RoutingControlObserverProxy: virtual public RoutingControlObserver, virtual public RoutingControlObserverProxyBase, public _AttributeExtensions... {
 public:
    RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~RoutingControlObserverProxy();

    /// Returns the wrapper class that provides access to the attribute RoutingReady.
    virtual RoutingReadyAttribute& getRoutingReadyAttribute() {
        return delegate_->getRoutingReadyAttribute();
    }




    /**
     * Calls ackConnect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackConnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback);

    /**
     * Calls ackDisconnect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackDisconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback);

    /**
     * Calls ackSetSinkVolumeChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkVolumeChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback);

    /**
     * Calls ackSetSourceVolumeChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceVolumeChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback);

    /**
     * Calls ackSetSourceState with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback);

    /**
     * Calls ackSetSinkSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback);

    /**
     * Calls ackSetSinkSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback);

    /**
     * Calls ackSetSourceSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback);

    /**
     * Calls ackSetSourceSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback);

    /**
     * Calls ackCrossFading with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackCrossFading with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback);

    /**
     * Calls ackSourceVolumeTick with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSourceVolumeTick with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback);

    /**
     * Calls ackSinkVolumeTick with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSinkVolumeTick with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback);

    /**
     * Calls peekDomain with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
    /**
     * Calls peekDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback);

    /**
     * Calls registerDomain with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerDomain(const am_Domain_s& domainData, const std::string& returnInterface, const std::string& returnPath, const std::string& returnBusname, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
    /**
     * Calls registerDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_Domain_s& domainData, const std::string& returnInterface, const std::string& returnPath, const std::string& returnBusname, RegisterDomainAsyncCallback callback);

    /**
     * Calls deregisterDomain with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback);

    /**
     * Calls registerGateway with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error);
    /**
     * Calls registerGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback);

    /**
     * Calls deregisterGateway with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback);

    /**
     * Calls peekSink with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
    /**
     * Calls peekSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback);

    /**
     * Calls registerSink with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
    /**
     * Calls registerSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback);

    /**
     * Calls deregisterSink with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback);

    /**
     * Calls peekSource with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
    /**
     * Calls peekSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback);

    /**
     * Calls registerSource with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
    /**
     * Calls registerSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback);

    /**
     * Calls deregisterSource with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback);

    /**
     * Calls registerCrossfader with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error);
    /**
     * Calls registerCrossfader with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback);

    /**
     * Calls deregisterCrossfader with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterCrossfader with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback);

    /**
     * Calls peekSourceClassID with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error);
    /**
     * Calls peekSourceClassID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback);

    /**
     * Calls peekSinkClassID with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error);
    /**
     * Calls peekSinkClassID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback);

    /**
     * Calls hookInterruptStatusChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookInterruptStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback);

    /**
     * Calls hookDomainRegistrationComplete with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookDomainRegistrationComplete with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback);

    /**
     * Calls hookSinkAvailablityStatusChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSinkAvailablityStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback);

    /**
     * Calls hookSourceAvailablityStatusChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSourceAvailablityStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback);

    /**
     * Calls hookDomainStateChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookDomainStateChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback);

    /**
     * Calls hookTimingInformationChanged with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookTimingInformationChanged with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback);

    /**
     * Calls sendChangedData with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus);
    /**
     * Calls sendChangedData with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback);

    /**
     * Calls updateGateway with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls updateGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback);

    /**
     * Calls updateSink with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls updateSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback);

    /**
     * Calls updateSource with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls updateSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback);

    /**
     * Calls ackSetVolumes with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetVolumes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback);

    /**
     * Calls ackSinkNotificationConfiguration with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSinkNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback);

    /**
     * Calls ackSourceNotificationConfiguration with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSourceNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback);

    /**
     * Calls hookSinkNotificationDataChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSinkNotificationDataChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback);

    /**
     * Calls hookSourceNotificationDataChange with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSourceNotificationDataChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback);

    /**
     * Calls confirmRoutingRundown with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus);
    /**
     * Calls confirmRoutingRundown with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback);

    /// Returns the CommonAPI address of the remote partner this proxy communicates with.
    virtual std::string getAddress() const;

    /// Returns the domain of the remote partner this proxy communicates with.
    virtual const std::string& getDomain() const;

    /// Returns the service ID of the remote partner this proxy communicates with.
    virtual const std::string& getServiceId() const;

    /// Returns the instance ID of the remote partner this proxy communicates with.
    virtual const std::string& getInstanceId() const;

    /// Returns true if the remote partner for this proxy is available.
    virtual bool isAvailable() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<RoutingControlObserverProxyBase> delegate_;
};

namespace RoutingControlObserverExtensions {
    template <template <typename > class _ExtensionType>
    class RoutingReadyAttributeExtension {
     public:
        typedef _ExtensionType<RoutingControlObserverProxyBase::RoutingReadyAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<RoutingControlObserverProxyBase::RoutingReadyAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        RoutingReadyAttributeExtension(RoutingControlObserverProxyBase& proxy): attributeExtension_(proxy.getRoutingReadyAttribute()) {
        }
    
        inline extension_type& getRoutingReadyAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace RoutingControlObserverExtensions

//
// RoutingControlObserverProxy Implementation
//
template <typename ... _AttributeExtensions>
RoutingControlObserverProxy<_AttributeExtensions...>::RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        delegate_(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)),
        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)))... {
}

template <typename ... _AttributeExtensions>
RoutingControlObserverProxy<_AttributeExtensions...>::~RoutingControlObserverProxy() {
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackConnect(handle, connectionID, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback) {
    return delegate_->ackConnectAsync(handle, connectionID, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackDisconnect(handle, connectionID, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback) {
    return delegate_->ackDisconnectAsync(handle, connectionID, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkVolumeChange(handle, volume, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback) {
    return delegate_->ackSetSinkVolumeChangeAsync(handle, volume, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceVolumeChange(handle, volume, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback) {
    return delegate_->ackSetSourceVolumeChangeAsync(handle, volume, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceState(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback) {
    return delegate_->ackSetSourceStateAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkSoundProperties(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback) {
    return delegate_->ackSetSinkSoundPropertiesAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkSoundProperty(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback) {
    return delegate_->ackSetSinkSoundPropertyAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceSoundProperties(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback) {
    return delegate_->ackSetSourceSoundPropertiesAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceSoundProperty(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback) {
    return delegate_->ackSetSourceSoundPropertyAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackCrossFading(handle, hotSink, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback) {
    return delegate_->ackCrossFadingAsync(handle, hotSink, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSourceVolumeTick(handle, sourceID, volume, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback) {
    return delegate_->ackSourceVolumeTickAsync(handle, sourceID, volume, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSinkVolumeTick(handle, sinkID, volume, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback) {
    return delegate_->ackSinkVolumeTickAsync(handle, sinkID, volume, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
    delegate_->peekDomain(name, callStatus, domainID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) {
    return delegate_->peekDomainAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerDomain(const am_Domain_s& domainData, const std::string& returnInterface, const std::string& returnPath, const std::string& returnBusname, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
    delegate_->registerDomain(domainData, returnInterface, returnPath, returnBusname, callStatus, domainID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerDomainAsync(const am_Domain_s& domainData, const std::string& returnInterface, const std::string& returnPath, const std::string& returnBusname, RegisterDomainAsyncCallback callback) {
    return delegate_->registerDomainAsync(domainData, returnInterface, returnPath, returnBusname, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterDomain(domainID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback) {
    return delegate_->deregisterDomainAsync(domainID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error) {
    delegate_->registerGateway(gatewayData, callStatus, gatewayID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback) {
    return delegate_->registerGatewayAsync(gatewayData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterGateway(gatewayID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback) {
    return delegate_->deregisterGatewayAsync(gatewayID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
    delegate_->peekSink(name, callStatus, sinkID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback) {
    return delegate_->peekSinkAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
    delegate_->registerSink(sinkData, callStatus, sinkID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback) {
    return delegate_->registerSinkAsync(sinkData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterSink(sinkID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback) {
    return delegate_->deregisterSinkAsync(sinkID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
    delegate_->peekSource(name, callStatus, sourceID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) {
    return delegate_->peekSourceAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
    delegate_->registerSource(sourceData, callStatus, sourceID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback) {
    return delegate_->registerSourceAsync(sourceData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterSource(sourceID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback) {
    return delegate_->deregisterSourceAsync(sourceID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error) {
    delegate_->registerCrossfader(crossfaderData, callStatus, crossfaderID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback) {
    return delegate_->registerCrossfaderAsync(crossfaderData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterCrossfader(crossfaderID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback) {
    return delegate_->deregisterCrossfaderAsync(crossfaderID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error) {
    delegate_->peekSourceClassID(name, callStatus, sourceClassID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback) {
    return delegate_->peekSourceClassIDAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error) {
    delegate_->peekSinkClassID(name, callStatus, sinkClassID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback) {
    return delegate_->peekSinkClassIDAsync(name, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus) {
    delegate_->hookInterruptStatusChange(sourceID, interruptState, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback) {
    return delegate_->hookInterruptStatusChangeAsync(sourceID, interruptState, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) {
    delegate_->hookDomainRegistrationComplete(domainID, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback) {
    return delegate_->hookDomainRegistrationCompleteAsync(domainID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSinkAvailablityStatusChange(sinkID, availability, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback) {
    return delegate_->hookSinkAvailablityStatusChangeAsync(sinkID, availability, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSourceAvailablityStatusChange(sourceID, availability, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback) {
    return delegate_->hookSourceAvailablityStatusChangeAsync(sourceID, availability, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus) {
    delegate_->hookDomainStateChange(domainID, domainState, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback) {
    return delegate_->hookDomainStateChangeAsync(domainID, domainState, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus) {
    delegate_->hookTimingInformationChanged(connectionID, delay, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback) {
    return delegate_->hookTimingInformationChangedAsync(connectionID, delay, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus) {
    delegate_->sendChangedData(earlyData, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback) {
    return delegate_->sendChangedDataAsync(earlyData, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->updateGateway(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback) {
    return delegate_->updateGatewayAsync(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->updateSink(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback) {
    return delegate_->updateSinkAsync(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->updateSource(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback) {
    return delegate_->updateSourceAsync(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetVolumes(handle, listvolumes, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback) {
    return delegate_->ackSetVolumesAsync(handle, listvolumes, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSinkNotificationConfiguration(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback) {
    return delegate_->ackSinkNotificationConfigurationAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSourceNotificationConfiguration(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback) {
    return delegate_->ackSourceNotificationConfigurationAsync(handle, error, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSinkNotificationDataChange(sinkID, payload, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback) {
    return delegate_->hookSinkNotificationDataChangeAsync(sinkID, payload, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSourceNotificationDataChange(sourceID, payload, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback) {
    return delegate_->hookSourceNotificationDataChangeAsync(sourceID, payload, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus) {
    delegate_->confirmRoutingRundown(domainName, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback) {
    return delegate_->confirmRoutingRundownAsync(domainName, callback);
}


template <typename ... _AttributeExtensions>
std::string RoutingControlObserverProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool RoutingControlObserverProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& RoutingControlObserverProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& RoutingControlObserverProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}

} // namespace am
} // namespace genivi
} // namespace org

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyFactoryHelper<org::genivi::am::RoutingControlObserverProxy,
    _AttributeExtension> {
    typedef typename org::genivi::am::RoutingControlObserverProxy<
            org::genivi::am::RoutingControlObserverExtensions::RoutingReadyAttributeExtension<_AttributeExtension>
    > class_t;
};
}


#endif // ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_

/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.5.201312121915.
* Used org.franca.core 0.8.11.201401091023.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * Routing Receive sendInterface description.
 * @author Christian Mueller
 */
#ifndef ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_
#define ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_

#include "RoutingControlObserverProxyBase.h"


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.h>
#include <CommonAPI/Factory.h>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace am {

template <typename ... _AttributeExtensions>
class RoutingControlObserverProxy: virtual public RoutingControlObserver, virtual public RoutingControlObserverProxyBase
, public _AttributeExtensions... {
public:
    RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~RoutingControlObserverProxy();

    typedef RoutingControlObserver InterfaceType;


    /**
     * This attribute signals to the clients the current routing state.
    A client
     *  should notify himself to this attribute in order to know the current state and
     *  act accordingly.
     */
    /**
     * Returns the wrapper class that provides access to the attribute RoutingReady.
     */
    virtual RoutingReadyAttribute& getRoutingReadyAttribute() {
        return delegate_->getRoutingReadyAttribute();
    }


    /**
     * acknowledges a asyncConnect
     * 
     * Calls ackConnect with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackConnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback);
    /**
     * acknowledges a asyncDisconnect
     * 
     * Calls ackDisconnect with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackDisconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback);
    /**
     * acknowledges a asyncsetSinkVolume
     * 
     * Calls ackSetSinkVolumeChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkVolumeChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback);
    /**
     * acknowledges a asyncsetSourceVolume
     * 
     * Calls ackSetSourceVolumeChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceVolumeChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback);
    /**
     * acknowlegde for asyncSetSourceState
     * 
     * Calls ackSetSourceState with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback);
    /**
     * acknowledges asyncSetSinkSoundProperties
     * 
     * Calls ackSetSinkSoundProperties with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback);
    /**
     * acknowledges asyncSetSinkSoundProperty
     * 
     * Calls ackSetSinkSoundProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSinkSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback);
    /**
     * acknowledges asyncSetSourceSoundProperties
     * 
     * Calls ackSetSourceSoundProperties with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback);
    /**
     * acknowledges asyncSetSourceSoundProperty
     * 
     * Calls ackSetSourceSoundProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetSourceSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback);
    /**
     * acknowledges asyncCrossFade
     * 
     * Calls ackCrossFading with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackCrossFading with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback);
    /**
     * acknowledges a volume tick. This can be used to display volumechanges during
     *  ramps
     * 
     * Calls ackSourceVolumeTick with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSourceVolumeTick with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback);
    /**
     * acknowledges a volume tick. This can be used to display volumechanges during
     *  ramps
     * 
     * Calls ackSinkVolumeTick with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSinkVolumeTick with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback);
    /**
     * This function returns the ID to the given domainName. If already a domain is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the domain. The other parameters of the domain
     *  will be overwritten when the domain is registered.
    (at)return E_OK on
     *  success, E_UNKNOWN on error
     * 
     * Calls peekDomain with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
    /**
     * Calls peekDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback);
    /**
     * registers a domain
    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
     *  registered E_UNKOWN on error
     * 
     * Calls registerDomain with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
    /**
     * Calls registerDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback);
    /**
     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
     *  domain will be removed as well.
    (at)return E_OK on succes, E_NON_EXISTENT if
     *  not found E_UNKOWN on error
     * 
     * Calls deregisterDomain with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback);
    /**
     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
     *  registered E_UNKOWN on error
     * 
     * Calls registerGateway with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error);
    /**
     * Calls registerGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback);
    /**
     * deregisters a gateway. Also removes all sinks and sources of the controlling
     *  domain.
    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
     *  error
     * 
     * Calls deregisterGateway with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback);
    /**
     * This function returns the ID to the given sinkName. If already a sink is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the sink. The other parameters of the sink will
     *  be overwritten when the sink is registered.
    (at)return E_OK on success,
     *  E_UNKNOWN on error
     * 
     * Calls peekSink with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
    /**
     * Calls peekSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback);
    /**
     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
     *  is copied to the gatewayInformation
    (at)return E_OK on succes,
     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
     * 
     * Calls registerSink with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
    /**
     * Calls registerSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback);
    /**
     * deregisters a sink.
    (at)return E_OK on succes, E_NON_EXISTENT if not found
     *  E_UNKOWN on error
     * 
     * Calls deregisterSink with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback);
    /**
     * This function returns the ID to the given sourceName. If already a source is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the source. The other parameters of the source
     *  will be overwritten when the source is registered.
    (at)return E_OK on
     *  success, E_UNKNOWN on error
     * 
     * Calls peekSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
    /**
     * Calls peekSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback);
    /**
     * registers a source.  If the source is part of a gateway, the
     *  listconnectionFormats is copied to the gatewayInformation
    (at)return E_OK on
     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
     *  already exists
     * 
     * Calls registerSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
    /**
     * Calls registerSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback);
    /**
     * deregisters a source
    (at)return E_OK on succes, E_NON_EXISTENT if not found
     *  E_UNKOWN on error
     * 
     * Calls deregisterSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback);
    /**
     * this function registers a crossfader.
    (at)return E_OK on succes,
     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
     * 
     * Calls registerCrossfader with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error);
    /**
     * Calls registerCrossfader with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback);
    /**
     * this function deregisters a crossfader. removes all sources and sinks assiated
     *  as well.
    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
     *  error
     * 
     * Calls deregisterCrossfader with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls deregisterCrossfader with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback);
    /**
     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
     *  determine the SinkClassIDs of a sinkClass.
    (at)return E_OK on succes,
     *  E_DATABASE_ERROR on error
     * 
     * Calls peekSourceClassID with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error);
    /**
     * Calls peekSourceClassID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback);
    /**
     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
     *  determine the SinkClassIDs of a sinkClass.
    (at)return E_OK on succes,
     *  E_DATABASE_ERROR on error
     * 
     * Calls peekSinkClassID with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error);
    /**
     * Calls peekSinkClassID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback);
    /**
     * is called when a low level interrupt changes it status.
     * 
     * Calls hookInterruptStatusChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookInterruptStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback);
    /**
     * This hook is called when all elements from a domain are registered.
    Is used by
     *  the Controller to know when all expected domains are finally registered
     * 
     * Calls hookDomainRegistrationComplete with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookDomainRegistrationComplete with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback);
    /**
     * is called when a sink changes its availability
     * 
     * Calls hookSinkAvailablityStatusChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSinkAvailablityStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback);
    /**
     * is called when a source changes its availability
     * 
     * Calls hookSourceAvailablityStatusChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSourceAvailablityStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback);
    /**
     * is called when a domain changes its status. This used for early domains only
     * 
     * Calls hookDomainStateChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookDomainStateChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback);
    /**
     * is called when the timinginformation (delay) changed for a connection.
     * 
     * Calls hookTimingInformationChanged with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookTimingInformationChanged with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback);
    /**
     * this function is used to send out all data that has been changed in an early
     *  state.
    (at)return E_OK on success, E_UNKNOWN on error
     * 
     * Calls sendChangedData with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus);
    /**
     * Calls sendChangedData with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback);
    /**
     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
     *  gatewayID is not valid.
     * 
     * Calls updateGateway with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls updateGateway with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback);
    /**
     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
     *  sinkID is not valid.
     * 
     * Calls updateSink with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls updateSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback);
    /**
     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
     *  sourceID in the struct is not valid. 
    Please note that only the following
     *  data out of am_Source_s have effect when they are
     *  changed:
    sourceClassID,
    listSoundProperties,
    listConnectionFormats,
     * 
    listMainSoundProperties
     * 
     * Calls updateSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls updateSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback);
    /**
     * acknowledges a asyncSetSinkVolumes
     * 
     * Calls ackSetVolumes with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSetVolumes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback);
    /**
     * The acknowledge of the SinkNotificationConfiguration
     * 
     * Calls ackSinkNotificationConfiguration with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSinkNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback);
    /**
     * The acknowledge of the SourceNotificationConfiguration
     * 
     * Calls ackSourceNotificationConfiguration with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    /**
     * Calls ackSourceNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback);
    /**
     * is called whenever a notified value needs to be send
     * 
     * Calls hookSinkNotificationDataChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSinkNotificationDataChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback);
    /**
     * is called whenever a notified value needs to be send
     * 
     * Calls hookSourceNotificationDataChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    /**
     * Calls hookSourceNotificationDataChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback);
    /**
     * Calls confirmRoutingRundown with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus);
    /**
     * Calls confirmRoutingRundown with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual std::string getAddress() const;

    /**
     * Returns the domain of the remote partner this proxy communicates with.
     */
    virtual const std::string& getDomain() const;

    /** 
     * Returns the service ID of the remote partner this proxy communicates with.
     */
    virtual const std::string& getServiceId() const;

    /**
     * Returns the instance ID of the remote partner this proxy communicates with.
     */
    virtual const std::string& getInstanceId() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<RoutingControlObserverProxyBase> delegate_;
};

namespace RoutingControlObserverExtensions {
    /**
     * This attribute signals to the clients the current routing state.
    A client
     *  should notify himself to this attribute in order to know the current state and
     *  act accordingly.
     */
    template <template <typename > class _ExtensionType>
    class RoutingReadyAttributeExtension {
     public:
        typedef _ExtensionType<RoutingControlObserverProxyBase::RoutingReadyAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<RoutingControlObserverProxyBase::RoutingReadyAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        RoutingReadyAttributeExtension(RoutingControlObserverProxyBase& proxy): attributeExtension_(proxy.getRoutingReadyAttribute()) {
        }
    
        inline extension_type& getRoutingReadyAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace RoutingControlObserverExtensions

//
// RoutingControlObserverProxy Implementation
//
template <typename ... _AttributeExtensions>
RoutingControlObserverProxy<_AttributeExtensions...>::RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        delegate_(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)),
        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)))... {
}

template <typename ... _AttributeExtensions>
RoutingControlObserverProxy<_AttributeExtensions...>::~RoutingControlObserverProxy() {
}

/**
 * acknowledges a asyncConnect
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackConnect(handle, connectionID, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback) {
    return delegate_->ackConnectAsync(handle, connectionID, error, callback);
}
/**
 * acknowledges a asyncDisconnect
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackDisconnect(handle, connectionID, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback) {
    return delegate_->ackDisconnectAsync(handle, connectionID, error, callback);
}
/**
 * acknowledges a asyncsetSinkVolume
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkVolumeChange(handle, volume, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback) {
    return delegate_->ackSetSinkVolumeChangeAsync(handle, volume, error, callback);
}
/**
 * acknowledges a asyncsetSourceVolume
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceVolumeChange(handle, volume, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback) {
    return delegate_->ackSetSourceVolumeChangeAsync(handle, volume, error, callback);
}
/**
 * acknowlegde for asyncSetSourceState
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceState(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback) {
    return delegate_->ackSetSourceStateAsync(handle, error, callback);
}
/**
 * acknowledges asyncSetSinkSoundProperties
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkSoundProperties(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback) {
    return delegate_->ackSetSinkSoundPropertiesAsync(handle, error, callback);
}
/**
 * acknowledges asyncSetSinkSoundProperty
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSinkSoundProperty(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback) {
    return delegate_->ackSetSinkSoundPropertyAsync(handle, error, callback);
}
/**
 * acknowledges asyncSetSourceSoundProperties
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceSoundProperties(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback) {
    return delegate_->ackSetSourceSoundPropertiesAsync(handle, error, callback);
}
/**
 * acknowledges asyncSetSourceSoundProperty
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetSourceSoundProperty(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback) {
    return delegate_->ackSetSourceSoundPropertyAsync(handle, error, callback);
}
/**
 * acknowledges asyncCrossFade
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackCrossFading(handle, hotSink, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback) {
    return delegate_->ackCrossFadingAsync(handle, hotSink, error, callback);
}
/**
 * acknowledges a volume tick. This can be used to display volumechanges during
 *  ramps
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSourceVolumeTick(handle, sourceID, volume, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback) {
    return delegate_->ackSourceVolumeTickAsync(handle, sourceID, volume, callback);
}
/**
 * acknowledges a volume tick. This can be used to display volumechanges during
 *  ramps
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSinkVolumeTick(handle, sinkID, volume, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback) {
    return delegate_->ackSinkVolumeTickAsync(handle, sinkID, volume, callback);
}
/**
 * This function returns the ID to the given domainName. If already a domain is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the domain. The other parameters of the domain
 *  will be overwritten when the domain is registered.
(at)return E_OK on
 *  success, E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
    delegate_->peekDomain(name, callStatus, domainID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) {
    return delegate_->peekDomainAsync(name, callback);
}
/**
 * registers a domain
(at)return E_OK on succes, E_ALREADY_EXISTENT if already
 *  registered E_UNKOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
    delegate_->registerDomain(domainData, returnBusname, returnInterface, callStatus, domainID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback) {
    return delegate_->registerDomainAsync(domainData, returnBusname, returnInterface, callback);
}
/**
 * deregisters a domain. All sources, sinks, gateways and crossfaders from that
 *  domain will be removed as well.
(at)return E_OK on succes, E_NON_EXISTENT if
 *  not found E_UNKOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterDomain(domainID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback) {
    return delegate_->deregisterDomainAsync(domainID, callback);
}
/**
 * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
 *  registered E_UNKOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error) {
    delegate_->registerGateway(gatewayData, callStatus, gatewayID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback) {
    return delegate_->registerGatewayAsync(gatewayData, callback);
}
/**
 * deregisters a gateway. Also removes all sinks and sources of the controlling
 *  domain.
(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
 *  error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterGateway(gatewayID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback) {
    return delegate_->deregisterGatewayAsync(gatewayID, callback);
}
/**
 * This function returns the ID to the given sinkName. If already a sink is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the sink. The other parameters of the sink will
 *  be overwritten when the sink is registered.
(at)return E_OK on success,
 *  E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
    delegate_->peekSink(name, callStatus, sinkID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback) {
    return delegate_->peekSinkAsync(name, callback);
}
/**
 * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
 *  is copied to the gatewayInformation
(at)return E_OK on succes,
 *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
    delegate_->registerSink(sinkData, callStatus, sinkID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback) {
    return delegate_->registerSinkAsync(sinkData, callback);
}
/**
 * deregisters a sink.
(at)return E_OK on succes, E_NON_EXISTENT if not found
 *  E_UNKOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterSink(sinkID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback) {
    return delegate_->deregisterSinkAsync(sinkID, callback);
}
/**
 * This function returns the ID to the given sourceName. If already a source is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the source. The other parameters of the source
 *  will be overwritten when the source is registered.
(at)return E_OK on
 *  success, E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
    delegate_->peekSource(name, callStatus, sourceID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) {
    return delegate_->peekSourceAsync(name, callback);
}
/**
 * registers a source.  If the source is part of a gateway, the
 *  listconnectionFormats is copied to the gatewayInformation
(at)return E_OK on
 *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
 *  already exists
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
    delegate_->registerSource(sourceData, callStatus, sourceID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback) {
    return delegate_->registerSourceAsync(sourceData, callback);
}
/**
 * deregisters a source
(at)return E_OK on succes, E_NON_EXISTENT if not found
 *  E_UNKOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterSource(sourceID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback) {
    return delegate_->deregisterSourceAsync(sourceID, callback);
}
/**
 * this function registers a crossfader.
(at)return E_OK on succes,
 *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error) {
    delegate_->registerCrossfader(crossfaderData, callStatus, crossfaderID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback) {
    return delegate_->registerCrossfaderAsync(crossfaderData, callback);
}
/**
 * this function deregisters a crossfader. removes all sources and sinks assiated
 *  as well.
(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
 *  error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->deregisterCrossfader(crossfaderID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback) {
    return delegate_->deregisterCrossfaderAsync(crossfaderID, callback);
}
/**
 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
 *  determine the SinkClassIDs of a sinkClass.
(at)return E_OK on succes,
 *  E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error) {
    delegate_->peekSourceClassID(name, callStatus, sourceClassID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback) {
    return delegate_->peekSourceClassIDAsync(name, callback);
}
/**
 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
 *  determine the SinkClassIDs of a sinkClass.
(at)return E_OK on succes,
 *  E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error) {
    delegate_->peekSinkClassID(name, callStatus, sinkClassID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback) {
    return delegate_->peekSinkClassIDAsync(name, callback);
}
/**
 * is called when a low level interrupt changes it status.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus) {
    delegate_->hookInterruptStatusChange(sourceID, interruptState, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback) {
    return delegate_->hookInterruptStatusChangeAsync(sourceID, interruptState, callback);
}
/**
 * This hook is called when all elements from a domain are registered.
Is used by
 *  the Controller to know when all expected domains are finally registered
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) {
    delegate_->hookDomainRegistrationComplete(domainID, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback) {
    return delegate_->hookDomainRegistrationCompleteAsync(domainID, callback);
}
/**
 * is called when a sink changes its availability
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSinkAvailablityStatusChange(sinkID, availability, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback) {
    return delegate_->hookSinkAvailablityStatusChangeAsync(sinkID, availability, callback);
}
/**
 * is called when a source changes its availability
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSourceAvailablityStatusChange(sourceID, availability, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback) {
    return delegate_->hookSourceAvailablityStatusChangeAsync(sourceID, availability, callback);
}
/**
 * is called when a domain changes its status. This used for early domains only
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus) {
    delegate_->hookDomainStateChange(domainID, domainState, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback) {
    return delegate_->hookDomainStateChangeAsync(domainID, domainState, callback);
}
/**
 * is called when the timinginformation (delay) changed for a connection.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus) {
    delegate_->hookTimingInformationChanged(connectionID, delay, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback) {
    return delegate_->hookTimingInformationChangedAsync(connectionID, delay, callback);
}
/**
 * this function is used to send out all data that has been changed in an early
 *  state.
(at)return E_OK on success, E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus) {
    delegate_->sendChangedData(earlyData, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback) {
    return delegate_->sendChangedDataAsync(earlyData, callback);
}
/**
 * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
 *  gatewayID is not valid.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->updateGateway(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback) {
    return delegate_->updateGatewayAsync(gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, callback);
}
/**
 * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
 *  sinkID is not valid.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->updateSink(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback) {
    return delegate_->updateSinkAsync(sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callback);
}
/**
 * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
 *  sourceID in the struct is not valid. 
Please note that only the following
 *  data out of am_Source_s have effect when they are
 *  changed:
sourceClassID,
listSoundProperties,
listConnectionFormats,
 * 
listMainSoundProperties
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->updateSource(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback) {
    return delegate_->updateSourceAsync(sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, callback);
}
/**
 * acknowledges a asyncSetSinkVolumes
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSetVolumes(handle, listvolumes, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback) {
    return delegate_->ackSetVolumesAsync(handle, listvolumes, error, callback);
}
/**
 * The acknowledge of the SinkNotificationConfiguration
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSinkNotificationConfiguration(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback) {
    return delegate_->ackSinkNotificationConfigurationAsync(handle, error, callback);
}
/**
 * The acknowledge of the SourceNotificationConfiguration
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    delegate_->ackSourceNotificationConfiguration(handle, error, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback) {
    return delegate_->ackSourceNotificationConfigurationAsync(handle, error, callback);
}
/**
 * is called whenever a notified value needs to be send
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSinkNotificationDataChange(sinkID, payload, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback) {
    return delegate_->hookSinkNotificationDataChangeAsync(sinkID, payload, callback);
}
/**
 * is called whenever a notified value needs to be send
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
    delegate_->hookSourceNotificationDataChange(sourceID, payload, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback) {
    return delegate_->hookSourceNotificationDataChangeAsync(sourceID, payload, callback);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus) {
    delegate_->confirmRoutingRundown(domainName, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback) {
    return delegate_->confirmRoutingRundownAsync(domainName, callback);
}

template <typename ... _AttributeExtensions>
std::string RoutingControlObserverProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlObserverProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool RoutingControlObserverProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool RoutingControlObserverProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& RoutingControlObserverProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& RoutingControlObserverProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace am
} // namespace genivi
} // namespace org

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyFactoryHelper<org::genivi::am::RoutingControlObserverProxy,
    _AttributeExtension> {
    typedef typename org::genivi::am::RoutingControlObserverProxy<
            org::genivi::am::RoutingControlObserverExtensions::RoutingReadyAttributeExtension<_AttributeExtension>
    > class_t;
};
}

#endif // ORG_GENIVI_AM_Routing_Control_Observer_PROXY_H_

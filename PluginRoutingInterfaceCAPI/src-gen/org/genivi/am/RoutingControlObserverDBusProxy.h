/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.5.201312121915.
* Used org.franca.core 0.8.11.201401091023.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * Routing Receive sendInterface description.
 * @author Christian Mueller
 */
#ifndef ORG_GENIVI_AM_Routing_Control_Observer_DBUS_PROXY_H_
#define ORG_GENIVI_AM_Routing_Control_Observer_DBUS_PROXY_H_

#include <org/genivi/am/RoutingControlObserverProxyBase.h>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/DBus/DBusFactory.h>
#include <CommonAPI/DBus/DBusProxy.h>
#include <CommonAPI/DBus/DBusAttribute.h>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace org {
namespace genivi {
namespace am {

class RoutingControlObserverDBusProxy: virtual public RoutingControlObserverProxyBase, virtual public CommonAPI::DBus::DBusProxy {
 public:
    RoutingControlObserverDBusProxy(
                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                    const std::string& commonApiAddress,
                    const std::string& interfaceName,
                    const std::string& busName,
                    const std::string& objectPath,
                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);

    virtual ~RoutingControlObserverDBusProxy() { }

    virtual RoutingReadyAttribute& getRoutingReadyAttribute();


    /**
     * acknowledges a asyncConnect
     */
    virtual void ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback);
    /**
     * acknowledges a asyncDisconnect
     */
    virtual void ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback);
    /**
     * acknowledges a asyncsetSinkVolume
     */
    virtual void ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback);
    /**
     * acknowledges a asyncsetSourceVolume
     */
    virtual void ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback);
    /**
     * acknowlegde for asyncSetSourceState
     */
    virtual void ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback);
    /**
     * acknowledges asyncSetSinkSoundProperties
     */
    virtual void ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback);
    /**
     * acknowledges asyncSetSinkSoundProperty
     */
    virtual void ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback);
    /**
     * acknowledges asyncSetSourceSoundProperties
     */
    virtual void ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback);
    /**
     * acknowledges asyncSetSourceSoundProperty
     */
    virtual void ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback);
    /**
     * acknowledges asyncCrossFade
     */
    virtual void ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback);
    /**
     * acknowledges a volume tick. This can be used to display volumechanges during
     *  ramps
     */
    virtual void ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback);
    /**
     * acknowledges a volume tick. This can be used to display volumechanges during
     *  ramps
     */
    virtual void ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback);
    /**
     * This function returns the ID to the given domainName. If already a domain is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the domain. The other parameters of the domain
     *  will be overwritten when the domain is registered.
    (at)return E_OK on
     *  success, E_UNKNOWN on error
     */
    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback);
    /**
     * registers a domain
    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
     *  registered E_UNKOWN on error
     */
    virtual void registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback);
    /**
     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
     *  domain will be removed as well.
    (at)return E_OK on succes, E_NON_EXISTENT if
     *  not found E_UNKOWN on error
     */
    virtual void deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback);
    /**
     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
     *  registered E_UNKOWN on error
     */
    virtual void registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback);
    /**
     * deregisters a gateway. Also removes all sinks and sources of the controlling
     *  domain.
    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
     *  error
     */
    virtual void deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback);
    /**
     * This function returns the ID to the given sinkName. If already a sink is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the sink. The other parameters of the sink will
     *  be overwritten when the sink is registered.
    (at)return E_OK on success,
     *  E_UNKNOWN on error
     */
    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback);
    /**
     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
     *  is copied to the gatewayInformation
    (at)return E_OK on succes,
     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
     */
    virtual void registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback);
    /**
     * deregisters a sink.
    (at)return E_OK on succes, E_NON_EXISTENT if not found
     *  E_UNKOWN on error
     */
    virtual void deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback);
    /**
     * This function returns the ID to the given sourceName. If already a source is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the source. The other parameters of the source
     *  will be overwritten when the source is registered.
    (at)return E_OK on
     *  success, E_UNKNOWN on error
     */
    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback);
    /**
     * registers a source.  If the source is part of a gateway, the
     *  listconnectionFormats is copied to the gatewayInformation
    (at)return E_OK on
     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
     *  already exists
     */
    virtual void registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback);
    /**
     * deregisters a source
    (at)return E_OK on succes, E_NON_EXISTENT if not found
     *  E_UNKOWN on error
     */
    virtual void deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback);
    /**
     * this function registers a crossfader.
    (at)return E_OK on succes,
     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
     */
    virtual void registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback);
    /**
     * this function deregisters a crossfader. removes all sources and sinks assiated
     *  as well.
    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
     *  error
     */
    virtual void deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback);
    /**
     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
     *  determine the SinkClassIDs of a sinkClass.
    (at)return E_OK on succes,
     *  E_DATABASE_ERROR on error
     */
    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback);
    /**
     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
     *  determine the SinkClassIDs of a sinkClass.
    (at)return E_OK on succes,
     *  E_DATABASE_ERROR on error
     */
    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback);
    /**
     * is called when a low level interrupt changes it status.
     */
    virtual void hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback);
    /**
     * This hook is called when all elements from a domain are registered.
    Is used by
     *  the Controller to know when all expected domains are finally registered
     */
    virtual void hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback);
    /**
     * is called when a sink changes its availability
     */
    virtual void hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback);
    /**
     * is called when a source changes its availability
     */
    virtual void hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback);
    /**
     * is called when a domain changes its status. This used for early domains only
     */
    virtual void hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback);
    /**
     * is called when the timinginformation (delay) changed for a connection.
     */
    virtual void hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback);
    /**
     * this function is used to send out all data that has been changed in an early
     *  state.
    (at)return E_OK on success, E_UNKNOWN on error
     */
    virtual void sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback);
    /**
     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
     *  gatewayID is not valid.
     */
    virtual void updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback);
    /**
     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
     *  sinkID is not valid.
     */
    virtual void updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback);
    /**
     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
     *  sourceID in the struct is not valid. 
    Please note that only the following
     *  data out of am_Source_s have effect when they are
     *  changed:
    sourceClassID,
    listSoundProperties,
    listConnectionFormats,
     * 
    listMainSoundProperties
     */
    virtual void updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback);
    /**
     * acknowledges a asyncSetSinkVolumes
     */
    virtual void ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback);
    /**
     * The acknowledge of the SinkNotificationConfiguration
     */
    virtual void ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback);
    /**
     * The acknowledge of the SourceNotificationConfiguration
     */
    virtual void ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback);
    /**
     * is called whenever a notified value needs to be send
     */
    virtual void hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback);
    /**
     * is called whenever a notified value needs to be send
     */
    virtual void hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback);
    virtual void confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback);


    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

 private:
   CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<RoutingReadyAttribute>> routingReady_;


};



} // namespace am
} // namespace genivi
} // namespace org

#endif // ORG_GENIVI_AM_Routing_Control_Observer_DBUS_PROXY_H_

/*
* This file was generated by the CommonAPI Generators.
*
* This file was generated by the CommonAPI Generators.
*
* This file was generated by the CommonAPI Generators.
*
* Copyright (C) 2012, BMW AG
*
* This file is part of GENIVI Project AudioManager.
*
* Contributions are licensed to the GENIVI Alliance under one or more
* Contribution License Agreements.
*
* \copyright
* This Source Code Form is subject to the terms of the
* Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
* this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
*
* \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
* \author Christian Linke christian.linke@bmw.de BMW 2013
*
* For further information see http://www.genivi.org/.
*/
#include <org/genivi/am/RoutingControlObserverStubDefault.h>

namespace org {
namespace genivi {
namespace am {

RoutingControlObserverStubDefault::RoutingControlObserverStubDefault():
        remoteEventHandler_(this) {
}

RoutingControlObserverStubRemoteEvent* RoutingControlObserverStubDefault::initStubAdapter(const std::shared_ptr<RoutingControlObserverStubAdapter>& stubAdapter) {
    stubAdapter_ = stubAdapter;
    return &remoteEventHandler_;
}

const am_RoutingReady_e& RoutingControlObserverStubDefault::getRoutingReadyAttribute() {
    return routingReadyAttributeValue_;
}

void RoutingControlObserverStubDefault::setRoutingReadyAttribute(am_RoutingReady_e value) {
    const bool valueChanged = trySetRoutingReadyAttribute(std::move(value));
    if (valueChanged)
        stubAdapter_->fireRoutingReadyAttributeChanged(routingReadyAttributeValue_);
}

void RoutingControlObserverStubDefault::onRemoteRoutingReadyAttributeChanged() {
    // No operation in default
}

bool RoutingControlObserverStubDefault::trySetRoutingReadyAttribute(am_RoutingReady_e value) {
    if (!validateRoutingReadyAttributeRequestedValue(value))
        return false;

    const bool valueChanged = (routingReadyAttributeValue_ != value);
    routingReadyAttributeValue_ = std::move(value);
    return valueChanged;
}

bool RoutingControlObserverStubDefault::validateRoutingReadyAttributeRequestedValue(const am_RoutingReady_e& value) {
    return true;
}

bool RoutingControlObserverStubDefault::RemoteEventHandler::onRemoteSetRoutingReadyAttribute(am_RoutingReady_e value) {
    return defaultStub_->trySetRoutingReadyAttribute(std::move(value));
}

void RoutingControlObserverStubDefault::RemoteEventHandler::onRemoteRoutingReadyAttributeChanged() {
    defaultStub_->onRemoteRoutingReadyAttributeChanged();
}


void RoutingControlObserverStubDefault::ackConnect(am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackDisconnect(am_Handle_s handle, am_connectionID_t connectionID, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSetSinkVolumeChange(am_Handle_s handle, am_volume_t volume, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSetSourceVolumeChange(am_Handle_s handle, am_volume_t volume, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSetSourceState(am_Handle_s handle, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSetSinkSoundProperties(am_Handle_s handle, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSetSinkSoundProperty(am_Handle_s handle, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSetSourceSoundProperties(am_Handle_s handle, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSetSourceSoundProperty(am_Handle_s handle, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackCrossFading(am_Handle_s handle, am_HotSink_e hotSink, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSourceVolumeTick(am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSinkVolumeTick(am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume) {
    // No operation in default
}

void RoutingControlObserverStubDefault::peekDomain(std::string name, am_domainID_t& domainID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::registerDomain(am_Domain_s domainData, std::string returnBusname, std::string returnInterface, am_domainID_t& domainID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::deregisterDomain(am_domainID_t domainID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::registerGateway(am_Gateway_s gatewayData, am_gatewayID_t& gatewayID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::deregisterGateway(am_gatewayID_t gatewayID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::peekSink(std::string name, am_sinkID_t& sinkID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::registerSink(am_Sink_s sinkData, am_sinkID_t& sinkID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::deregisterSink(am_sinkID_t sinkID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::peekSource(std::string name, am_sourceID_t& sourceID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::registerSource(am_Source_s sourceData, am_sourceID_t& sourceID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::deregisterSource(am_sourceID_t sourceID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::registerCrossfader(am_Crossfader_s crossfaderData, am_crossfaderID_t& crossfaderID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::deregisterCrossfader(am_crossfaderID_t crossfaderID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::peekSourceClassID(std::string name, am_sourceClass_t& sourceClassID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::peekSinkClassID(std::string name, am_sinkClass_t& sinkClassID, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::hookInterruptStatusChange(am_sourceID_t sourceID, am_InterruptState_e interruptState) {
    // No operation in default
}

void RoutingControlObserverStubDefault::hookDomainRegistrationComplete(am_domainID_t domainID) {
    // No operation in default
}

void RoutingControlObserverStubDefault::hookSinkAvailablityStatusChange(am_sinkID_t sinkID, am_Availability_s availability) {
    // No operation in default
}

void RoutingControlObserverStubDefault::hookSourceAvailablityStatusChange(am_sourceID_t sourceID, am_Availability_s availability) {
    // No operation in default
}

void RoutingControlObserverStubDefault::hookDomainStateChange(am_domainID_t domainID, am_DomainState_e domainState) {
    // No operation in default
}

void RoutingControlObserverStubDefault::hookTimingInformationChanged(am_connectionID_t connectionID, am_timeSync_t delay) {
    // No operation in default
}

void RoutingControlObserverStubDefault::sendChangedData(am_EarlyData_L earlyData) {
    // No operation in default
}

void RoutingControlObserverStubDefault::updateGateway(am_gatewayID_t gatewayID, am_ConnectionFormat_L listSourceFormats, am_ConnectionFormat_L listSinkFormats, am_Convertion_L convertionMatrix, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::updateSink(am_sinkID_t sinkID, am_sinkClass_t sinkClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::updateSource(am_sourceID_t sourceID, am_sourceClass_t sourceClassID, am_SoundProperty_L listSoundProperties, am_ConnectionFormat_L listConnectionFormats, am_MainSoundProperty_L listMainSoundProperties, am_Error_e& error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSetVolumes(am_Handle_s handle, am_Volumes_L listvolumes, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSinkNotificationConfiguration(am_Handle_s handle, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::ackSourceNotificationConfiguration(am_Handle_s handle, am_Error_e error) {
    // No operation in default
}

void RoutingControlObserverStubDefault::hookSinkNotificationDataChange(am_sinkID_t sinkID, am_NotificationPayload_s payload) {
    // No operation in default
}

void RoutingControlObserverStubDefault::hookSourceNotificationDataChange(am_sourceID_t sourceID, am_NotificationPayload_s payload) {
    // No operation in default
}

void RoutingControlObserverStubDefault::confirmRoutingRundown(std::string domainName) {
    // No operation in default
}



RoutingControlObserverStubDefault::RemoteEventHandler::RemoteEventHandler(RoutingControlObserverStubDefault* defaultStub):
        defaultStub_(defaultStub) {
}

} // namespace am
} // namespace genivi
} // namespace org

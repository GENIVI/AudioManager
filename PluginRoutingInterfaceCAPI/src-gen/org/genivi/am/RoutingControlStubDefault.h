/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.5.201312121915.
* Used org.franca.core 0.8.11.201401091023.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * This class implements everything from Audiomanager -&gt; RoutingAdapter
 * @author Christian Mueller
 */
#ifndef ORG_GENIVI_AM_Routing_Control_STUB_DEFAULT_H_
#define ORG_GENIVI_AM_Routing_Control_STUB_DEFAULT_H_


#include <org/genivi/am/RoutingControlStub.h>
#include <sstream>

namespace org {
namespace genivi {
namespace am {

/**
 * Provides a default implementation for RoutingControlStubRemoteEvent and
 * RoutingControlStub. Method callbacks have an empty implementation,
 * remote set calls on attributes will always change the value of the attribute
 * to the one received.
 *
 * Override this stub if you only want to provide a subset of the functionality
 * that would be defined for this service, and/or if you do not need any non-default
 * behaviour.
 */
class RoutingControlStubDefault : public virtual RoutingControlStub {
public:
    RoutingControlStubDefault();

    RoutingControlStubRemoteEvent* initStubAdapter(const std::shared_ptr<RoutingControlStubAdapter>& stubAdapter);

    const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> clientId);


    /**
     * aborts an asynchronous action.
    (at)return E_OK on success, E_UNKNOWN on error,
     *  E_NON_EXISTENT if handle was not found
     */
    virtual void asyncAbort(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle);
    virtual void asyncAbort(am_Handle_s handle);

    /**
     * connects a source to a sink
    (at)return E_OK on success, E_UNKNOWN on error,
     *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
     */
    virtual void asyncConnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat);
    virtual void asyncConnect(am_Handle_s handle, am_connectionID_t connectionID, am_sourceID_t sourceID, am_sinkID_t sinkID, am_CustomConnectionFormat_t connectionFormat);

    /**
     * disconnect a connection with given connectionID
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
     */
    virtual void asyncDisconnect(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_connectionID_t connectionID);
    virtual void asyncDisconnect(am_Handle_s handle, am_connectionID_t connectionID);

    /**
     * this method is used to set the volume of a sink. This function is used to drive
     *  ramps, to mute or unmute or directly set the value. The difference is made
     *  through the ramptype.
    (at)return E_OK on success, E_UNKNOWN on error,
     *  E_OUT_OF_RANGE if new volume is out of range
     */
    virtual void asyncSetSinkVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time);
    virtual void asyncSetSinkVolume(am_Handle_s handle, am_sinkID_t sinkID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time);

    /**
     * sets the volume of a source. This method is used to set the volume of a sink.
     *  This function is used to drive ramps, to mute or unmute or directly set the
     *  value. The difference is made through the ramptype.
    (at)return E_OK on
     *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
     *  range.
    triggers the acknowledge ackSourceVolumeChange
     */
    virtual void asyncSetSourceVolume(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time);
    virtual void asyncSetSourceVolume(am_Handle_s handle, am_sourceID_t sourceID, am_volume_t volume, am_CustomRampType_t ramp, am_time_t time);

    /**
     * This function is used to set the source state of a particular
     *  source.
    (at)return E_OK on success, E_UNKNOWN on error
     */
    virtual void asyncSetSourceState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SourceState_e state);
    virtual void asyncSetSourceState(am_Handle_s handle, am_sourceID_t sourceID, am_SourceState_e state);

    /**
     * this function sets the sinksoundproperty.
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
     */
    virtual void asyncSetSinkSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties);
    virtual void asyncSetSinkSoundProperties(am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_L listSoundProperties);

    /**
     * this function sets the sinksoundproperty.
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
     */
    virtual void asyncSetSinkSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty);
    virtual void asyncSetSinkSoundProperty(am_Handle_s handle, am_sinkID_t sinkID, am_SoundProperty_s soundProperty);

    /**
     * this function sets the sourcesoundproperty.
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
     */
    virtual void asyncSetSourceSoundProperties(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_L listSoundProperties);
    virtual void asyncSetSourceSoundProperties(am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_L listSoundProperties);

    /**
     * this function sets the sourcesoundproperty.
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
     */
    virtual void asyncSetSourceSoundProperty(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_s soundProperty);
    virtual void asyncSetSourceSoundProperty(am_Handle_s handle, am_sourceID_t sourceID, am_SoundProperty_s soundProperty);

    /**
     * this function triggers crossfading.
    (at)return E_OK on success, E_UNKNOWN on
     *  error
     */
    virtual void asyncCrossFade(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_crossfaderID_t crossfaderID, am_HotSink_e hotSink, am_CustomRampType_t rampType, am_time_t time);
    virtual void asyncCrossFade(am_Handle_s handle, am_crossfaderID_t crossfaderID, am_HotSink_e hotSink, am_CustomRampType_t rampType, am_time_t time);

    /**
     * this function is used for early and late audio functions to set the domain
     *  state
    (at)return E_OK on success, E_UNKNOWN on error
     */
    virtual void setDomainState(const std::shared_ptr<CommonAPI::ClientId> clientId, am_domainID_t domainID, am_DomainState_e domainState, am_Error_e& error);
    virtual void setDomainState(am_domainID_t domainID, am_DomainState_e domainState, am_Error_e& error);

    virtual void asyncSetVolumes(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_Volumes_L volumes);
    virtual void asyncSetVolumes(am_Handle_s handle, am_Volumes_L volumes);

    virtual void asyncSetSinkNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sinkID_t sinkID, am_NotificationConfiguration_s notificationConfiguration);
    virtual void asyncSetSinkNotificationConfiguration(am_Handle_s handle, am_sinkID_t sinkID, am_NotificationConfiguration_s notificationConfiguration);

    virtual void asyncSetSourceNotificationConfiguration(const std::shared_ptr<CommonAPI::ClientId> clientId, am_Handle_s handle, am_sourceID_t sourceID, am_NotificationConfiguration_s notificationConfiguration);
    virtual void asyncSetSourceNotificationConfiguration(am_Handle_s handle, am_sourceID_t sourceID, am_NotificationConfiguration_s notificationConfiguration);




protected:
private:
    class RemoteEventHandler: public RoutingControlStubRemoteEvent {
     public:
        RemoteEventHandler(RoutingControlStubDefault* defaultStub);


     private:
        RoutingControlStubDefault* defaultStub_;
    };

    RemoteEventHandler remoteEventHandler_;


    CommonAPI::Version interfaceVersion_;
};

} // namespace am
} // namespace genivi
} // namespace org

#endif // ORG_GENIVI_AM_Routing_Control_STUB_DEFAULT_H_

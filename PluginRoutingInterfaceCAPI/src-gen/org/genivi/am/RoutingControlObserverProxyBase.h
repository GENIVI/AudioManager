/*
* This file was generated by the CommonAPI Generators. 
* Used org.genivi.commonapi.core 2.1.1.201309251246.
* Used org.franca.core 0.8.9.201308271211.
*
* Copyright (c) 2012 BMW
* 
* \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
* 
* \copyright
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
* subject to the following conditions:
* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
* THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* 
* For further information see http://www.genivi.org/.
*/
/**
 * Routing Receive sendInterface description.
 * @author Christian Mueller
 */
#ifndef ORG_GENIVI_AM_Routing_Control_Observer_PROXY_BASE_H_
#define ORG_GENIVI_AM_Routing_Control_Observer_PROXY_BASE_H_

#include "RoutingControlObserver.h"


#include <org/genivi/am.h>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/InputStream.h>
#include <CommonAPI/OutputStream.h>
#include <CommonAPI/SerializableStruct.h>
#include <cstdint>
#include <string>
#include <vector>

#include <CommonAPI/Attribute.h>
#include <CommonAPI/Proxy.h>
#include <functional>
#include <future>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace am {

class RoutingControlObserverProxyBase: virtual public CommonAPI::Proxy {
 public:
    typedef CommonAPI::ObservableReadonlyAttribute<am_RoutingReady_e> RoutingReadyAttribute;

    typedef std::function<void(const CommonAPI::CallStatus&)> AckConnectAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckDisconnectAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSinkVolumeChangeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSourceVolumeChangeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSourceStateAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSinkSoundPropertiesAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSinkSoundPropertyAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSourceSoundPropertiesAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetSourceSoundPropertyAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckCrossFadingAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSourceVolumeTickAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSinkVolumeTickAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_domainID_t&, const am_Error_e&)> PeekDomainAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_domainID_t&, const am_Error_e&)> RegisterDomainAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterDomainAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_gatewayID_t&, const am_Error_e&)> RegisterGatewayAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterGatewayAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_sinkID_t&, const am_Error_e&)> PeekSinkAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_sinkID_t&, const am_Error_e&)> RegisterSinkAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterSinkAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_sourceID_t&, const am_Error_e&)> PeekSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_sourceID_t&, const am_Error_e&)> RegisterSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_crossfaderID_t&, const am_Error_e&)> RegisterCrossfaderAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> DeregisterCrossfaderAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_sourceClass_t&, const am_Error_e&)> PeekSourceClassIDAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_sinkClass_t&, const am_Error_e&)> PeekSinkClassIDAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> HookInterruptStatusChangeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> HookDomainRegistrationCompleteAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> HookSinkAvailablityStatusChangeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> HookSourceAvailablityStatusChangeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> HookDomainStateChangeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> HookTimingInformationChangedAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> SendChangedDataAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> UpdateGatewayAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> UpdateSinkAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const am_Error_e&)> UpdateSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSetVolumesAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSinkNotificationConfigurationAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AckSourceNotificationConfigurationAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> HookSinkNotificationDataChangeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> HookSourceNotificationDataChangeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> ConfirmRoutingRundownAsyncCallback;

    /**
     * This attribute signals to the clients the current routing state.
    A client
     *  should notify himself to this attribute in order to know the current state and
     *  act accordingly.
     */
    virtual RoutingReadyAttribute& getRoutingReadyAttribute() = 0;


    /**
     * acknowledges a asyncConnect
     */
    virtual void ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback) = 0;
    /**
     * acknowledges a asyncDisconnect
     */
    virtual void ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback) = 0;
    /**
     * acknowledges a asyncsetSinkVolume
     */
    virtual void ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback) = 0;
    /**
     * acknowledges a asyncsetSourceVolume
     */
    virtual void ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback) = 0;
    /**
     * acknowlegde for asyncSetSourceState
     */
    virtual void ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback) = 0;
    /**
     * acknowledges asyncSetSinkSoundProperties
     */
    virtual void ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback) = 0;
    /**
     * acknowledges asyncSetSinkSoundProperty
     */
    virtual void ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback) = 0;
    /**
     * acknowledges asyncSetSourceSoundProperties
     */
    virtual void ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback) = 0;
    /**
     * acknowledges asyncSetSourceSoundProperty
     */
    virtual void ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback) = 0;
    /**
     * acknowledges asyncCrossFade
     */
    virtual void ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback) = 0;
    /**
     * acknowledges a volume tick. This can be used to display volumechanges during
     *  ramps
     */
    virtual void ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback) = 0;
    /**
     * acknowledges a volume tick. This can be used to display volumechanges during
     *  ramps
     */
    virtual void ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback) = 0;
    /**
     * This function returns the ID to the given domainName. If already a domain is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the domain. The other parameters of the domain
     *  will be overwritten when the domain is registered.
    (at)return E_OK on
     *  success, E_UNKNOWN on error
     */
    virtual void peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) = 0;
    /**
     * registers a domain
    (at)return E_OK on succes, E_ALREADY_EXISTENT if already
     *  registered E_UNKOWN on error
     */
    virtual void registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback) = 0;
    /**
     * deregisters a domain. All sources, sinks, gateways and crossfaders from that
     *  domain will be removed as well.
    (at)return E_OK on succes, E_NON_EXISTENT if
     *  not found E_UNKOWN on error
     */
    virtual void deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback) = 0;
    /**
     * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
     *  registered E_UNKOWN on error
     */
    virtual void registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback) = 0;
    /**
     * deregisters a gateway. Also removes all sinks and sources of the controlling
     *  domain.
    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
     *  error
     */
    virtual void deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback) = 0;
    /**
     * This function returns the ID to the given sinkName. If already a sink is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the sink. The other parameters of the sink will
     *  be overwritten when the sink is registered.
    (at)return E_OK on success,
     *  E_UNKNOWN on error
     */
    virtual void peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback) = 0;
    /**
     * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
     *  is copied to the gatewayInformation
    (at)return E_OK on succes,
     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
     */
    virtual void registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback) = 0;
    /**
     * deregisters a sink.
    (at)return E_OK on succes, E_NON_EXISTENT if not found
     *  E_UNKOWN on error
     */
    virtual void deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback) = 0;
    /**
     * This function returns the ID to the given sourceName. If already a source is
     *  registered with this name, it will return the corresponding ID, if not it will
     *  reserve an ID but not register the source. The other parameters of the source
     *  will be overwritten when the source is registered.
    (at)return E_OK on
     *  success, E_UNKNOWN on error
     */
    virtual void peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) = 0;
    /**
     * registers a source.  If the source is part of a gateway, the
     *  listconnectionFormats is copied to the gatewayInformation
    (at)return E_OK on
     *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
     *  already exists
     */
    virtual void registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback) = 0;
    /**
     * deregisters a source
    (at)return E_OK on succes, E_NON_EXISTENT if not found
     *  E_UNKOWN on error
     */
    virtual void deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback) = 0;
    /**
     * this function registers a crossfader.
    (at)return E_OK on succes,
     *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
     */
    virtual void registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback) = 0;
    /**
     * this function deregisters a crossfader. removes all sources and sinks assiated
     *  as well.
    (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
     *  error
     */
    virtual void deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback) = 0;
    /**
     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
     *  determine the SinkClassIDs of a sinkClass.
    (at)return E_OK on succes,
     *  E_DATABASE_ERROR on error
     */
    virtual void peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback) = 0;
    /**
     * this function peeks a sourceclassID. It is used by the RoutingPlugins to
     *  determine the SinkClassIDs of a sinkClass.
    (at)return E_OK on succes,
     *  E_DATABASE_ERROR on error
     */
    virtual void peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback) = 0;
    /**
     * is called when a low level interrupt changes it status.
     */
    virtual void hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback) = 0;
    /**
     * This hook is called when all elements from a domain are registered.
    Is used by
     *  the Controller to know when all expected domains are finally registered
     */
    virtual void hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback) = 0;
    /**
     * is called when a sink changes its availability
     */
    virtual void hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback) = 0;
    /**
     * is called when a source changes its availability
     */
    virtual void hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback) = 0;
    /**
     * is called when a domain changes its status. This used for early domains only
     */
    virtual void hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback) = 0;
    /**
     * is called when the timinginformation (delay) changed for a connection.
     */
    virtual void hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback) = 0;
    /**
     * this function is used to send out all data that has been changed in an early
     *  state.
    (at)return E_OK on success, E_UNKNOWN on error
     */
    virtual void sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback) = 0;
    /**
     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
     *  gatewayID is not valid.
     */
    virtual void updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback) = 0;
    /**
     * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
     *  sinkID is not valid.
     */
    virtual void updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback) = 0;
    /**
     * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
     *  sourceID in the struct is not valid. 
    Please note that only the following
     *  data out of am_Source_s have effect when they are
     *  changed:
    sourceClassID,
    listSoundProperties,
    listConnectionFormats,
     * 
    listMainSoundProperties
     */
    virtual void updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) = 0;
    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback) = 0;
    /**
     * acknowledges a asyncSetSinkVolumes
     */
    virtual void ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback) = 0;
    /**
     * The acknowledge of the SinkNotificationConfiguration
     */
    virtual void ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback) = 0;
    /**
     * The acknowledge of the SourceNotificationConfiguration
     */
    virtual void ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback) = 0;
    /**
     * is called whenever a notified value needs to be send
     */
    virtual void hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback) = 0;
    /**
     * is called whenever a notified value needs to be send
     */
    virtual void hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback) = 0;
    virtual void confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus) = 0;
    virtual std::future<CommonAPI::CallStatus> confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback) = 0;
};

} // namespace am
} // namespace genivi
} // namespace org

#endif // ORG_GENIVI_AM_Routing_Control_Observer_PROXY_BASE_H_

/*
* This file was generated by the CommonAPI Generators.
*
 * Copyright (C) 2013, BMW AG
 *
 * \author Christian Linke, christian.linke@bmw.de BMW 2012,2013
*/
#ifndef ORG_GENIVI_AM_Routing_Control_PROXY_H_
#define ORG_GENIVI_AM_Routing_Control_PROXY_H_

#include "RoutingControlProxyBase.h"

#define COMMONAPI_INTERNAL_COMPILATION


#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace am {

template <typename ... _AttributeExtensions>
class RoutingControlProxy: virtual public RoutingControl, virtual public RoutingControlProxyBase, public _AttributeExtensions... {
 public:
    RoutingControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~RoutingControlProxy();




    /**
     * Calls asyncAbort with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncAbort with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback);

    /**
     * Calls asyncConnect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_ConnectionFormat_pe& connectionFormat, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncConnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_ConnectionFormat_pe& connectionFormat, AsyncConnectAsyncCallback callback);

    /**
     * Calls asyncDisconnect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncDisconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback);

    /**
     * Calls asyncSetSinkVolume with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSinkVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback);

    /**
     * Calls asyncSetSourceVolume with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSourceVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback);

    /**
     * Calls asyncSetSourceState with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSourceState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback);

    /**
     * Calls asyncSetSinkSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSinkSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback);

    /**
     * Calls asyncSetSinkSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSinkSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback);

    /**
     * Calls asyncSetSourceSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSourceSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback);

    /**
     * Calls asyncSetSourceSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSourceSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback);

    /**
     * Calls asyncCrossFade with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_RampType_pe& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncCrossFade with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_RampType_pe& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback);

    /**
     * Calls setDomainState with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setDomainState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback);

    /**
     * Calls asyncSetVolumes with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetVolumes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback);

    /**
     * Calls asyncSetSinkNotificationConfiguration with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSinkNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback);

    /**
     * Calls asyncSetSourceNotificationConfiguration with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
    /**
     * Calls asyncSetSourceNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback);

    /// Returns the CommonAPI address of the remote partner this proxy communicates with.
    virtual std::string getAddress() const;

    /// Returns the domain of the remote partner this proxy communicates with.
    virtual const std::string& getDomain() const;

    /// Returns the service ID of the remote partner this proxy communicates with.
    virtual const std::string& getServiceId() const;

    /// Returns the instance ID of the remote partner this proxy communicates with.
    virtual const std::string& getInstanceId() const;

    /// Returns true if the remote partner for this proxy is available.
    virtual bool isAvailable() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<RoutingControlProxyBase> delegate_;
};


//
// RoutingControlProxy Implementation
//
template <typename ... _AttributeExtensions>
RoutingControlProxy<_AttributeExtensions...>::RoutingControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        delegate_(std::dynamic_pointer_cast<RoutingControlProxyBase>(delegate)),
        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlProxyBase>(delegate)))... {
}

template <typename ... _AttributeExtensions>
RoutingControlProxy<_AttributeExtensions...>::~RoutingControlProxy() {
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncAbort(handle, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback) {
    return delegate_->asyncAbortAsync(handle, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_ConnectionFormat_pe& connectionFormat, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncConnect(handle, connectionID, sourceID, sinkID, connectionFormat, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_ConnectionFormat_pe& connectionFormat, AsyncConnectAsyncCallback callback) {
    return delegate_->asyncConnectAsync(handle, connectionID, sourceID, sinkID, connectionFormat, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncDisconnect(handle, connectionID, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback) {
    return delegate_->asyncDisconnectAsync(handle, connectionID, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSinkVolume(handle, sinkID, volume, ramp, time, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback) {
    return delegate_->asyncSetSinkVolumeAsync(handle, sinkID, volume, ramp, time, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSourceVolume(handle, sourceID, volume, ramp, time, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback) {
    return delegate_->asyncSetSourceVolumeAsync(handle, sourceID, volume, ramp, time, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSourceState(handle, sourceID, state, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback) {
    return delegate_->asyncSetSourceStateAsync(handle, sourceID, state, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSinkSoundProperties(handle, sinkID, listSoundProperties, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback) {
    return delegate_->asyncSetSinkSoundPropertiesAsync(handle, sinkID, listSoundProperties, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSinkSoundProperty(handle, sinkID, soundProperty, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback) {
    return delegate_->asyncSetSinkSoundPropertyAsync(handle, sinkID, soundProperty, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSourceSoundProperties(handle, sourceID, listSoundProperties, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback) {
    return delegate_->asyncSetSourceSoundPropertiesAsync(handle, sourceID, listSoundProperties, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSourceSoundProperty(handle, sourceID, soundProperty, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback) {
    return delegate_->asyncSetSourceSoundPropertyAsync(handle, sourceID, soundProperty, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_RampType_pe& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncCrossFade(handle, crossfaderID, hotSink, rampType, time, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_RampType_pe& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback) {
    return delegate_->asyncCrossFadeAsync(handle, crossfaderID, hotSink, rampType, time, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setDomainState(domainID, domainState, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback) {
    return delegate_->setDomainStateAsync(domainID, domainState, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetVolumes(handle, volumes, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback) {
    return delegate_->asyncSetVolumesAsync(handle, volumes, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSinkNotificationConfiguration(handle, sinkID, notificationConfiguration, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback) {
    return delegate_->asyncSetSinkNotificationConfigurationAsync(handle, sinkID, notificationConfiguration, callback);
}

template <typename ... _AttributeExtensions>
void RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus) {
    delegate_->asyncSetSourceNotificationConfiguration(handle, sourceID, notificationConfiguration, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlProxy<_AttributeExtensions...>::asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback) {
    return delegate_->asyncSetSourceNotificationConfigurationAsync(handle, sourceID, notificationConfiguration, callback);
}


template <typename ... _AttributeExtensions>
std::string RoutingControlProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& RoutingControlProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool RoutingControlProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& RoutingControlProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& RoutingControlProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}

} // namespace am
} // namespace genivi
} // namespace org



#endif // ORG_GENIVI_AM_Routing_Control_PROXY_H_

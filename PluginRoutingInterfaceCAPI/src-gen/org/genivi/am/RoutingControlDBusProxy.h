/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.5.201312121915.
* Used org.franca.core 0.8.11.201401091023.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * This class implements everything from Audiomanager -&gt; RoutingAdapter
 * @author Christian Mueller
 */
#ifndef ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_
#define ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_

#include <org/genivi/am/RoutingControlProxyBase.h>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/DBus/DBusFactory.h>
#include <CommonAPI/DBus/DBusProxy.h>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace org {
namespace genivi {
namespace am {

class RoutingControlDBusProxy: virtual public RoutingControlProxyBase, virtual public CommonAPI::DBus::DBusProxy {
 public:
    RoutingControlDBusProxy(
                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                    const std::string& commonApiAddress,
                    const std::string& interfaceName,
                    const std::string& busName,
                    const std::string& objectPath,
                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);

    virtual ~RoutingControlDBusProxy() { }



    /**
     * aborts an asynchronous action.
    (at)return E_OK on success, E_UNKNOWN on error,
     *  E_NON_EXISTENT if handle was not found
     */
    virtual void asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback);
    /**
     * connects a source to a sink
    (at)return E_OK on success, E_UNKNOWN on error,
     *  E_WRONG_FORMAT in case am_CustomConnectionFormat_t does not match
     */
    virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_CustomConnectionFormat_t& connectionFormat, AsyncConnectAsyncCallback callback);
    /**
     * disconnect a connection with given connectionID
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_NON_EXISTENT if connection was not found
     */
    virtual void asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback);
    /**
     * this method is used to set the volume of a sink. This function is used to drive
     *  ramps, to mute or unmute or directly set the value. The difference is made
     *  through the ramptype.
    (at)return E_OK on success, E_UNKNOWN on error,
     *  E_OUT_OF_RANGE if new volume is out of range
     */
    virtual void asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback);
    /**
     * sets the volume of a source. This method is used to set the volume of a sink.
     *  This function is used to drive ramps, to mute or unmute or directly set the
     *  value. The difference is made through the ramptype.
    (at)return E_OK on
     *  success, E_UNKNOWN on error, E_OUT_OF_RANGE if volume is out of
     *  range.
    triggers the acknowledge ackSourceVolumeChange
     */
    virtual void asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_CustomRampType_t& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback);
    /**
     * This function is used to set the source state of a particular
     *  source.
    (at)return E_OK on success, E_UNKNOWN on error
     */
    virtual void asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback);
    /**
     * this function sets the sinksoundproperty.
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
     */
    virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback);
    /**
     * this function sets the sinksoundproperty.
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
     */
    virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback);
    /**
     * this function sets the sourcesoundproperty.
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
     */
    virtual void asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback);
    /**
     * this function sets the sourcesoundproperty.
    (at)return E_OK on success,
     *  E_UNKNOWN on error, E_OUT_OF_RANGE in case the propery value is out of range
     */
    virtual void asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback);
    /**
     * this function triggers crossfading.
    (at)return E_OK on success, E_UNKNOWN on
     *  error
     */
    virtual void asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_CustomRampType_t& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback);
    /**
     * this function is used for early and late audio functions to set the domain
     *  state
    (at)return E_OK on success, E_UNKNOWN on error
     */
    virtual void setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback);
    virtual void asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback);
    virtual void asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback);
    virtual void asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback);


    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

 private:


};



} // namespace am
} // namespace genivi
} // namespace org

#endif // ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_

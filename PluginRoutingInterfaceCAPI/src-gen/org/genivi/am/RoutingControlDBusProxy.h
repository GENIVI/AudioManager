/*
* This file was generated by the CommonAPI Generators.
*
* This file was generated by the CommonAPI Generators.
*
* This file was generated by the CommonAPI Generators.
*
* Copyright (C) 2012, BMW AG
*
* This file is part of GENIVI Project AudioManager.
*
* Contributions are licensed to the GENIVI Alliance under one or more
* Contribution License Agreements.
*
* \copyright
* This Source Code Form is subject to the terms of the
* Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
* this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
*
* \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
* \author Christian Linke christian.linke@bmw.de BMW 2013
*
* For further information see http://www.genivi.org/.
*/
#ifndef ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_
#define ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_

#include <org/genivi/am/RoutingControlProxyBase.h>

#define COMMONAPI_INTERNAL_COMPILATION

#include <CommonAPI/DBus/DBusFactory.h>
#include <CommonAPI/DBus/DBusProxy.h>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace org {
namespace genivi {
namespace am {

class RoutingControlDBusProxy: virtual public RoutingControlProxyBase, virtual public CommonAPI::DBus::DBusProxy {
 public:
    RoutingControlDBusProxy(
                    const std::string& commonApiAddress,
                    const std::string& interfaceName,
                    const std::string& busName,
                    const std::string& objectPath,
                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection);

    virtual ~RoutingControlDBusProxy() { }




    virtual void asyncAbort(const am_Handle_s& handle, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncAbortAsync(const am_Handle_s& handle, AsyncAbortAsyncCallback callback);

    virtual void asyncConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_ConnectionFormat_pe& connectionFormat, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_ConnectionFormat_pe& connectionFormat, AsyncConnectAsyncCallback callback);

    virtual void asyncDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, AsyncDisconnectAsyncCallback callback);

    virtual void asyncSetSinkVolume(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkVolumeAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, AsyncSetSinkVolumeAsyncCallback callback);

    virtual void asyncSetSourceVolume(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceVolumeAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, const am_RampType_pe& ramp, const am_time_t& time, AsyncSetSourceVolumeAsyncCallback callback);

    virtual void asyncSetSourceState(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceStateAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SourceState_e& state, AsyncSetSourceStateAsyncCallback callback);

    virtual void asyncSetSinkSoundProperties(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_L& listSoundProperties, AsyncSetSinkSoundPropertiesAsyncCallback callback);

    virtual void asyncSetSinkSoundProperty(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_SoundProperty_s& soundProperty, AsyncSetSinkSoundPropertyAsyncCallback callback);

    virtual void asyncSetSourceSoundProperties(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_L& listSoundProperties, AsyncSetSourceSoundPropertiesAsyncCallback callback);

    virtual void asyncSetSourceSoundProperty(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_SoundProperty_s& soundProperty, AsyncSetSourceSoundPropertyAsyncCallback callback);

    virtual void asyncCrossFade(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_RampType_pe& rampType, const am_time_t& time, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncCrossFadeAsync(const am_Handle_s& handle, const am_crossfaderID_t& crossfaderID, const am_HotSink_e& hotSink, const am_RampType_pe& rampType, const am_time_t& time, AsyncCrossFadeAsyncCallback callback);

    virtual void setDomainState(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    virtual std::future<CommonAPI::CallStatus> setDomainStateAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, SetDomainStateAsyncCallback callback);

    virtual void asyncSetVolumes(const am_Handle_s& handle, const am_Volumes_L& volumes, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& volumes, AsyncSetVolumesAsyncCallback callback);

    virtual void asyncSetSinkNotificationConfiguration(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSinkNotificationConfigurationAsyncCallback callback);

    virtual void asyncSetSourceNotificationConfiguration(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, CommonAPI::CallStatus& callStatus);
    virtual std::future<CommonAPI::CallStatus> asyncSetSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& notificationConfiguration, AsyncSetSourceNotificationConfigurationAsyncCallback callback);
    
    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

 private:

};

} // namespace am
} // namespace genivi
} // namespace org

#endif // ORG_GENIVI_AM_Routing_Control_DBUS_PROXY_H_

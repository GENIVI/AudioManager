/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.5.201312121915.
* Used org.franca.core 0.8.11.201401091023.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include "RoutingControlObserverDBusStubAdapter.h"
#include <org/genivi/am/RoutingControlObserver.h>

namespace org {
namespace genivi {
namespace am {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createRoutingControlObserverDBusStubAdapter(
                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                   const std::string& commonApiAddress,
                   const std::string& interfaceName,
                   const std::string& busName,
                   const std::string& objectPath,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
    return std::make_shared<RoutingControlObserverDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
}

__attribute__((constructor)) void registerRoutingControlObserverDBusStubAdapter(void) {
    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(RoutingControlObserver::getInterfaceId(),
                                                               &createRoutingControlObserverDBusStubAdapter);
}



RoutingControlObserverDBusStubAdapterInternal::~RoutingControlObserverDBusStubAdapterInternal() {
    deactivateManagedInstances();
    RoutingControlObserverDBusStubAdapterHelper::deinit();
}

void RoutingControlObserverDBusStubAdapterInternal::deactivateManagedInstances() {
}

const char* RoutingControlObserverDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getRoutingReadyAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onRoutingReadyAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        /**
         * acknowledges a asyncConnect
         */
        "<method name=\"ackConnect\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges a asyncDisconnect
         */
        "<method name=\"ackDisconnect\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges a asyncsetSinkVolume
         */
        "<method name=\"ackSetSinkVolumeChange\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges a asyncsetSourceVolume
         */
        "<method name=\"ackSetSourceVolumeChange\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowlegde for asyncSetSourceState
         */
        "<method name=\"ackSetSourceState\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges asyncSetSinkSoundProperties
         */
        "<method name=\"ackSetSinkSoundProperties\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges asyncSetSinkSoundProperty
         */
        "<method name=\"ackSetSinkSoundProperty\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges asyncSetSourceSoundProperties
         */
        "<method name=\"ackSetSourceSoundProperties\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges asyncSetSourceSoundProperty
         */
        "<method name=\"ackSetSourceSoundProperty\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges asyncCrossFade
         */
        "<method name=\"ackCrossFading\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"hotSink\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges a volume tick. This can be used to display volumechanges during
         *  ramps
         */
        "<method name=\"ackSourceVolumeTick\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * acknowledges a volume tick. This can be used to display volumechanges during
         *  ramps
         */
        "<method name=\"ackSinkVolumeTick\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * This function returns the ID to the given domainName. If already a domain is
         *  registered with this name, it will return the corresponding ID, if not it will
         *  reserve an ID but not register the domain. The other parameters of the domain
         *  will be overwritten when the domain is registered.
        (at)return E_OK on
         *  success, E_UNKNOWN on error
         */
        "<method name=\"peekDomain\">\n"
            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"domainID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * registers a domain
        (at)return E_OK on succes, E_ALREADY_EXISTENT if already
         *  registered E_UNKOWN on error
         */
        "<method name=\"registerDomain\">\n"
            "<arg name=\"domainData\" type=\"(qsssbbi)\" direction=\"in\" />\n"
            "<arg name=\"returnBusname\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"returnInterface\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"domainID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * deregisters a domain. All sources, sinks, gateways and crossfaders from that
         *  domain will be removed as well.
        (at)return E_OK on succes, E_NON_EXISTENT if
         *  not found E_UNKOWN on error
         */
        "<method name=\"deregisterDomain\">\n"
            "<arg name=\"domainID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
         *  registered E_UNKOWN on error
         */
        "<method name=\"registerGateway\">\n"
            "<arg name=\"gatewayData\" type=\"(qsqqqqqaqaqab)\" direction=\"in\" />\n"
            "<arg name=\"gatewayID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * deregisters a gateway. Also removes all sinks and sources of the controlling
         *  domain.
        (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
         *  error
         */
        "<method name=\"deregisterGateway\">\n"
            "<arg name=\"gatewayID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This function returns the ID to the given sinkName. If already a sink is
         *  registered with this name, it will return the corresponding ID, if not it will
         *  reserve an ID but not register the sink. The other parameters of the sink will
         *  be overwritten when the sink is registered.
        (at)return E_OK on success,
         *  E_UNKNOWN on error
         */
        "<method name=\"peekSink\">\n"
            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
         *  is copied to the gatewayInformation
        (at)return E_OK on succes,
         *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
         */
        "<method name=\"registerSink\">\n"
            "<arg name=\"sinkData\" type=\"(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * deregisters a sink.
        (at)return E_OK on succes, E_NON_EXISTENT if not found
         *  E_UNKOWN on error
         */
        "<method name=\"deregisterSink\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This function returns the ID to the given sourceName. If already a source is
         *  registered with this name, it will return the corresponding ID, if not it will
         *  reserve an ID but not register the source. The other parameters of the source
         *  will be overwritten when the source is registered.
        (at)return E_OK on
         *  success, E_UNKNOWN on error
         */
        "<method name=\"peekSource\">\n"
            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * registers a source.  If the source is part of a gateway, the
         *  listconnectionFormats is copied to the gatewayInformation
        (at)return E_OK on
         *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
         *  already exists
         */
        "<method name=\"registerSource\">\n"
            "<arg name=\"sourceData\" type=\"(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))\" direction=\"in\" />\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * deregisters a source
        (at)return E_OK on succes, E_NON_EXISTENT if not found
         *  E_UNKOWN on error
         */
        "<method name=\"deregisterSource\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * this function registers a crossfader.
        (at)return E_OK on succes,
         *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
         */
        "<method name=\"registerCrossfader\">\n"
            "<arg name=\"crossfaderData\" type=\"(qsqqqi)\" direction=\"in\" />\n"
            "<arg name=\"crossfaderID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * this function deregisters a crossfader. removes all sources and sinks assiated
         *  as well.
        (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
         *  error
         */
        "<method name=\"deregisterCrossfader\">\n"
            "<arg name=\"crossfaderID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * this function peeks a sourceclassID. It is used by the RoutingPlugins to
         *  determine the SinkClassIDs of a sinkClass.
        (at)return E_OK on succes,
         *  E_DATABASE_ERROR on error
         */
        "<method name=\"peekSourceClassID\">\n"
            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"sourceClassID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * this function peeks a sourceclassID. It is used by the RoutingPlugins to
         *  determine the SinkClassIDs of a sinkClass.
        (at)return E_OK on succes,
         *  E_DATABASE_ERROR on error
         */
        "<method name=\"peekSinkClassID\">\n"
            "<arg name=\"name\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"sinkClassID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * is called when a low level interrupt changes it status.
         */
        "<method name=\"hookInterruptStatusChange\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"interruptState\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * This hook is called when all elements from a domain are registered.
        Is used by
         *  the Controller to know when all expected domains are finally registered
         */
        "<method name=\"hookDomainRegistrationComplete\">\n"
            "<arg name=\"domainID\" type=\"q\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * is called when a sink changes its availability
         */
        "<method name=\"hookSinkAvailablityStatusChange\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"availability\" type=\"(iq)\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * is called when a source changes its availability
         */
        "<method name=\"hookSourceAvailablityStatusChange\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"availability\" type=\"(iq)\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * is called when a domain changes its status. This used for early domains only
         */
        "<method name=\"hookDomainStateChange\">\n"
            "<arg name=\"domainID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"domainState\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * is called when the timinginformation (delay) changed for a connection.
         */
        "<method name=\"hookTimingInformationChanged\">\n"
            "<arg name=\"connectionID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"delay\" type=\"n\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * this function is used to send out all data that has been changed in an early
         *  state.
        (at)return E_OK on success, E_UNKNOWN on error
         */
        "<method name=\"sendChangedData\">\n"
            "<arg name=\"earlyData\" type=\"a(i(yv)(yv))\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
         *  gatewayID is not valid.
         */
        "<method name=\"updateGateway\">\n"
            "<arg name=\"gatewayID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listSourceFormats\" type=\"aq\" direction=\"in\" />\n"
            "<arg name=\"listSinkFormats\" type=\"aq\" direction=\"in\" />\n"
            "<arg name=\"convertionMatrix\" type=\"ab\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
         *  sinkID is not valid.
         */
        "<method name=\"updateSink\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"sinkClassID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
            "<arg name=\"listConnectionFormats\" type=\"aq\" direction=\"in\" />\n"
            "<arg name=\"listMainSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
         *  sourceID in the struct is not valid. 
        Please note that only the following
         *  data out of am_Source_s have effect when they are
         *  changed:
        sourceClassID,
        listSoundProperties,
        listConnectionFormats,
         * 
        listMainSoundProperties
         */
        "<method name=\"updateSource\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"sourceClassID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
            "<arg name=\"listConnectionFormats\" type=\"aq\" direction=\"in\" />\n"
            "<arg name=\"listMainSoundProperties\" type=\"a(qn)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * acknowledges a asyncSetSinkVolumes
         */
        "<method name=\"ackSetVolumes\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"listvolumes\" type=\"a(i(yv)nqn)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * The acknowledge of the SinkNotificationConfiguration
         */
        "<method name=\"ackSinkNotificationConfiguration\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * The acknowledge of the SourceNotificationConfiguration
         */
        "<method name=\"ackSourceNotificationConfiguration\">\n"
            "<arg name=\"handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * is called whenever a notified value needs to be send
         */
        "<method name=\"hookSinkNotificationDataChange\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"payload\" type=\"(qn)\" direction=\"in\" />\n"
        "</method>\n"
        /**
         * is called whenever a notified value needs to be send
         */
        "<method name=\"hookSourceNotificationDataChange\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"payload\" type=\"(qn)\" direction=\"in\" />\n"
        "</method>\n"
        "<method name=\"confirmRoutingRundown\">\n"
            "<arg name=\"domainName\" type=\"s\" direction=\"in\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        RoutingControlObserverStub,
        CommonAPI::Version
        > getRoutingControlObserverInterfaceVersionStubDispatcher(&RoutingControlObserverStub::getInterfaceVersion, "uu");

/**
 * This attribute signals to the clients the current routing state.
A client
 *  should notify himself to this attribute in order to know the current state and
 *  act accordingly.
 */
static CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        RoutingControlObserverStub,
        am_RoutingReady_e
        > getRoutingReadyAttributeStubDispatcher(&RoutingControlObserverStub::getRoutingReadyAttribute, "i");


/**
 * acknowledges a asyncConnect
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
    std::tuple<>
    > ackConnectStubDispatcher(&RoutingControlObserverStub::ackConnect, "");
/**
 * acknowledges a asyncDisconnect
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_connectionID_t, am_Error_e>,
    std::tuple<>
    > ackDisconnectStubDispatcher(&RoutingControlObserverStub::ackDisconnect, "");
/**
 * acknowledges a asyncsetSinkVolume
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
    std::tuple<>
    > ackSetSinkVolumeChangeStubDispatcher(&RoutingControlObserverStub::ackSetSinkVolumeChange, "");
/**
 * acknowledges a asyncsetSourceVolume
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_volume_t, am_Error_e>,
    std::tuple<>
    > ackSetSourceVolumeChangeStubDispatcher(&RoutingControlObserverStub::ackSetSourceVolumeChange, "");
/**
 * acknowlegde for asyncSetSourceState
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_Error_e>,
    std::tuple<>
    > ackSetSourceStateStubDispatcher(&RoutingControlObserverStub::ackSetSourceState, "");
/**
 * acknowledges asyncSetSinkSoundProperties
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_Error_e>,
    std::tuple<>
    > ackSetSinkSoundPropertiesStubDispatcher(&RoutingControlObserverStub::ackSetSinkSoundProperties, "");
/**
 * acknowledges asyncSetSinkSoundProperty
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_Error_e>,
    std::tuple<>
    > ackSetSinkSoundPropertyStubDispatcher(&RoutingControlObserverStub::ackSetSinkSoundProperty, "");
/**
 * acknowledges asyncSetSourceSoundProperties
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_Error_e>,
    std::tuple<>
    > ackSetSourceSoundPropertiesStubDispatcher(&RoutingControlObserverStub::ackSetSourceSoundProperties, "");
/**
 * acknowledges asyncSetSourceSoundProperty
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_Error_e>,
    std::tuple<>
    > ackSetSourceSoundPropertyStubDispatcher(&RoutingControlObserverStub::ackSetSourceSoundProperty, "");
/**
 * acknowledges asyncCrossFade
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_HotSink_e, am_Error_e>,
    std::tuple<>
    > ackCrossFadingStubDispatcher(&RoutingControlObserverStub::ackCrossFading, "");
/**
 * acknowledges a volume tick. This can be used to display volumechanges during
 *  ramps
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_sourceID_t, am_volume_t>,
    std::tuple<>
    > ackSourceVolumeTickStubDispatcher(&RoutingControlObserverStub::ackSourceVolumeTick, "");
/**
 * acknowledges a volume tick. This can be used to display volumechanges during
 *  ramps
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_sinkID_t, am_volume_t>,
    std::tuple<>
    > ackSinkVolumeTickStubDispatcher(&RoutingControlObserverStub::ackSinkVolumeTick, "");
/**
 * This function returns the ID to the given domainName. If already a domain is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the domain. The other parameters of the domain
 *  will be overwritten when the domain is registered.
(at)return E_OK on
 *  success, E_UNKNOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<std::string>,
    std::tuple<am_domainID_t, am_Error_e>
    > peekDomainStubDispatcher(&RoutingControlObserverStub::peekDomain, "qi");
/**
 * registers a domain
(at)return E_OK on succes, E_ALREADY_EXISTENT if already
 *  registered E_UNKOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Domain_s, std::string, std::string>,
    std::tuple<am_domainID_t, am_Error_e>
    > registerDomainStubDispatcher(&RoutingControlObserverStub::registerDomain, "qi");
/**
 * deregisters a domain. All sources, sinks, gateways and crossfaders from that
 *  domain will be removed as well.
(at)return E_OK on succes, E_NON_EXISTENT if
 *  not found E_UNKOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_domainID_t>,
    std::tuple<am_Error_e>
    > deregisterDomainStubDispatcher(&RoutingControlObserverStub::deregisterDomain, "i");
/**
 * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
 *  registered E_UNKOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Gateway_s>,
    std::tuple<am_gatewayID_t, am_Error_e>
    > registerGatewayStubDispatcher(&RoutingControlObserverStub::registerGateway, "qi");
/**
 * deregisters a gateway. Also removes all sinks and sources of the controlling
 *  domain.
(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
 *  error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_gatewayID_t>,
    std::tuple<am_Error_e>
    > deregisterGatewayStubDispatcher(&RoutingControlObserverStub::deregisterGateway, "i");
/**
 * This function returns the ID to the given sinkName. If already a sink is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the sink. The other parameters of the sink will
 *  be overwritten when the sink is registered.
(at)return E_OK on success,
 *  E_UNKNOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<std::string>,
    std::tuple<am_sinkID_t, am_Error_e>
    > peekSinkStubDispatcher(&RoutingControlObserverStub::peekSink, "qi");
/**
 * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
 *  is copied to the gatewayInformation
(at)return E_OK on succes,
 *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Sink_s>,
    std::tuple<am_sinkID_t, am_Error_e>
    > registerSinkStubDispatcher(&RoutingControlObserverStub::registerSink, "qi");
/**
 * deregisters a sink.
(at)return E_OK on succes, E_NON_EXISTENT if not found
 *  E_UNKOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sinkID_t>,
    std::tuple<am_Error_e>
    > deregisterSinkStubDispatcher(&RoutingControlObserverStub::deregisterSink, "i");
/**
 * This function returns the ID to the given sourceName. If already a source is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the source. The other parameters of the source
 *  will be overwritten when the source is registered.
(at)return E_OK on
 *  success, E_UNKNOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<std::string>,
    std::tuple<am_sourceID_t, am_Error_e>
    > peekSourceStubDispatcher(&RoutingControlObserverStub::peekSource, "qi");
/**
 * registers a source.  If the source is part of a gateway, the
 *  listconnectionFormats is copied to the gatewayInformation
(at)return E_OK on
 *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
 *  already exists
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Source_s>,
    std::tuple<am_sourceID_t, am_Error_e>
    > registerSourceStubDispatcher(&RoutingControlObserverStub::registerSource, "qi");
/**
 * deregisters a source
(at)return E_OK on succes, E_NON_EXISTENT if not found
 *  E_UNKOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sourceID_t>,
    std::tuple<am_Error_e>
    > deregisterSourceStubDispatcher(&RoutingControlObserverStub::deregisterSource, "i");
/**
 * this function registers a crossfader.
(at)return E_OK on succes,
 *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Crossfader_s>,
    std::tuple<am_crossfaderID_t, am_Error_e>
    > registerCrossfaderStubDispatcher(&RoutingControlObserverStub::registerCrossfader, "qi");
/**
 * this function deregisters a crossfader. removes all sources and sinks assiated
 *  as well.
(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
 *  error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_crossfaderID_t>,
    std::tuple<am_Error_e>
    > deregisterCrossfaderStubDispatcher(&RoutingControlObserverStub::deregisterCrossfader, "i");
/**
 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
 *  determine the SinkClassIDs of a sinkClass.
(at)return E_OK on succes,
 *  E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<std::string>,
    std::tuple<am_sourceClass_t, am_Error_e>
    > peekSourceClassIDStubDispatcher(&RoutingControlObserverStub::peekSourceClassID, "qi");
/**
 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
 *  determine the SinkClassIDs of a sinkClass.
(at)return E_OK on succes,
 *  E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<std::string>,
    std::tuple<am_sinkClass_t, am_Error_e>
    > peekSinkClassIDStubDispatcher(&RoutingControlObserverStub::peekSinkClassID, "qi");
/**
 * is called when a low level interrupt changes it status.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sourceID_t, am_InterruptState_e>,
    std::tuple<>
    > hookInterruptStatusChangeStubDispatcher(&RoutingControlObserverStub::hookInterruptStatusChange, "");
/**
 * This hook is called when all elements from a domain are registered.
Is used by
 *  the Controller to know when all expected domains are finally registered
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_domainID_t>,
    std::tuple<>
    > hookDomainRegistrationCompleteStubDispatcher(&RoutingControlObserverStub::hookDomainRegistrationComplete, "");
/**
 * is called when a sink changes its availability
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sinkID_t, am_Availability_s>,
    std::tuple<>
    > hookSinkAvailablityStatusChangeStubDispatcher(&RoutingControlObserverStub::hookSinkAvailablityStatusChange, "");
/**
 * is called when a source changes its availability
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sourceID_t, am_Availability_s>,
    std::tuple<>
    > hookSourceAvailablityStatusChangeStubDispatcher(&RoutingControlObserverStub::hookSourceAvailablityStatusChange, "");
/**
 * is called when a domain changes its status. This used for early domains only
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_domainID_t, am_DomainState_e>,
    std::tuple<>
    > hookDomainStateChangeStubDispatcher(&RoutingControlObserverStub::hookDomainStateChange, "");
/**
 * is called when the timinginformation (delay) changed for a connection.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_connectionID_t, am_timeSync_t>,
    std::tuple<>
    > hookTimingInformationChangedStubDispatcher(&RoutingControlObserverStub::hookTimingInformationChanged, "");
/**
 * this function is used to send out all data that has been changed in an early
 *  state.
(at)return E_OK on success, E_UNKNOWN on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_EarlyData_L>,
    std::tuple<>
    > sendChangedDataStubDispatcher(&RoutingControlObserverStub::sendChangedData, "");
/**
 * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
 *  gatewayID is not valid.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
    std::tuple<am_Error_e>
    > updateGatewayStubDispatcher(&RoutingControlObserverStub::updateGateway, "i");
/**
 * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
 *  sinkID is not valid.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
    std::tuple<am_Error_e>
    > updateSinkStubDispatcher(&RoutingControlObserverStub::updateSink, "i");
/**
 * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
 *  sourceID in the struct is not valid. 
Please note that only the following
 *  data out of am_Source_s have effect when they are
 *  changed:
sourceClassID,
listSoundProperties,
listConnectionFormats,
 * 
listMainSoundProperties
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
    std::tuple<am_Error_e>
    > updateSourceStubDispatcher(&RoutingControlObserverStub::updateSource, "i");
/**
 * acknowledges a asyncSetSinkVolumes
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_Volumes_L, am_Error_e>,
    std::tuple<>
    > ackSetVolumesStubDispatcher(&RoutingControlObserverStub::ackSetVolumes, "");
/**
 * The acknowledge of the SinkNotificationConfiguration
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_Error_e>,
    std::tuple<>
    > ackSinkNotificationConfigurationStubDispatcher(&RoutingControlObserverStub::ackSinkNotificationConfiguration, "");
/**
 * The acknowledge of the SourceNotificationConfiguration
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_Handle_s, am_Error_e>,
    std::tuple<>
    > ackSourceNotificationConfigurationStubDispatcher(&RoutingControlObserverStub::ackSourceNotificationConfiguration, "");
/**
 * is called whenever a notified value needs to be send
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sinkID_t, am_NotificationPayload_s>,
    std::tuple<>
    > hookSinkNotificationDataChangeStubDispatcher(&RoutingControlObserverStub::hookSinkNotificationDataChange, "");
/**
 * is called whenever a notified value needs to be send
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<am_sourceID_t, am_NotificationPayload_s>,
    std::tuple<>
    > hookSourceNotificationDataChangeStubDispatcher(&RoutingControlObserverStub::hookSourceNotificationDataChange, "");
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    RoutingControlObserverStub,
    std::tuple<std::string>,
    std::tuple<>
    > confirmRoutingRundownStubDispatcher(&RoutingControlObserverStub::confirmRoutingRundown, "");

/**
 * This attribute signals to the clients the current routing state.
A client
 *  should notify himself to this attribute in order to know the current state and
 *  act accordingly.
 */
void RoutingControlObserverDBusStubAdapterInternal::fireRoutingReadyAttributeChanged(const am_RoutingReady_e& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_RoutingReady_e>>
        ::sendSignal(
            *this,
            "onRoutingReadyAttributeChanged",
            "i",
            value
    );
}


const RoutingControlObserverDBusStubAdapterHelper::StubDispatcherTable& RoutingControlObserverDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}


RoutingControlObserverDBusStubAdapterInternal::RoutingControlObserverDBusStubAdapterInternal(
        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
        const std::string& commonApiAddress,
        const std::string& dbusInterfaceName,
        const std::string& dbusBusName,
        const std::string& dbusObjectPath,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
        const std::shared_ptr<CommonAPI::StubBase>& stub):
        CommonAPI::DBus::DBusStubAdapter(
                factory,
                commonApiAddress,
                dbusInterfaceName,
                dbusBusName,
                dbusObjectPath,
                dbusConnection,
                false),
        RoutingControlObserverDBusStubAdapterHelper(
            factory,
            commonApiAddress,
            dbusInterfaceName,
            dbusBusName,
            dbusObjectPath,
            dbusConnection,
            std::dynamic_pointer_cast<RoutingControlObserverStub>(stub),
            false),
        stubDispatcherTable_({
            /**
             * This attribute signals to the clients the current routing state.
            A client
             *  should notify himself to this attribute in order to know the current state and
             *  act accordingly.
             */
            { { "getRoutingReadyAttribute", "" }, &org::genivi::am::getRoutingReadyAttributeStubDispatcher }
            ,
            /**
             * acknowledges a asyncConnect
             */
            { { "ackConnect", "(iq)qi" }, &org::genivi::am::ackConnectStubDispatcher },
            /**
             * acknowledges a asyncDisconnect
             */
            { { "ackDisconnect", "(iq)qi" }, &org::genivi::am::ackDisconnectStubDispatcher },
            /**
             * acknowledges a asyncsetSinkVolume
             */
            { { "ackSetSinkVolumeChange", "(iq)ni" }, &org::genivi::am::ackSetSinkVolumeChangeStubDispatcher },
            /**
             * acknowledges a asyncsetSourceVolume
             */
            { { "ackSetSourceVolumeChange", "(iq)ni" }, &org::genivi::am::ackSetSourceVolumeChangeStubDispatcher },
            /**
             * acknowlegde for asyncSetSourceState
             */
            { { "ackSetSourceState", "(iq)i" }, &org::genivi::am::ackSetSourceStateStubDispatcher },
            /**
             * acknowledges asyncSetSinkSoundProperties
             */
            { { "ackSetSinkSoundProperties", "(iq)i" }, &org::genivi::am::ackSetSinkSoundPropertiesStubDispatcher },
            /**
             * acknowledges asyncSetSinkSoundProperty
             */
            { { "ackSetSinkSoundProperty", "(iq)i" }, &org::genivi::am::ackSetSinkSoundPropertyStubDispatcher },
            /**
             * acknowledges asyncSetSourceSoundProperties
             */
            { { "ackSetSourceSoundProperties", "(iq)i" }, &org::genivi::am::ackSetSourceSoundPropertiesStubDispatcher },
            /**
             * acknowledges asyncSetSourceSoundProperty
             */
            { { "ackSetSourceSoundProperty", "(iq)i" }, &org::genivi::am::ackSetSourceSoundPropertyStubDispatcher },
            /**
             * acknowledges asyncCrossFade
             */
            { { "ackCrossFading", "(iq)ii" }, &org::genivi::am::ackCrossFadingStubDispatcher },
            /**
             * acknowledges a volume tick. This can be used to display volumechanges during
             *  ramps
             */
            { { "ackSourceVolumeTick", "(iq)qn" }, &org::genivi::am::ackSourceVolumeTickStubDispatcher },
            /**
             * acknowledges a volume tick. This can be used to display volumechanges during
             *  ramps
             */
            { { "ackSinkVolumeTick", "(iq)qn" }, &org::genivi::am::ackSinkVolumeTickStubDispatcher },
            /**
             * This function returns the ID to the given domainName. If already a domain is
             *  registered with this name, it will return the corresponding ID, if not it will
             *  reserve an ID but not register the domain. The other parameters of the domain
             *  will be overwritten when the domain is registered.
            (at)return E_OK on
             *  success, E_UNKNOWN on error
             */
            { { "peekDomain", "s" }, &org::genivi::am::peekDomainStubDispatcher },
            /**
             * registers a domain
            (at)return E_OK on succes, E_ALREADY_EXISTENT if already
             *  registered E_UNKOWN on error
             */
            { { "registerDomain", "(qsssbbi)ss" }, &org::genivi::am::registerDomainStubDispatcher },
            /**
             * deregisters a domain. All sources, sinks, gateways and crossfaders from that
             *  domain will be removed as well.
            (at)return E_OK on succes, E_NON_EXISTENT if
             *  not found E_UNKOWN on error
             */
            { { "deregisterDomain", "q" }, &org::genivi::am::deregisterDomainStubDispatcher },
            /**
             * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
             *  registered E_UNKOWN on error
             */
            { { "registerGateway", "(qsqqqqqaqaqab)" }, &org::genivi::am::registerGatewayStubDispatcher },
            /**
             * deregisters a gateway. Also removes all sinks and sources of the controlling
             *  domain.
            (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
             *  error
             */
            { { "deregisterGateway", "q" }, &org::genivi::am::deregisterGatewayStubDispatcher },
            /**
             * This function returns the ID to the given sinkName. If already a sink is
             *  registered with this name, it will return the corresponding ID, if not it will
             *  reserve an ID but not register the sink. The other parameters of the sink will
             *  be overwritten when the sink is registered.
            (at)return E_OK on success,
             *  E_UNKNOWN on error
             */
            { { "peekSink", "s" }, &org::genivi::am::peekSinkStubDispatcher },
            /**
             * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
             *  is copied to the gatewayInformation
            (at)return E_OK on succes,
             *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
             */
            { { "registerSink", "(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))" }, &org::genivi::am::registerSinkStubDispatcher },
            /**
             * deregisters a sink.
            (at)return E_OK on succes, E_NON_EXISTENT if not found
             *  E_UNKOWN on error
             */
            { { "deregisterSink", "q" }, &org::genivi::am::deregisterSinkStubDispatcher },
            /**
             * This function returns the ID to the given sourceName. If already a source is
             *  registered with this name, it will return the corresponding ID, if not it will
             *  reserve an ID but not register the source. The other parameters of the source
             *  will be overwritten when the source is registered.
            (at)return E_OK on
             *  success, E_UNKNOWN on error
             */
            { { "peekSource", "s" }, &org::genivi::am::peekSourceStubDispatcher },
            /**
             * registers a source.  If the source is part of a gateway, the
             *  listconnectionFormats is copied to the gatewayInformation
            (at)return E_OK on
             *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
             *  already exists
             */
            { { "registerSource", "(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))" }, &org::genivi::am::registerSourceStubDispatcher },
            /**
             * deregisters a source
            (at)return E_OK on succes, E_NON_EXISTENT if not found
             *  E_UNKOWN on error
             */
            { { "deregisterSource", "q" }, &org::genivi::am::deregisterSourceStubDispatcher },
            /**
             * this function registers a crossfader.
            (at)return E_OK on succes,
             *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
             */
            { { "registerCrossfader", "(qsqqqi)" }, &org::genivi::am::registerCrossfaderStubDispatcher },
            /**
             * this function deregisters a crossfader. removes all sources and sinks assiated
             *  as well.
            (at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
             *  error
             */
            { { "deregisterCrossfader", "q" }, &org::genivi::am::deregisterCrossfaderStubDispatcher },
            /**
             * this function peeks a sourceclassID. It is used by the RoutingPlugins to
             *  determine the SinkClassIDs of a sinkClass.
            (at)return E_OK on succes,
             *  E_DATABASE_ERROR on error
             */
            { { "peekSourceClassID", "s" }, &org::genivi::am::peekSourceClassIDStubDispatcher },
            /**
             * this function peeks a sourceclassID. It is used by the RoutingPlugins to
             *  determine the SinkClassIDs of a sinkClass.
            (at)return E_OK on succes,
             *  E_DATABASE_ERROR on error
             */
            { { "peekSinkClassID", "s" }, &org::genivi::am::peekSinkClassIDStubDispatcher },
            /**
             * is called when a low level interrupt changes it status.
             */
            { { "hookInterruptStatusChange", "qi" }, &org::genivi::am::hookInterruptStatusChangeStubDispatcher },
            /**
             * This hook is called when all elements from a domain are registered.
            Is used by
             *  the Controller to know when all expected domains are finally registered
             */
            { { "hookDomainRegistrationComplete", "q" }, &org::genivi::am::hookDomainRegistrationCompleteStubDispatcher },
            /**
             * is called when a sink changes its availability
             */
            { { "hookSinkAvailablityStatusChange", "q(iq)" }, &org::genivi::am::hookSinkAvailablityStatusChangeStubDispatcher },
            /**
             * is called when a source changes its availability
             */
            { { "hookSourceAvailablityStatusChange", "q(iq)" }, &org::genivi::am::hookSourceAvailablityStatusChangeStubDispatcher },
            /**
             * is called when a domain changes its status. This used for early domains only
             */
            { { "hookDomainStateChange", "qi" }, &org::genivi::am::hookDomainStateChangeStubDispatcher },
            /**
             * is called when the timinginformation (delay) changed for a connection.
             */
            { { "hookTimingInformationChanged", "qn" }, &org::genivi::am::hookTimingInformationChangedStubDispatcher },
            /**
             * this function is used to send out all data that has been changed in an early
             *  state.
            (at)return E_OK on success, E_UNKNOWN on error
             */
            { { "sendChangedData", "a(i(yv)(yv))" }, &org::genivi::am::sendChangedDataStubDispatcher },
            /**
             * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
             *  gatewayID is not valid.
             */
            { { "updateGateway", "qaqaqab" }, &org::genivi::am::updateGatewayStubDispatcher },
            /**
             * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
             *  sinkID is not valid.
             */
            { { "updateSink", "qqa(qn)aqa(qn)" }, &org::genivi::am::updateSinkStubDispatcher },
            /**
             * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
             *  sourceID in the struct is not valid. 
            Please note that only the following
             *  data out of am_Source_s have effect when they are
             *  changed:
            sourceClassID,
            listSoundProperties,
            listConnectionFormats,
             * 
            listMainSoundProperties
             */
            { { "updateSource", "qqa(qn)aqa(qn)" }, &org::genivi::am::updateSourceStubDispatcher },
            /**
             * acknowledges a asyncSetSinkVolumes
             */
            { { "ackSetVolumes", "(iq)a(i(yv)nqn)i" }, &org::genivi::am::ackSetVolumesStubDispatcher },
            /**
             * The acknowledge of the SinkNotificationConfiguration
             */
            { { "ackSinkNotificationConfiguration", "(iq)i" }, &org::genivi::am::ackSinkNotificationConfigurationStubDispatcher },
            /**
             * The acknowledge of the SourceNotificationConfiguration
             */
            { { "ackSourceNotificationConfiguration", "(iq)i" }, &org::genivi::am::ackSourceNotificationConfigurationStubDispatcher },
            /**
             * is called whenever a notified value needs to be send
             */
            { { "hookSinkNotificationDataChange", "q(qn)" }, &org::genivi::am::hookSinkNotificationDataChangeStubDispatcher },
            /**
             * is called whenever a notified value needs to be send
             */
            { { "hookSourceNotificationDataChange", "q(qn)" }, &org::genivi::am::hookSourceNotificationDataChangeStubDispatcher },
            { { "confirmRoutingRundown", "s" }, &org::genivi::am::confirmRoutingRundownStubDispatcher }
            }) {

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::getRoutingControlObserverInterfaceVersionStubDispatcher });
}

} // namespace am
} // namespace genivi
} // namespace org

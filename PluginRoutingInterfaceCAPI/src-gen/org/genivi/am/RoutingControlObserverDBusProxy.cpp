/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.5.201312121915.
* Used org.franca.core 0.8.11.201401091023.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * Routing Receive sendInterface description.
 * @author Christian Mueller
 */
#include "RoutingControlObserverDBusProxy.h"

namespace org {
namespace genivi {
namespace am {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createRoutingControlObserverDBusProxy(
                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                    const std::string& commonApiAddress,
                    const std::string& interfaceName,
                    const std::string& busName,
                    const std::string& objectPath,
                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection) {
    return std::make_shared<RoutingControlObserverDBusProxy>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection);
}

__attribute__((constructor)) void registerRoutingControlObserverDBusProxy(void) {
    CommonAPI::DBus::DBusFactory::registerProxyFactoryMethod(RoutingControlObserver::getInterfaceId(),
       &createRoutingControlObserverDBusProxy);
}

RoutingControlObserverDBusProxy::RoutingControlObserverDBusProxy(
                    const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                    const std::string& commonApiAddress,
                    const std::string& interfaceName,
                    const std::string& busName,
                    const std::string& objectPath,
                    const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyconnection):
        CommonAPI::DBus::DBusProxy(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyconnection)
,routingReady_(*this, "onRoutingReadyAttributeChanged", "i", "getRoutingReadyAttribute")
    {
    }

RoutingControlObserverDBusProxy::RoutingReadyAttribute& RoutingControlObserverDBusProxy::getRoutingReadyAttribute() {
    return routingReady_;
}


/**
 * acknowledges a asyncConnect
 */
void RoutingControlObserverDBusProxy::ackConnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackConnect",
        "(iq)qi",
        handle, connectionID, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackConnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckConnectAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackConnect",
        "(iq)qi",
        handle, connectionID, error, 
        std::move(callback));
}
/**
 * acknowledges a asyncDisconnect
 */
void RoutingControlObserverDBusProxy::ackDisconnect(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackDisconnect",
        "(iq)qi",
        handle, connectionID, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackDisconnectAsync(const am_Handle_s& handle, const am_connectionID_t& connectionID, const am_Error_e& error, AckDisconnectAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_connectionID_t, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackDisconnect",
        "(iq)qi",
        handle, connectionID, error, 
        std::move(callback));
}
/**
 * acknowledges a asyncsetSinkVolume
 */
void RoutingControlObserverDBusProxy::ackSetSinkVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_volume_t, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSetSinkVolumeChange",
        "(iq)ni",
        handle, volume, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSinkVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSinkVolumeChangeAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_volume_t, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSetSinkVolumeChange",
        "(iq)ni",
        handle, volume, error, 
        std::move(callback));
}
/**
 * acknowledges a asyncsetSourceVolume
 */
void RoutingControlObserverDBusProxy::ackSetSourceVolumeChange(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_volume_t, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSetSourceVolumeChange",
        "(iq)ni",
        handle, volume, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSourceVolumeChangeAsync(const am_Handle_s& handle, const am_volume_t& volume, const am_Error_e& error, AckSetSourceVolumeChangeAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_volume_t, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSetSourceVolumeChange",
        "(iq)ni",
        handle, volume, error, 
        std::move(callback));
}
/**
 * acknowlegde for asyncSetSourceState
 */
void RoutingControlObserverDBusProxy::ackSetSourceState(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSetSourceState",
        "(iq)i",
        handle, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSourceStateAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceStateAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSetSourceState",
        "(iq)i",
        handle, error, 
        std::move(callback));
}
/**
 * acknowledges asyncSetSinkSoundProperties
 */
void RoutingControlObserverDBusProxy::ackSetSinkSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSetSinkSoundProperties",
        "(iq)i",
        handle, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSinkSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertiesAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSetSinkSoundProperties",
        "(iq)i",
        handle, error, 
        std::move(callback));
}
/**
 * acknowledges asyncSetSinkSoundProperty
 */
void RoutingControlObserverDBusProxy::ackSetSinkSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSetSinkSoundProperty",
        "(iq)i",
        handle, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSinkSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSinkSoundPropertyAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSetSinkSoundProperty",
        "(iq)i",
        handle, error, 
        std::move(callback));
}
/**
 * acknowledges asyncSetSourceSoundProperties
 */
void RoutingControlObserverDBusProxy::ackSetSourceSoundProperties(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSetSourceSoundProperties",
        "(iq)i",
        handle, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSourceSoundPropertiesAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertiesAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSetSourceSoundProperties",
        "(iq)i",
        handle, error, 
        std::move(callback));
}
/**
 * acknowledges asyncSetSourceSoundProperty
 */
void RoutingControlObserverDBusProxy::ackSetSourceSoundProperty(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSetSourceSoundProperty",
        "(iq)i",
        handle, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetSourceSoundPropertyAsync(const am_Handle_s& handle, const am_Error_e& error, AckSetSourceSoundPropertyAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSetSourceSoundProperty",
        "(iq)i",
        handle, error, 
        std::move(callback));
}
/**
 * acknowledges asyncCrossFade
 */
void RoutingControlObserverDBusProxy::ackCrossFading(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_HotSink_e, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackCrossFading",
        "(iq)ii",
        handle, hotSink, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackCrossFadingAsync(const am_Handle_s& handle, const am_HotSink_e& hotSink, const am_Error_e& error, AckCrossFadingAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_HotSink_e, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackCrossFading",
        "(iq)ii",
        handle, hotSink, error, 
        std::move(callback));
}
/**
 * acknowledges a volume tick. This can be used to display volumechanges during
 *  ramps
 */
void RoutingControlObserverDBusProxy::ackSourceVolumeTick(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_volume_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSourceVolumeTick",
        "(iq)qn",
        handle, sourceID, volume,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSourceVolumeTickAsync(const am_Handle_s& handle, const am_sourceID_t& sourceID, const am_volume_t& volume, AckSourceVolumeTickAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sourceID_t, am_volume_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSourceVolumeTick",
        "(iq)qn",
        handle, sourceID, volume, 
        std::move(callback));
}
/**
 * acknowledges a volume tick. This can be used to display volumechanges during
 *  ramps
 */
void RoutingControlObserverDBusProxy::ackSinkVolumeTick(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_volume_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSinkVolumeTick",
        "(iq)qn",
        handle, sinkID, volume,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSinkVolumeTickAsync(const am_Handle_s& handle, const am_sinkID_t& sinkID, const am_volume_t& volume, AckSinkVolumeTickAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_sinkID_t, am_volume_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSinkVolumeTick",
        "(iq)qn",
        handle, sinkID, volume, 
        std::move(callback));
}
/**
 * This function returns the ID to the given domainName. If already a domain is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the domain. The other parameters of the domain
 *  will be overwritten when the domain is registered.
(at)return E_OK on
 *  success, E_UNKNOWN on error
 */
void RoutingControlObserverDBusProxy::peekDomain(const std::string& name, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_Error_e> >::callMethodWithReply(
        *this,
        "peekDomain",
        "s",
        name,
        callStatus
        , domainID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekDomainAsync(const std::string& name, PeekDomainAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_Error_e> >::callMethodAsync(
        *this,
        "peekDomain",
        "s",
        name, 
        std::move(callback));
}
/**
 * registers a domain
(at)return E_OK on succes, E_ALREADY_EXISTENT if already
 *  registered E_UNKOWN on error
 */
void RoutingControlObserverDBusProxy::registerDomain(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, CommonAPI::CallStatus& callStatus, am_domainID_t& domainID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Domain_s, std::string, std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_Error_e> >::callMethodWithReply(
        *this,
        "registerDomain",
        "(qsssbbi)ss",
        domainData, returnBusname, returnInterface,
        callStatus
        , domainID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerDomainAsync(const am_Domain_s& domainData, const std::string& returnBusname, const std::string& returnInterface, RegisterDomainAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Domain_s, std::string, std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_Error_e> >::callMethodAsync(
        *this,
        "registerDomain",
        "(qsssbbi)ss",
        domainData, returnBusname, returnInterface, 
        std::move(callback));
}
/**
 * deregisters a domain. All sources, sinks, gateways and crossfaders from that
 *  domain will be removed as well.
(at)return E_OK on succes, E_NON_EXISTENT if
 *  not found E_UNKOWN on error
 */
void RoutingControlObserverDBusProxy::deregisterDomain(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
        *this,
        "deregisterDomain",
        "q",
        domainID,
        callStatus
        , error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterDomainAsync(const am_domainID_t& domainID, DeregisterDomainAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
        *this,
        "deregisterDomain",
        "q",
        domainID, 
        std::move(callback));
}
/**
 * registers a gateway. (at)return E_OK on succes, E_ALREADY_EXISTENT if already
 *  registered E_UNKOWN on error
 */
void RoutingControlObserverDBusProxy::registerGateway(const am_Gateway_s& gatewayData, CommonAPI::CallStatus& callStatus, am_gatewayID_t& gatewayID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Gateway_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t, am_Error_e> >::callMethodWithReply(
        *this,
        "registerGateway",
        "(qsqqqqqaqaqab)",
        gatewayData,
        callStatus
        , gatewayID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerGatewayAsync(const am_Gateway_s& gatewayData, RegisterGatewayAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Gateway_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t, am_Error_e> >::callMethodAsync(
        *this,
        "registerGateway",
        "(qsqqqqqaqaqab)",
        gatewayData, 
        std::move(callback));
}
/**
 * deregisters a gateway. Also removes all sinks and sources of the controlling
 *  domain.
(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
 *  error
 */
void RoutingControlObserverDBusProxy::deregisterGateway(const am_gatewayID_t& gatewayID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
        *this,
        "deregisterGateway",
        "q",
        gatewayID,
        callStatus
        , error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterGatewayAsync(const am_gatewayID_t& gatewayID, DeregisterGatewayAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
        *this,
        "deregisterGateway",
        "q",
        gatewayID, 
        std::move(callback));
}
/**
 * This function returns the ID to the given sinkName. If already a sink is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the sink. The other parameters of the sink will
 *  be overwritten when the sink is registered.
(at)return E_OK on success,
 *  E_UNKNOWN on error
 */
void RoutingControlObserverDBusProxy::peekSink(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Error_e> >::callMethodWithReply(
        *this,
        "peekSink",
        "s",
        name,
        callStatus
        , sinkID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSinkAsync(const std::string& name, PeekSinkAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Error_e> >::callMethodAsync(
        *this,
        "peekSink",
        "s",
        name, 
        std::move(callback));
}
/**
 * Registers a sink. If the sink is part of a gateway, the listconnectionFormats
 *  is copied to the gatewayInformation
(at)return E_OK on succes,
 *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
 */
void RoutingControlObserverDBusProxy::registerSink(const am_Sink_s& sinkData, CommonAPI::CallStatus& callStatus, am_sinkID_t& sinkID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Sink_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Error_e> >::callMethodWithReply(
        *this,
        "registerSink",
        "(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))",
        sinkData,
        callStatus
        , sinkID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerSinkAsync(const am_Sink_s& sinkData, RegisterSinkAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Sink_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Error_e> >::callMethodAsync(
        *this,
        "registerSink",
        "(qsqqnb(iq)ina(qn)aqa(qn)a(qin)a(qin))",
        sinkData, 
        std::move(callback));
}
/**
 * deregisters a sink.
(at)return E_OK on succes, E_NON_EXISTENT if not found
 *  E_UNKOWN on error
 */
void RoutingControlObserverDBusProxy::deregisterSink(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
        *this,
        "deregisterSink",
        "q",
        sinkID,
        callStatus
        , error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterSinkAsync(const am_sinkID_t& sinkID, DeregisterSinkAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
        *this,
        "deregisterSink",
        "q",
        sinkID, 
        std::move(callback));
}
/**
 * This function returns the ID to the given sourceName. If already a source is
 *  registered with this name, it will return the corresponding ID, if not it will
 *  reserve an ID but not register the source. The other parameters of the source
 *  will be overwritten when the source is registered.
(at)return E_OK on
 *  success, E_UNKNOWN on error
 */
void RoutingControlObserverDBusProxy::peekSource(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Error_e> >::callMethodWithReply(
        *this,
        "peekSource",
        "s",
        name,
        callStatus
        , sourceID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSourceAsync(const std::string& name, PeekSourceAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Error_e> >::callMethodAsync(
        *this,
        "peekSource",
        "s",
        name, 
        std::move(callback));
}
/**
 * registers a source.  If the source is part of a gateway, the
 *  listconnectionFormats is copied to the gatewayInformation
(at)return E_OK on
 *  success, E_UNKNOWN on error, E_ALREADY_EXIST if either name or sourceID
 *  already exists
 */
void RoutingControlObserverDBusProxy::registerSource(const am_Source_s& sourceData, CommonAPI::CallStatus& callStatus, am_sourceID_t& sourceID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Source_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Error_e> >::callMethodWithReply(
        *this,
        "registerSource",
        "(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))",
        sourceData,
        callStatus
        , sourceID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerSourceAsync(const am_Source_s& sourceData, RegisterSourceAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Source_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Error_e> >::callMethodAsync(
        *this,
        "registerSource",
        "(qqsqinb(iq)ia(qn)aqa(qn)a(qin)a(qin))",
        sourceData, 
        std::move(callback));
}
/**
 * deregisters a source
(at)return E_OK on succes, E_NON_EXISTENT if not found
 *  E_UNKOWN on error
 */
void RoutingControlObserverDBusProxy::deregisterSource(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
        *this,
        "deregisterSource",
        "q",
        sourceID,
        callStatus
        , error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterSourceAsync(const am_sourceID_t& sourceID, DeregisterSourceAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
        *this,
        "deregisterSource",
        "q",
        sourceID, 
        std::move(callback));
}
/**
 * this function registers a crossfader.
(at)return E_OK on succes,
 *  E_ALREADY_EXISTENT if already registered E_UNKOWN on error
 */
void RoutingControlObserverDBusProxy::registerCrossfader(const am_Crossfader_s& crossfaderData, CommonAPI::CallStatus& callStatus, am_crossfaderID_t& crossfaderID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Crossfader_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_crossfaderID_t, am_Error_e> >::callMethodWithReply(
        *this,
        "registerCrossfader",
        "(qsqqqi)",
        crossfaderData,
        callStatus
        , crossfaderID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerCrossfaderAsync(const am_Crossfader_s& crossfaderData, RegisterCrossfaderAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Crossfader_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_crossfaderID_t, am_Error_e> >::callMethodAsync(
        *this,
        "registerCrossfader",
        "(qsqqqi)",
        crossfaderData, 
        std::move(callback));
}
/**
 * this function deregisters a crossfader. removes all sources and sinks assiated
 *  as well.
(at)return E_OK on succes, E_NON_EXISTENT if not found E_UNKOWN on
 *  error
 */
void RoutingControlObserverDBusProxy::deregisterCrossfader(const am_crossfaderID_t& crossfaderID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_crossfaderID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
        *this,
        "deregisterCrossfader",
        "q",
        crossfaderID,
        callStatus
        , error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterCrossfaderAsync(const am_crossfaderID_t& crossfaderID, DeregisterCrossfaderAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_crossfaderID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
        *this,
        "deregisterCrossfader",
        "q",
        crossfaderID, 
        std::move(callback));
}
/**
 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
 *  determine the SinkClassIDs of a sinkClass.
(at)return E_OK on succes,
 *  E_DATABASE_ERROR on error
 */
void RoutingControlObserverDBusProxy::peekSourceClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sourceClass_t& sourceClassID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceClass_t, am_Error_e> >::callMethodWithReply(
        *this,
        "peekSourceClassID",
        "s",
        name,
        callStatus
        , sourceClassID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSourceClassIDAsync(const std::string& name, PeekSourceClassIDAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sourceClass_t, am_Error_e> >::callMethodAsync(
        *this,
        "peekSourceClassID",
        "s",
        name, 
        std::move(callback));
}
/**
 * this function peeks a sourceclassID. It is used by the RoutingPlugins to
 *  determine the SinkClassIDs of a sinkClass.
(at)return E_OK on succes,
 *  E_DATABASE_ERROR on error
 */
void RoutingControlObserverDBusProxy::peekSinkClassID(const std::string& name, CommonAPI::CallStatus& callStatus, am_sinkClass_t& sinkClassID, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkClass_t, am_Error_e> >::callMethodWithReply(
        *this,
        "peekSinkClassID",
        "s",
        name,
        callStatus
        , sinkClassID, error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSinkClassIDAsync(const std::string& name, PeekSinkClassIDAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_sinkClass_t, am_Error_e> >::callMethodAsync(
        *this,
        "peekSinkClassID",
        "s",
        name, 
        std::move(callback));
}
/**
 * is called when a low level interrupt changes it status.
 */
void RoutingControlObserverDBusProxy::hookInterruptStatusChange(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_InterruptState_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "hookInterruptStatusChange",
        "qi",
        sourceID, interruptState,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookInterruptStatusChangeAsync(const am_sourceID_t& sourceID, const am_InterruptState_e& interruptState, HookInterruptStatusChangeAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_InterruptState_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "hookInterruptStatusChange",
        "qi",
        sourceID, interruptState, 
        std::move(callback));
}
/**
 * This hook is called when all elements from a domain are registered.
Is used by
 *  the Controller to know when all expected domains are finally registered
 */
void RoutingControlObserverDBusProxy::hookDomainRegistrationComplete(const am_domainID_t& domainID, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "hookDomainRegistrationComplete",
        "q",
        domainID,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookDomainRegistrationCompleteAsync(const am_domainID_t& domainID, HookDomainRegistrationCompleteAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "hookDomainRegistrationComplete",
        "q",
        domainID, 
        std::move(callback));
}
/**
 * is called when a sink changes its availability
 */
void RoutingControlObserverDBusProxy::hookSinkAvailablityStatusChange(const am_sinkID_t& sinkID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Availability_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "hookSinkAvailablityStatusChange",
        "q(iq)",
        sinkID, availability,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSinkAvailablityStatusChangeAsync(const am_sinkID_t& sinkID, const am_Availability_s& availability, HookSinkAvailablityStatusChangeAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Availability_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "hookSinkAvailablityStatusChange",
        "q(iq)",
        sinkID, availability, 
        std::move(callback));
}
/**
 * is called when a source changes its availability
 */
void RoutingControlObserverDBusProxy::hookSourceAvailablityStatusChange(const am_sourceID_t& sourceID, const am_Availability_s& availability, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Availability_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "hookSourceAvailablityStatusChange",
        "q(iq)",
        sourceID, availability,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSourceAvailablityStatusChangeAsync(const am_sourceID_t& sourceID, const am_Availability_s& availability, HookSourceAvailablityStatusChangeAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Availability_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "hookSourceAvailablityStatusChange",
        "q(iq)",
        sourceID, availability, 
        std::move(callback));
}
/**
 * is called when a domain changes its status. This used for early domains only
 */
void RoutingControlObserverDBusProxy::hookDomainStateChange(const am_domainID_t& domainID, const am_DomainState_e& domainState, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_DomainState_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "hookDomainStateChange",
        "qi",
        domainID, domainState,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookDomainStateChangeAsync(const am_domainID_t& domainID, const am_DomainState_e& domainState, HookDomainStateChangeAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_domainID_t, am_DomainState_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "hookDomainStateChange",
        "qi",
        domainID, domainState, 
        std::move(callback));
}
/**
 * is called when the timinginformation (delay) changed for a connection.
 */
void RoutingControlObserverDBusProxy::hookTimingInformationChanged(const am_connectionID_t& connectionID, const am_timeSync_t& delay, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_connectionID_t, am_timeSync_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "hookTimingInformationChanged",
        "qn",
        connectionID, delay,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookTimingInformationChangedAsync(const am_connectionID_t& connectionID, const am_timeSync_t& delay, HookTimingInformationChangedAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_connectionID_t, am_timeSync_t>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "hookTimingInformationChanged",
        "qn",
        connectionID, delay, 
        std::move(callback));
}
/**
 * this function is used to send out all data that has been changed in an early
 *  state.
(at)return E_OK on success, E_UNKNOWN on error
 */
void RoutingControlObserverDBusProxy::sendChangedData(const am_EarlyData_L& earlyData, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_EarlyData_L>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "sendChangedData",
        "a(i(yv)(yv))",
        earlyData,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendChangedDataAsync(const am_EarlyData_L& earlyData, SendChangedDataAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_EarlyData_L>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "sendChangedData",
        "a(i(yv)(yv))",
        earlyData, 
        std::move(callback));
}
/**
 * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
 *  gatewayID is not valid.
 */
void RoutingControlObserverDBusProxy::updateGateway(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
        *this,
        "updateGateway",
        "qaqaqab",
        gatewayID, listSourceFormats, listSinkFormats, convertionMatrix,
        callStatus
        , error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateGatewayAsync(const am_gatewayID_t& gatewayID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const am_Convertion_L& convertionMatrix, UpdateGatewayAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_gatewayID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
        *this,
        "updateGateway",
        "qaqaqab",
        gatewayID, listSourceFormats, listSinkFormats, convertionMatrix, 
        std::move(callback));
}
/**
 * updates data of an gateway. (at)return E_OK on success, E_NON_EXISTENT if the
 *  sinkID is not valid.
 */
void RoutingControlObserverDBusProxy::updateSink(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
        *this,
        "updateSink",
        "qqa(qn)aqa(qn)",
        sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties,
        callStatus
        , error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateSinkAsync(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSinkAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_sinkClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
        *this,
        "updateSink",
        "qqa(qn)aqa(qn)",
        sinkID, sinkClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, 
        std::move(callback));
}
/**
 * updates data of an source. (at)return E_OK on success, E_NON_EXISTENT if the
 *  sourceID in the struct is not valid. 
Please note that only the following
 *  data out of am_Source_s have effect when they are
 *  changed:
sourceClassID,
listSoundProperties,
listConnectionFormats,
 * 
listMainSoundProperties
 */
void RoutingControlObserverDBusProxy::updateSource(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodWithReply(
        *this,
        "updateSource",
        "qqa(qn)aqa(qn)",
        sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties,
        callStatus
        , error);
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateSourceAsync(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, UpdateSourceAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_sourceClass_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L>,
                                     CommonAPI::DBus::DBusSerializableArguments<am_Error_e> >::callMethodAsync(
        *this,
        "updateSource",
        "qqa(qn)aqa(qn)",
        sourceID, sourceClassID, listSoundProperties, listConnectionFormats, listMainSoundProperties, 
        std::move(callback));
}
/**
 * acknowledges a asyncSetSinkVolumes
 */
void RoutingControlObserverDBusProxy::ackSetVolumes(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Volumes_L, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSetVolumes",
        "(iq)a(i(yv)nqn)i",
        handle, listvolumes, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSetVolumesAsync(const am_Handle_s& handle, const am_Volumes_L& listvolumes, const am_Error_e& error, AckSetVolumesAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Volumes_L, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSetVolumes",
        "(iq)a(i(yv)nqn)i",
        handle, listvolumes, error, 
        std::move(callback));
}
/**
 * The acknowledge of the SinkNotificationConfiguration
 */
void RoutingControlObserverDBusProxy::ackSinkNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSinkNotificationConfiguration",
        "(iq)i",
        handle, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSinkNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSinkNotificationConfigurationAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSinkNotificationConfiguration",
        "(iq)i",
        handle, error, 
        std::move(callback));
}
/**
 * The acknowledge of the SourceNotificationConfiguration
 */
void RoutingControlObserverDBusProxy::ackSourceNotificationConfiguration(const am_Handle_s& handle, const am_Error_e& error, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "ackSourceNotificationConfiguration",
        "(iq)i",
        handle, error,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::ackSourceNotificationConfigurationAsync(const am_Handle_s& handle, const am_Error_e& error, AckSourceNotificationConfigurationAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_Handle_s, am_Error_e>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "ackSourceNotificationConfiguration",
        "(iq)i",
        handle, error, 
        std::move(callback));
}
/**
 * is called whenever a notified value needs to be send
 */
void RoutingControlObserverDBusProxy::hookSinkNotificationDataChange(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationPayload_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "hookSinkNotificationDataChange",
        "q(qn)",
        sinkID, payload,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSinkNotificationDataChangeAsync(const am_sinkID_t& sinkID, const am_NotificationPayload_s& payload, HookSinkNotificationDataChangeAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationPayload_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "hookSinkNotificationDataChange",
        "q(qn)",
        sinkID, payload, 
        std::move(callback));
}
/**
 * is called whenever a notified value needs to be send
 */
void RoutingControlObserverDBusProxy::hookSourceNotificationDataChange(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationPayload_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "hookSourceNotificationDataChange",
        "q(qn)",
        sourceID, payload,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSourceNotificationDataChangeAsync(const am_sourceID_t& sourceID, const am_NotificationPayload_s& payload, HookSourceNotificationDataChangeAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationPayload_s>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "hookSourceNotificationDataChange",
        "q(qn)",
        sourceID, payload, 
        std::move(callback));
}
void RoutingControlObserverDBusProxy::confirmRoutingRundown(const std::string& domainName, CommonAPI::CallStatus& callStatus) {
    CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodWithReply(
        *this,
        "confirmRoutingRundown",
        "s",
        domainName,
        callStatus
        );
}
std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::confirmRoutingRundownAsync(const std::string& domainName, ConfirmRoutingRundownAsyncCallback callback) {
    return CommonAPI::DBus::DBusProxyHelper<CommonAPI::DBus::DBusSerializableArguments<std::string>,
                                     CommonAPI::DBus::DBusSerializableArguments<> >::callMethodAsync(
        *this,
        "confirmRoutingRundown",
        "s",
        domainName, 
        std::move(callback));
}



void RoutingControlObserverDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
    ownVersionMajor = 0;
    ownVersionMinor = 1;
}

} // namespace am
} // namespace genivi
} // namespace org

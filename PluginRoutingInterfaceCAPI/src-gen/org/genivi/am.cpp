/*
* This file was generated by the CommonAPI Generators.
*
 * Copyright (C) 2013, BMW AG
 *
 * \author Christian Linke, christian.linke@bmw.de BMW 2012,2013
*/
#include "am.h"


namespace org {
namespace genivi {
namespace am {

am_Route_s::am_Route_s(const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_RoutingElement_L& routeValue):
        sourceID(sourceIDValue),
        sinkID(sinkIDValue),
        route(routeValue)
{
}


bool operator==(const am_Route_s& lhs, const am_Route_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.sourceID == rhs.sourceID &&
        lhs.sinkID == rhs.sinkID &&
        lhs.route == rhs.route
    ;
}

void am_Route_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> sourceID;
    inputStream >> sinkID;
    inputStream >> route;
}

void am_Route_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << sourceID;
    outputStream << sinkID;
    outputStream << route;
}
am_Availability_s::am_Availability_s(const am_Availability_e& availabilityValue, const am_AvailabilityReason_pe& availabilityReasonValue):
        availability(availabilityValue),
        availabilityReason(availabilityReasonValue)
{
}


bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.availability == rhs.availability &&
        lhs.availabilityReason == rhs.availabilityReason
    ;
}

void am_Availability_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> availability;
    inputStream >> availabilityReason;
}

void am_Availability_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << availability;
    outputStream << availabilityReason;
}
am_ClassProperty_s::am_ClassProperty_s(const am_ClassProperty_pe& classPropertyValue, const int16_t& valueValue):
        classProperty(classPropertyValue),
        value(valueValue)
{
}


bool operator==(const am_ClassProperty_s& lhs, const am_ClassProperty_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.classProperty == rhs.classProperty &&
        lhs.value == rhs.value
    ;
}

void am_ClassProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> classProperty;
    inputStream >> value;
}

void am_ClassProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << classProperty;
    outputStream << value;
}
am_Crossfader_s::am_Crossfader_s(const am_crossfaderID_t& crossfaderIDValue, const std::string& nameValue, const am_sinkID_t& sinkID_AValue, const am_sinkID_t& sinkID_BValue, const am_sourceID_t& sourceIDValue, const am_HotSink_e& hotSinkValue):
        crossfaderID(crossfaderIDValue),
        name(nameValue),
        sinkID_A(sinkID_AValue),
        sinkID_B(sinkID_BValue),
        sourceID(sourceIDValue),
        hotSink(hotSinkValue)
{
}


bool operator==(const am_Crossfader_s& lhs, const am_Crossfader_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.crossfaderID == rhs.crossfaderID &&
        lhs.name == rhs.name &&
        lhs.sinkID_A == rhs.sinkID_A &&
        lhs.sinkID_B == rhs.sinkID_B &&
        lhs.sourceID == rhs.sourceID &&
        lhs.hotSink == rhs.hotSink
    ;
}

void am_Crossfader_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> crossfaderID;
    inputStream >> name;
    inputStream >> sinkID_A;
    inputStream >> sinkID_B;
    inputStream >> sourceID;
    inputStream >> hotSink;
}

void am_Crossfader_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << crossfaderID;
    outputStream << name;
    outputStream << sinkID_A;
    outputStream << sinkID_B;
    outputStream << sourceID;
    outputStream << hotSink;
}
am_Gateway_s::am_Gateway_s(const am_gatewayID_t& gatewayIDValue, const std::string& nameValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_domainID_t& domainSinkIDValue, const am_domainID_t& domainSourceIDValue, const am_domainID_t& controlDomainIDValue, const am_ConnectionFormat_L& listSourceFormatsValue, const am_ConnectionFormat_L& listSinkFormatsValue, const am_Convertion_L& convertionMatrixValue):
        gatewayID(gatewayIDValue),
        name(nameValue),
        sinkID(sinkIDValue),
        sourceID(sourceIDValue),
        domainSinkID(domainSinkIDValue),
        domainSourceID(domainSourceIDValue),
        controlDomainID(controlDomainIDValue),
        listSourceFormats(listSourceFormatsValue),
        listSinkFormats(listSinkFormatsValue),
        convertionMatrix(convertionMatrixValue)
{
}


bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.gatewayID == rhs.gatewayID &&
        lhs.name == rhs.name &&
        lhs.sinkID == rhs.sinkID &&
        lhs.sourceID == rhs.sourceID &&
        lhs.domainSinkID == rhs.domainSinkID &&
        lhs.domainSourceID == rhs.domainSourceID &&
        lhs.controlDomainID == rhs.controlDomainID &&
        lhs.listSourceFormats == rhs.listSourceFormats &&
        lhs.listSinkFormats == rhs.listSinkFormats &&
        lhs.convertionMatrix == rhs.convertionMatrix
    ;
}

void am_Gateway_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> gatewayID;
    inputStream >> name;
    inputStream >> sinkID;
    inputStream >> sourceID;
    inputStream >> domainSinkID;
    inputStream >> domainSourceID;
    inputStream >> controlDomainID;
    inputStream >> listSourceFormats;
    inputStream >> listSinkFormats;
    inputStream >> convertionMatrix;
}

void am_Gateway_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << gatewayID;
    outputStream << name;
    outputStream << sinkID;
    outputStream << sourceID;
    outputStream << domainSinkID;
    outputStream << domainSourceID;
    outputStream << controlDomainID;
    outputStream << listSourceFormats;
    outputStream << listSinkFormats;
    outputStream << convertionMatrix;
}
am_RoutingElement_s::am_RoutingElement_s(const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_domainID_t& domainIDValue, const am_ConnectionFormat_pe& connectionFormatValue):
        sourceID(sourceIDValue),
        sinkID(sinkIDValue),
        domainID(domainIDValue),
        connectionFormat(connectionFormatValue)
{
}


bool operator==(const am_RoutingElement_s& lhs, const am_RoutingElement_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.sourceID == rhs.sourceID &&
        lhs.sinkID == rhs.sinkID &&
        lhs.domainID == rhs.domainID &&
        lhs.connectionFormat == rhs.connectionFormat
    ;
}

void am_RoutingElement_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> sourceID;
    inputStream >> sinkID;
    inputStream >> domainID;
    inputStream >> connectionFormat;
}

void am_RoutingElement_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << sourceID;
    outputStream << sinkID;
    outputStream << domainID;
    outputStream << connectionFormat;
}
am_SoundProperty_s::am_SoundProperty_s(const am_SoundPropertyType_pe& typeValue, const int16_t& valueValue):
        type(typeValue),
        value(valueValue)
{
}


bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.type == rhs.type &&
        lhs.value == rhs.value
    ;
}

void am_SoundProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> type;
    inputStream >> value;
}

void am_SoundProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << type;
    outputStream << value;
}
am_SystemProperty_s::am_SystemProperty_s(const am_SystemPropertyType_pe& typeValue, const int16_t& valueValue):
        type(typeValue),
        value(valueValue)
{
}


bool operator==(const am_SystemProperty_s& lhs, const am_SystemProperty_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.type == rhs.type &&
        lhs.value == rhs.value
    ;
}

void am_SystemProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> type;
    inputStream >> value;
}

void am_SystemProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << type;
    outputStream << value;
}
am_SinkClass_s::am_SinkClass_s(const am_sinkClass_t& sinkClassIDValue, const std::string& nameValue, const am_ClassProperty_L& listClassPropertiesValue):
        sinkClassID(sinkClassIDValue),
        name(nameValue),
        listClassProperties(listClassPropertiesValue)
{
}


bool operator==(const am_SinkClass_s& lhs, const am_SinkClass_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.sinkClassID == rhs.sinkClassID &&
        lhs.name == rhs.name &&
        lhs.listClassProperties == rhs.listClassProperties
    ;
}

void am_SinkClass_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> sinkClassID;
    inputStream >> name;
    inputStream >> listClassProperties;
}

void am_SinkClass_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << sinkClassID;
    outputStream << name;
    outputStream << listClassProperties;
}
am_SourceClass_s::am_SourceClass_s(const am_sourceClass_t& sourceClassIDValue, const std::string& nameValue, const am_ClassProperty_L& listClassPropertiesValue):
        sourceClassID(sourceClassIDValue),
        name(nameValue),
        listClassProperties(listClassPropertiesValue)
{
}


bool operator==(const am_SourceClass_s& lhs, const am_SourceClass_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.sourceClassID == rhs.sourceClassID &&
        lhs.name == rhs.name &&
        lhs.listClassProperties == rhs.listClassProperties
    ;
}

void am_SourceClass_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> sourceClassID;
    inputStream >> name;
    inputStream >> listClassProperties;
}

void am_SourceClass_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << sourceClassID;
    outputStream << name;
    outputStream << listClassProperties;
}
am_SourceType_s::am_SourceType_s(const am_sourceID_t& sourceIDValue, const std::string& nameValue, const am_Availability_s& availabilityValue, const am_sourceClass_t& sourceClassIDValue):
        sourceID(sourceIDValue),
        name(nameValue),
        availability(availabilityValue),
        sourceClassID(sourceClassIDValue)
{
}


bool operator==(const am_SourceType_s& lhs, const am_SourceType_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.sourceID == rhs.sourceID &&
        lhs.name == rhs.name &&
        lhs.availability == rhs.availability &&
        lhs.sourceClassID == rhs.sourceClassID
    ;
}

void am_SourceType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> sourceID;
    inputStream >> name;
    inputStream >> availability;
    inputStream >> sourceClassID;
}

void am_SourceType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << sourceID;
    outputStream << name;
    outputStream << availability;
    outputStream << sourceClassID;
}
am_SinkType_s::am_SinkType_s(const am_sinkID_t& sinkIDValue, const std::string& nameValue, const am_Availability_s& availabilityValue, const am_mainVolume_t& volumeValue, const am_MuteState_e& muteStateValue, const am_sinkClass_t& sinkClassIDValue):
        sinkID(sinkIDValue),
        name(nameValue),
        availability(availabilityValue),
        volume(volumeValue),
        muteState(muteStateValue),
        sinkClassID(sinkClassIDValue)
{
}


bool operator==(const am_SinkType_s& lhs, const am_SinkType_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.sinkID == rhs.sinkID &&
        lhs.name == rhs.name &&
        lhs.availability == rhs.availability &&
        lhs.volume == rhs.volume &&
        lhs.muteState == rhs.muteState &&
        lhs.sinkClassID == rhs.sinkClassID
    ;
}

void am_SinkType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> sinkID;
    inputStream >> name;
    inputStream >> availability;
    inputStream >> volume;
    inputStream >> muteState;
    inputStream >> sinkClassID;
}

void am_SinkType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << sinkID;
    outputStream << name;
    outputStream << availability;
    outputStream << volume;
    outputStream << muteState;
    outputStream << sinkClassID;
}
am_Handle_s::am_Handle_s(const am_Handle_e& handleTypeValue, const uint16_t& handleValue):
        handleType(handleTypeValue),
        handle(handleValue)
{
}


bool operator==(const am_Handle_s& lhs, const am_Handle_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.handleType == rhs.handleType &&
        lhs.handle == rhs.handle
    ;
}

void am_Handle_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> handleType;
    inputStream >> handle;
}

void am_Handle_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << handleType;
    outputStream << handle;
}
am_MainSoundProperty_s::am_MainSoundProperty_s(const am_MainSoundPropertyType_pe& typeValue, const int16_t& valueValue):
        type(typeValue),
        value(valueValue)
{
}


bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.type == rhs.type &&
        lhs.value == rhs.value
    ;
}

void am_MainSoundProperty_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> type;
    inputStream >> value;
}

void am_MainSoundProperty_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << type;
    outputStream << value;
}
am_MainConnectionType_s::am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionIDValue, const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_timeSync_t& delayValue, const am_ConnectionState_e& connectionStateValue):
        mainConnectionID(mainConnectionIDValue),
        sourceID(sourceIDValue),
        sinkID(sinkIDValue),
        delay(delayValue),
        connectionState(connectionStateValue)
{
}


bool operator==(const am_MainConnectionType_s& lhs, const am_MainConnectionType_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.mainConnectionID == rhs.mainConnectionID &&
        lhs.sourceID == rhs.sourceID &&
        lhs.sinkID == rhs.sinkID &&
        lhs.delay == rhs.delay &&
        lhs.connectionState == rhs.connectionState
    ;
}

void am_MainConnectionType_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> mainConnectionID;
    inputStream >> sourceID;
    inputStream >> sinkID;
    inputStream >> delay;
    inputStream >> connectionState;
}

void am_MainConnectionType_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << mainConnectionID;
    outputStream << sourceID;
    outputStream << sinkID;
    outputStream << delay;
    outputStream << connectionState;
}
am_MainConnection_s::am_MainConnection_s(const am_mainConnectionID_t& mainConnectionIDValue, const am_ConnectionState_e& connectionStateValue, const am_sinkID_t& sinkIDValue, const am_sourceID_t& sourceIDValue, const am_timeSync_t& delayValue, const am_ConnectionID_L& listConnectionIDValue):
        mainConnectionID(mainConnectionIDValue),
        connectionState(connectionStateValue),
        sinkID(sinkIDValue),
        sourceID(sourceIDValue),
        delay(delayValue),
        listConnectionID(listConnectionIDValue)
{
}


bool operator==(const am_MainConnection_s& lhs, const am_MainConnection_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.mainConnectionID == rhs.mainConnectionID &&
        lhs.connectionState == rhs.connectionState &&
        lhs.sinkID == rhs.sinkID &&
        lhs.sourceID == rhs.sourceID &&
        lhs.delay == rhs.delay &&
        lhs.listConnectionID == rhs.listConnectionID
    ;
}

void am_MainConnection_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> mainConnectionID;
    inputStream >> connectionState;
    inputStream >> sinkID;
    inputStream >> sourceID;
    inputStream >> delay;
    inputStream >> listConnectionID;
}

void am_MainConnection_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << mainConnectionID;
    outputStream << connectionState;
    outputStream << sinkID;
    outputStream << sourceID;
    outputStream << delay;
    outputStream << listConnectionID;
}
am_NotificationPayload_s::am_NotificationPayload_s(const am_NotificationType_pe& typeValue, const int16_t& valueValue):
        type(typeValue),
        value(valueValue)
{
}


bool operator==(const am_NotificationPayload_s& lhs, const am_NotificationPayload_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.type == rhs.type &&
        lhs.value == rhs.value
    ;
}

void am_NotificationPayload_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> type;
    inputStream >> value;
}

void am_NotificationPayload_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << type;
    outputStream << value;
}
am_NotificationConfiguration_s::am_NotificationConfiguration_s(const am_NotificationType_pe& typeValue, const am_NotificationStatus_e& statusValue, const int16_t& parameterValue):
        type(typeValue),
        status(statusValue),
        parameter(parameterValue)
{
}


bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.type == rhs.type &&
        lhs.status == rhs.status &&
        lhs.parameter == rhs.parameter
    ;
}

void am_NotificationConfiguration_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> type;
    inputStream >> status;
    inputStream >> parameter;
}

void am_NotificationConfiguration_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << type;
    outputStream << status;
    outputStream << parameter;
}
am_Sink_s::am_Sink_s(const am_sinkID_t& sinkIDValue, const std::string& nameValue, const am_domainID_t& domainIDValue, const am_sinkClass_t& sinkClassIDValue, const am_volume_t& volumeValue, const bool& visibleValue, const am_Availability_s& availableValue, const am_MuteState_e& muteStateValue, const am_mainVolume_t& mainVolumeValue, const am_SoundProperty_L& listSoundPropertiesValue, const am_ConnectionFormat_L& listConnectionFormatsValue, const am_MainSoundProperty_L& listMainSoundPropertiesValue, const am_NotificationConfiguration_L& listMainNotificationConfigurationsValue, const am_NotificationConfiguration_L& listNotificationConfigurationsValue):
        sinkID(sinkIDValue),
        name(nameValue),
        domainID(domainIDValue),
        sinkClassID(sinkClassIDValue),
        volume(volumeValue),
        visible(visibleValue),
        available(availableValue),
        muteState(muteStateValue),
        mainVolume(mainVolumeValue),
        listSoundProperties(listSoundPropertiesValue),
        listConnectionFormats(listConnectionFormatsValue),
        listMainSoundProperties(listMainSoundPropertiesValue),
        listMainNotificationConfigurations(listMainNotificationConfigurationsValue),
        listNotificationConfigurations(listNotificationConfigurationsValue)
{
}


bool operator==(const am_Sink_s& lhs, const am_Sink_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.sinkID == rhs.sinkID &&
        lhs.name == rhs.name &&
        lhs.domainID == rhs.domainID &&
        lhs.sinkClassID == rhs.sinkClassID &&
        lhs.volume == rhs.volume &&
        lhs.visible == rhs.visible &&
        lhs.available == rhs.available &&
        lhs.muteState == rhs.muteState &&
        lhs.mainVolume == rhs.mainVolume &&
        lhs.listSoundProperties == rhs.listSoundProperties &&
        lhs.listConnectionFormats == rhs.listConnectionFormats &&
        lhs.listMainSoundProperties == rhs.listMainSoundProperties &&
        lhs.listMainNotificationConfigurations == rhs.listMainNotificationConfigurations &&
        lhs.listNotificationConfigurations == rhs.listNotificationConfigurations
    ;
}

void am_Sink_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> sinkID;
    inputStream >> name;
    inputStream >> domainID;
    inputStream >> sinkClassID;
    inputStream >> volume;
    inputStream >> visible;
    inputStream >> available;
    inputStream >> muteState;
    inputStream >> mainVolume;
    inputStream >> listSoundProperties;
    inputStream >> listConnectionFormats;
    inputStream >> listMainSoundProperties;
    inputStream >> listMainNotificationConfigurations;
    inputStream >> listNotificationConfigurations;
}

void am_Sink_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << sinkID;
    outputStream << name;
    outputStream << domainID;
    outputStream << sinkClassID;
    outputStream << volume;
    outputStream << visible;
    outputStream << available;
    outputStream << muteState;
    outputStream << mainVolume;
    outputStream << listSoundProperties;
    outputStream << listConnectionFormats;
    outputStream << listMainSoundProperties;
    outputStream << listMainNotificationConfigurations;
    outputStream << listNotificationConfigurations;
}
am_Source_s::am_Source_s(const am_sourceID_t& sourceIDValue, const am_domainID_t& domainIDValue, const std::string& nameValue, const am_sourceClass_t& sourceClassIDValue, const am_SourceState_e& sourceStateValue, const am_volume_t& volumeValue, const bool& visibleValue, const am_Availability_s& availableValue, const am_InterruptState_e& interruptStateValue, const am_SoundProperty_L& listSoundPropertiesValue, const am_ConnectionFormat_L& listConnectionFormatsValue, const am_MainSoundProperty_L& listMainSoundPropertiesValue, const am_NotificationConfiguration_L& listMainNotificationConfigurationsValue, const am_NotificationConfiguration_L& listNotificationConfigurationsValue):
        sourceID(sourceIDValue),
        domainID(domainIDValue),
        name(nameValue),
        sourceClassID(sourceClassIDValue),
        sourceState(sourceStateValue),
        volume(volumeValue),
        visible(visibleValue),
        available(availableValue),
        interruptState(interruptStateValue),
        listSoundProperties(listSoundPropertiesValue),
        listConnectionFormats(listConnectionFormatsValue),
        listMainSoundProperties(listMainSoundPropertiesValue),
        listMainNotificationConfigurations(listMainNotificationConfigurationsValue),
        listNotificationConfigurations(listNotificationConfigurationsValue)
{
}


bool operator==(const am_Source_s& lhs, const am_Source_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.sourceID == rhs.sourceID &&
        lhs.domainID == rhs.domainID &&
        lhs.name == rhs.name &&
        lhs.sourceClassID == rhs.sourceClassID &&
        lhs.sourceState == rhs.sourceState &&
        lhs.volume == rhs.volume &&
        lhs.visible == rhs.visible &&
        lhs.available == rhs.available &&
        lhs.interruptState == rhs.interruptState &&
        lhs.listSoundProperties == rhs.listSoundProperties &&
        lhs.listConnectionFormats == rhs.listConnectionFormats &&
        lhs.listMainSoundProperties == rhs.listMainSoundProperties &&
        lhs.listMainNotificationConfigurations == rhs.listMainNotificationConfigurations &&
        lhs.listNotificationConfigurations == rhs.listNotificationConfigurations
    ;
}

void am_Source_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> sourceID;
    inputStream >> domainID;
    inputStream >> name;
    inputStream >> sourceClassID;
    inputStream >> sourceState;
    inputStream >> volume;
    inputStream >> visible;
    inputStream >> available;
    inputStream >> interruptState;
    inputStream >> listSoundProperties;
    inputStream >> listConnectionFormats;
    inputStream >> listMainSoundProperties;
    inputStream >> listMainNotificationConfigurations;
    inputStream >> listNotificationConfigurations;
}

void am_Source_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << sourceID;
    outputStream << domainID;
    outputStream << name;
    outputStream << sourceClassID;
    outputStream << sourceState;
    outputStream << volume;
    outputStream << visible;
    outputStream << available;
    outputStream << interruptState;
    outputStream << listSoundProperties;
    outputStream << listConnectionFormats;
    outputStream << listMainSoundProperties;
    outputStream << listMainNotificationConfigurations;
    outputStream << listNotificationConfigurations;
}
am_Domain_s::am_Domain_s(const am_domainID_t& domainIDValue, const std::string& nameValue, const std::string& busnameValue, const std::string& nodenameValue, const bool& earlyValue, const bool& completeValue, const am_DomainState_e& stateValue):
        domainID(domainIDValue),
        name(nameValue),
        busname(busnameValue),
        nodename(nodenameValue),
        early(earlyValue),
        complete(completeValue),
        state(stateValue)
{
}


bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.domainID == rhs.domainID &&
        lhs.name == rhs.name &&
        lhs.busname == rhs.busname &&
        lhs.nodename == rhs.nodename &&
        lhs.early == rhs.early &&
        lhs.complete == rhs.complete &&
        lhs.state == rhs.state
    ;
}

void am_Domain_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> domainID;
    inputStream >> name;
    inputStream >> busname;
    inputStream >> nodename;
    inputStream >> early;
    inputStream >> complete;
    inputStream >> state;
}

void am_Domain_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << domainID;
    outputStream << name;
    outputStream << busname;
    outputStream << nodename;
    outputStream << early;
    outputStream << complete;
    outputStream << state;
}
am_EarlyData_s::am_EarlyData_s(const am_EarlyDataType_e& typeValue, const am_DataType_u& sinksourceValue, const am_EarlyData_u& dataValue):
        type(typeValue),
        sinksource(sinksourceValue),
        data(dataValue)
{
}


bool operator==(const am_EarlyData_s& lhs, const am_EarlyData_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.type == rhs.type &&
        lhs.sinksource == rhs.sinksource &&
        lhs.data == rhs.data
    ;
}

void am_EarlyData_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> type;
    inputStream >> sinksource;
    inputStream >> data;
}

void am_EarlyData_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << type;
    outputStream << sinksource;
    outputStream << data;
}
am_Connection_s::am_Connection_s(const am_connectionID_t& connectionIDValue, const am_sourceID_t& sourceIDValue, const am_sinkID_t& sinkIDValue, const am_timeSync_t& delayValue, const am_ConnectionFormat_pe& connectionFormatValue):
        connectionID(connectionIDValue),
        sourceID(sourceIDValue),
        sinkID(sinkIDValue),
        delay(delayValue),
        connectionFormat(connectionFormatValue)
{
}


bool operator==(const am_Connection_s& lhs, const am_Connection_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.connectionID == rhs.connectionID &&
        lhs.sourceID == rhs.sourceID &&
        lhs.sinkID == rhs.sinkID &&
        lhs.delay == rhs.delay &&
        lhs.connectionFormat == rhs.connectionFormat
    ;
}

void am_Connection_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> connectionID;
    inputStream >> sourceID;
    inputStream >> sinkID;
    inputStream >> delay;
    inputStream >> connectionFormat;
}

void am_Connection_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << connectionID;
    outputStream << sourceID;
    outputStream << sinkID;
    outputStream << delay;
    outputStream << connectionFormat;
}
am_Volumes_s::am_Volumes_s(const am_VolumeType_e& volumeTypeValue, const am_DataType_u& volumeIDValue, const am_volume_t& volumeValue, const am_RampType_pe& rampValue, const am_time_t& timeValue):
        volumeType(volumeTypeValue),
        volumeID(volumeIDValue),
        volume(volumeValue),
        ramp(rampValue),
        time(timeValue)
{
}


bool operator==(const am_Volumes_s& lhs, const am_Volumes_s& rhs) {
    if (&lhs == &rhs)
        return true;

    return
        lhs.volumeType == rhs.volumeType &&
        lhs.volumeID == rhs.volumeID &&
        lhs.volume == rhs.volume &&
        lhs.ramp == rhs.ramp &&
        lhs.time == rhs.time
    ;
}

void am_Volumes_s::readFromInputStream(CommonAPI::InputStream& inputStream) {
    inputStream >> volumeType;
    inputStream >> volumeID;
    inputStream >> volume;
    inputStream >> ramp;
    inputStream >> time;
}

void am_Volumes_s::writeToOutputStream(CommonAPI::OutputStream& outputStream) const {
    outputStream << volumeType;
    outputStream << volumeID;
    outputStream << volume;
    outputStream << ramp;
    outputStream << time;
}

} // namespace am
} // namespace genivi
} // namespace org

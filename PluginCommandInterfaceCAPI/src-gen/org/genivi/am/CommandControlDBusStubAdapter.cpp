/*
* This file was generated by the CommonAPI Generators. 
* Used org.genivi.commonapi.core 2.1.2.201309301424.
* Used org.franca.core 0.8.9.201308271211.
*
*  Copyright (c) 2012 BMW
*  
*   \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
*  
*   \copyright
*   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
*   including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
*   subject to the following conditions:
*   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
*   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
*   THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*    For further information see http://www.genivi.org/.
*  
*/
#include "CommandControlDBusStubAdapter.h"
#include <org/genivi/am/CommandControl.h>

namespace org {
namespace genivi {
namespace am {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createCommandControlDBusStubAdapter(
                   const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
                   const std::string& commonApiAddress,
                   const std::string& interfaceName,
                   const std::string& busName,
                   const std::string& objectPath,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusProxyConnection,
                   const std::shared_ptr<CommonAPI::StubBase>& stubBase) {
    return std::make_shared<CommandControlDBusStubAdapter>(factory, commonApiAddress, interfaceName, busName, objectPath, dbusProxyConnection, stubBase);
}

__attribute__((constructor)) void registerCommandControlDBusStubAdapter(void) {
    CommonAPI::DBus::DBusFactory::registerAdapterFactoryMethod(CommandControl::getInterfaceId(),
                                                               &createCommandControlDBusStubAdapter);
}

CommandControlDBusStubAdapter::CommandControlDBusStubAdapter(
        const std::shared_ptr<CommonAPI::DBus::DBusFactory>& factory,
        const std::string& commonApiAddress,
        const std::string& dbusInterfaceName,
        const std::string& dbusBusName,
        const std::string& dbusObjectPath,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection>& dbusConnection,
        const std::shared_ptr<CommonAPI::StubBase>& stub):
        CommandControlDBusStubAdapterHelper(factory, commonApiAddress, dbusInterfaceName, dbusBusName, dbusObjectPath, 
            dbusConnection, std::dynamic_pointer_cast<CommandControlStub>(stub),
            NULL)
            {
}

CommandControlDBusStubAdapter::~CommandControlDBusStubAdapter() {
    deactivateManagedInstances();
    deinit();
    stub_.reset();
}

void CommandControlDBusStubAdapter::deactivateManagedInstances() {
}

const char* CommandControlDBusStubAdapter::getMethodsDBusIntrospectionXmlData() const {
    static const char* introspectionData =
        /**
         * Callback that is called when the number of connections change
         */
        "<signal name=\"newMainConnection\">\n"
            "<arg name=\"mainConnection\" type=\"(qqqni)\" />\n"
        "</signal>\n"
        /**
         * Callback that is called when the number of connections change
         */
        "<signal name=\"removedMainConnection\">\n"
            "<arg name=\"mainConnection\" type=\"q\" />\n"
        "</signal>\n"
        /**
         * Callback that is called when the number of sinks change
         */
        "<signal name=\"newSink\">\n"
            "<arg name=\"sink\" type=\"(qs(iq)niq)\" />\n"
        "</signal>\n"
        /**
         * Callback that is called when the number of sinks change
         */
        "<signal name=\"removedSink\">\n"
            "<arg name=\"sinkID\" type=\"q\" />\n"
        "</signal>\n"
        /**
         * Callback that is called when the number of sources change
         */
        "<signal name=\"newSource\">\n"
            "<arg name=\"source\" type=\"(qs(iq)q)\" />\n"
        "</signal>\n"
        /**
         * Callback that is called when the number of sources change
         */
        "<signal name=\"removedSource\">\n"
            "<arg name=\"source\" type=\"q\" />\n"
        "</signal>\n"
        /**
         * this callback is fired if the number of sink classes changed
         */
        "<signal name=\"numberOfSinkClassesChanged\">\n"
        "</signal>\n"
        /**
         * this callback is fired if the number of source classes changed
         */
        "<signal name=\"numberOfSourceClassesChanged\">\n"
        "</signal>\n"
        /**
         * This callback is called when the ConnectionState of a connection changed.
         */
        "<signal name=\"mainConnectionStateChanged\">\n"
            "<arg name=\"connectionID\" type=\"q\" />\n"
            "<arg name=\"connectionState\" type=\"i\" />\n"
        "</signal>\n"
        /**
         * this callback indicates that a sinkSoundProperty has changed.
         */
        "<signal name=\"mainSinkSoundPropertyChanged\">\n"
            "<arg name=\"sinkID\" type=\"q\" />\n"
            "<arg name=\"soundProperty\" type=\"(qn)\" />\n"
        "</signal>\n"
        /**
         * this callback indicates that a sourceSoundProperty has changed.
         */
        "<signal name=\"mainSourceSoundPropertyChanged\">\n"
            "<arg name=\"sourceID\" type=\"q\" />\n"
            "<arg name=\"soundProperty\" type=\"(qn)\" />\n"
        "</signal>\n"
        /**
         * this callback is called when the availability of a sink has changed
         */
        "<signal name=\"sinkAvailabilityChanged\">\n"
            "<arg name=\"sinkID\" type=\"q\" />\n"
            "<arg name=\"availability\" type=\"(iq)\" />\n"
        "</signal>\n"
        /**
         * this callback is called when the availability of source has changed.
         */
        "<signal name=\"sourceAvailabilityChanged\">\n"
            "<arg name=\"sourceID\" type=\"q\" />\n"
            "<arg name=\"availability\" type=\"(iq)\" />\n"
        "</signal>\n"
        /**
         * this callback indicates a volume change on the indicated sink
         */
        "<signal name=\"volumeChanged\">\n"
            "<arg name=\"sinkID\" type=\"q\" />\n"
            "<arg name=\"volume\" type=\"n\" />\n"
        "</signal>\n"
        /**
         * this callback indicates a mute state change on a sink.
         */
        "<signal name=\"sinkMuteStateChanged\">\n"
            "<arg name=\"sinkID\" type=\"q\" />\n"
            "<arg name=\"muteState\" type=\"i\" />\n"
        "</signal>\n"
        /**
         * is fired if a systemProperty changed
         */
        "<signal name=\"systemPropertyChanged\">\n"
            "<arg name=\"systemProperty\" type=\"(qn)\" />\n"
        "</signal>\n"
        /**
         * This callback is fired if the timinginformation for a mainConnectionID changed
         */
        "<signal name=\"timingInformationChanged\">\n"
            "<arg name=\"mainConnectionID\" type=\"q\" />\n"
            "<arg name=\"time\" type=\"n\" />\n"
        "</signal>\n"
        /**
         * This callback is called when a sink is updated.
         */
        "<signal name=\"sinkUpdated\">\n"
            "<arg name=\"sinkID\" type=\"q\" />\n"
            "<arg name=\"sinkClassID\" type=\"q\" />\n"
            "<arg name=\"listMainSoundProperties\" type=\"a(qn)\" />\n"
        "</signal>\n"
        /**
         * This callback is called when a source is updated.
         */
        "<signal name=\"sourceUpdated\">\n"
            "<arg name=\"sourceID\" type=\"q\" />\n"
            "<arg name=\"sourceClassID\" type=\"q\" />\n"
            "<arg name=\"listMainSoundProperties\" type=\"a(qn)\" />\n"
        "</signal>\n"
        /**
         * This callback is called when a notificated value of a sink changes.
         */
        "<signal name=\"sinkNotification\">\n"
            "<arg name=\"sinkID\" type=\"q\" />\n"
            "<arg name=\"notification\" type=\"(qn)\" />\n"
        "</signal>\n"
        /**
         * This callback is called when a notifcated value of a source changes.
         */
        "<signal name=\"sourceNotification\">\n"
            "<arg name=\"sourceID\" type=\"q\" />\n"
            "<arg name=\"notification\" type=\"(qn)\" />\n"
        "</signal>\n"
        /**
         * This callback is triggered when a mainNotificationConfiguration is changed.
         */
        "<signal name=\"mainSinkNotificationConfigurationChanged\">\n"
            "<arg name=\"sinkID\" type=\"q\" />\n"
            "<arg name=\"mainNotificationConfiguration\" type=\"(qin)\" />\n"
        "</signal>\n"
        /**
         * This callback is triggered when a mainNotificationConfiguration is changed.
         */
        "<signal name=\"mainSourceNotificationConfigurationChanged\">\n"
            "<arg name=\"sourceID\" type=\"q\" />\n"
            "<arg name=\"mainNotificationConfiguration\" type=\"(qin)\" />\n"
        "</signal>\n"
        /**
         * connects a source to sink
        (at)return E_OK on success, E_NOT_POSSIBLE on
         *  failure, E_ALREADY_EXISTS if the connection does already exists
         */
        "<method name=\"connect\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"mainConnectionID\" type=\"q\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * disconnects a mainConnection
        (at)return E_OK on successes, E_NON_EXISTENT if
         *  the connection does not exist, E_NOT_POSSIBLE on error.
         */
        "<method name=\"disconnect\">\n"
            "<arg name=\"mainConnectionID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * sets the volume for a sink
        (at)return E_OK on success, E_UNKOWN on error,
         *  E_OUT_OF_RANGE in case the value is out of range
         */
        "<method name=\"setVolume\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"volume\" type=\"n\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This function is used to increment or decrement the current volume for a
         *  sink.
        (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
         *  the value is not in the given volume range.
         */
        "<method name=\"volumeStep\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"volumeStep_\" type=\"n\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * sets the mute state of a sink
        (at)return E_OK on success, E_UNKNOWN on error.
         *  If the mute state is already the desired one, the Daemon will return E_OK.
         */
        "<method name=\"setSinkMuteState\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"muteState\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This method is used to set sound properties, e.g. Equalizer Values. Since the
         *  capabilities of the system can differ, the exact key value pairs can be
         *  extended in each product
        (at)return E_OK on success, E_OUT_OF_RANGE if value
         *  exceeds range, E_UNKNOWN in case of an error
         */
        "<method name=\"setMainSinkSoundProperty\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"soundProperty\" type=\"(qn)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This method is used to set sound properties, e.g. Equalizer Values. Since the
         *  capabilities of the system can differ, the exact key value pairs can be
         *  extended in each product
        (at)return E_OK on success, E_OUT_OF_RANGE if value
         *  exceeds range, E_UNKNOWN in case of an error
         */
        "<method name=\"setMainSourceSoundProperty\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"soundProperty\" type=\"(qn)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * is used to set a specific system property.
        (at)return E_OK on success,
         *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
         */
        "<method name=\"setSystemProperty\">\n"
            "<arg name=\"property\" type=\"(qn)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * returns the actual list of MainConnections
        (at)return E_OK on success,
         *  E_DATABASE_ERROR on error
         */
        "<method name=\"getListMainConnections\">\n"
            "<arg name=\"listConnections\" type=\"a(qqqni)\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * returns the actual list of Sinks
        (at)return E_OK on success, E_DATABASE_ERROR
         *  on error
         */
        "<method name=\"getListMainSinks\">\n"
            "<arg name=\"listMainSinks\" type=\"a(qs(iq)niq)\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * returns the actual list of Sources
        (at)return E_OK on success,
         *  E_DATABASE_ERROR on error
         */
        "<method name=\"getListMainSources\">\n"
            "<arg name=\"listMainSources\" type=\"a(qs(iq)q)\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This is used to retrieve all source sound properties related to a source.
         *  Returns a vector of the sound properties and values as pair
        (at)return E_OK
         *  on success, E_DATABASE_ERROR on error
         */
        "<method name=\"getListMainSinkSoundProperties\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listSoundProperties\" type=\"a(qn)\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This is used to retrieve all source sound properties related to a
         *  source.
        (at)return E_OK on success, E_DATABASE_ERROR on error
         */
        "<method name=\"getListMainSourceSoundProperties\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listSourceProperties\" type=\"a(qn)\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This is used to retrieve SourceClass Information of all source classes
         *  
        (at)return E_OK on success, E_DATABASE_ERROR on error
         */
        "<method name=\"getListSourceClasses\">\n"
            "<arg name=\"listSourceClasses\" type=\"a(qsa(qn))\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * This is used to retrieve SinkClass Information of all sink classes 
        (at)return
         *  E_OK on success, E_DATABASE_ERROR on error
         */
        "<method name=\"getListSinkClasses\">\n"
            "<arg name=\"listSinkClasses\" type=\"a(qsa(qn))\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Retrieves a complete list of all systemProperties.
        (at)return E_OK on success,
         *  E_DATABASE_ERROR on error
         */
        "<method name=\"getListSystemProperties\">\n"
            "<arg name=\"listSystemProperties\" type=\"a(qn)\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * returns the delay in ms that the audiopath for the given mainConnection
         *  has
        (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
         *  yet retrieved, E_DATABASE_ERROR on read error on the database
         */
        "<method name=\"getTimingInformation\">\n"
            "<arg name=\"mainConnectionID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"delay\" type=\"n\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Retrieves the list of MainNotifications for a sink. Does not return the
         *  possible ones.
         */
        "<method name=\"getListMainSinkNotificationConfigurations\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listMainNotificationConfigurations\" type=\"a(qin)\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * Retrieves the list of MainNotifications for a source. Does not return the
         *  possible ones.
         */
        "<method name=\"getListMainSourceNotificationConfigurations\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"listMainNotificationConfigurations\" type=\"a(qin)\" direction=\"out\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * sets a MainNotificationConfiuration. This can be used to turn on an off
         *  notifications an to change the mode of the configuration.
        (at)return E_OK on
         *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
         */
        "<method name=\"setMainSinkNotificationConfiguration\">\n"
            "<arg name=\"sinkID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"mainNotificationConfiguration\" type=\"(qin)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * sets a MainNotificationConfiuration. This can be used to turn on an off
         *  notifications an to change the mode of the configuration.
        (at)return E_OK on
         *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
         */
        "<method name=\"setMainSourceNotificationConfiguration\">\n"
            "<arg name=\"sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"mainNotificationConfiguration\" type=\"(qin)\" direction=\"in\" />\n"
            "<arg name=\"error\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
    ;
    return introspectionData;
}



/**
 * connects a source to sink
(at)return E_OK on success, E_NOT_POSSIBLE on
 *  failure, E_ALREADY_EXISTS if the connection does already exists
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sourceID_t, am_sinkID_t>,
    std::tuple<am_mainConnectionID_t, am_Error_e>
    > connectStubDispatcher(&CommandControlStub::connect, "qi");
/**
 * disconnects a mainConnection
(at)return E_OK on successes, E_NON_EXISTENT if
 *  the connection does not exist, E_NOT_POSSIBLE on error.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_mainConnectionID_t>,
    std::tuple<am_Error_e>
    > disconnectStubDispatcher(&CommandControlStub::disconnect, "i");
/**
 * sets the volume for a sink
(at)return E_OK on success, E_UNKOWN on error,
 *  E_OUT_OF_RANGE in case the value is out of range
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sinkID_t, am_mainVolume_t>,
    std::tuple<am_Error_e>
    > setVolumeStubDispatcher(&CommandControlStub::setVolume, "i");
/**
 * This function is used to increment or decrement the current volume for a
 *  sink.
(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
 *  the value is not in the given volume range.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sinkID_t, int16_t>,
    std::tuple<am_Error_e>
    > volumeStepStubDispatcher(&CommandControlStub::volumeStep, "i");
/**
 * sets the mute state of a sink
(at)return E_OK on success, E_UNKNOWN on error.
 *  If the mute state is already the desired one, the Daemon will return E_OK.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sinkID_t, am_MuteState_e>,
    std::tuple<am_Error_e>
    > setSinkMuteStateStubDispatcher(&CommandControlStub::setSinkMuteState, "i");
/**
 * This method is used to set sound properties, e.g. Equalizer Values. Since the
 *  capabilities of the system can differ, the exact key value pairs can be
 *  extended in each product
(at)return E_OK on success, E_OUT_OF_RANGE if value
 *  exceeds range, E_UNKNOWN in case of an error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sinkID_t, am_MainSoundProperty_s>,
    std::tuple<am_Error_e>
    > setMainSinkSoundPropertyStubDispatcher(&CommandControlStub::setMainSinkSoundProperty, "i");
/**
 * This method is used to set sound properties, e.g. Equalizer Values. Since the
 *  capabilities of the system can differ, the exact key value pairs can be
 *  extended in each product
(at)return E_OK on success, E_OUT_OF_RANGE if value
 *  exceeds range, E_UNKNOWN in case of an error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sourceID_t, am_MainSoundProperty_s>,
    std::tuple<am_Error_e>
    > setMainSourceSoundPropertyStubDispatcher(&CommandControlStub::setMainSourceSoundProperty, "i");
/**
 * is used to set a specific system property.
(at)return E_OK on success,
 *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_SystemProperty_s>,
    std::tuple<am_Error_e>
    > setSystemPropertyStubDispatcher(&CommandControlStub::setSystemProperty, "i");
/**
 * returns the actual list of MainConnections
(at)return E_OK on success,
 *  E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<>,
    std::tuple<am_MainConnection_L, am_Error_e>
    > getListMainConnectionsStubDispatcher(&CommandControlStub::getListMainConnections, "a(qqqni)i");
/**
 * returns the actual list of Sinks
(at)return E_OK on success, E_DATABASE_ERROR
 *  on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<>,
    std::tuple<am_SinkType_L, am_Error_e>
    > getListMainSinksStubDispatcher(&CommandControlStub::getListMainSinks, "a(qs(iq)niq)i");
/**
 * returns the actual list of Sources
(at)return E_OK on success,
 *  E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<>,
    std::tuple<am_SourceType_L, am_Error_e>
    > getListMainSourcesStubDispatcher(&CommandControlStub::getListMainSources, "a(qs(iq)q)i");
/**
 * This is used to retrieve all source sound properties related to a source.
 *  Returns a vector of the sound properties and values as pair
(at)return E_OK
 *  on success, E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sinkID_t>,
    std::tuple<am_MainSoundProperty_L, am_Error_e>
    > getListMainSinkSoundPropertiesStubDispatcher(&CommandControlStub::getListMainSinkSoundProperties, "a(qn)i");
/**
 * This is used to retrieve all source sound properties related to a
 *  source.
(at)return E_OK on success, E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sourceID_t>,
    std::tuple<am_MainSoundProperty_L, am_Error_e>
    > getListMainSourceSoundPropertiesStubDispatcher(&CommandControlStub::getListMainSourceSoundProperties, "a(qn)i");
/**
 * This is used to retrieve SourceClass Information of all source classes
 *  
(at)return E_OK on success, E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<>,
    std::tuple<am_SourceClass_L, am_Error_e>
    > getListSourceClassesStubDispatcher(&CommandControlStub::getListSourceClasses, "a(qsa(qn))i");
/**
 * This is used to retrieve SinkClass Information of all sink classes 
(at)return
 *  E_OK on success, E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<>,
    std::tuple<am_SinkClass_L, am_Error_e>
    > getListSinkClassesStubDispatcher(&CommandControlStub::getListSinkClasses, "a(qsa(qn))i");
/**
 * Retrieves a complete list of all systemProperties.
(at)return E_OK on success,
 *  E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<>,
    std::tuple<am_SystemProperty_L, am_Error_e>
    > getListSystemPropertiesStubDispatcher(&CommandControlStub::getListSystemProperties, "a(qn)i");
/**
 * returns the delay in ms that the audiopath for the given mainConnection
 *  has
(at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
 *  yet retrieved, E_DATABASE_ERROR on read error on the database
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_mainConnectionID_t>,
    std::tuple<am_timeSync_t, am_Error_e>
    > getTimingInformationStubDispatcher(&CommandControlStub::getTimingInformation, "ni");
/**
 * Retrieves the list of MainNotifications for a sink. Does not return the
 *  possible ones.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sinkID_t>,
    std::tuple<am_NotificationConfiguration_L, am_Error_e>
    > getListMainSinkNotificationConfigurationsStubDispatcher(&CommandControlStub::getListMainSinkNotificationConfigurations, "a(qin)i");
/**
 * Retrieves the list of MainNotifications for a source. Does not return the
 *  possible ones.
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sourceID_t>,
    std::tuple<am_NotificationConfiguration_L, am_Error_e>
    > getListMainSourceNotificationConfigurationsStubDispatcher(&CommandControlStub::getListMainSourceNotificationConfigurations, "a(qin)i");
/**
 * sets a MainNotificationConfiuration. This can be used to turn on an off
 *  notifications an to change the mode of the configuration.
(at)return E_OK on
 *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sinkID_t, am_NotificationConfiguration_s>,
    std::tuple<am_Error_e>
    > setMainSinkNotificationConfigurationStubDispatcher(&CommandControlStub::setMainSinkNotificationConfiguration, "i");
/**
 * sets a MainNotificationConfiuration. This can be used to turn on an off
 *  notifications an to change the mode of the configuration.
(at)return E_OK on
 *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
 */
static CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    CommandControlStub,
    std::tuple<am_sourceID_t, am_NotificationConfiguration_s>,
    std::tuple<am_Error_e>
    > setMainSourceNotificationConfigurationStubDispatcher(&CommandControlStub::setMainSourceNotificationConfiguration, "i");


/**
 * Callback that is called when the number of connections change
 */
void CommandControlDBusStubAdapter::fireNewMainConnectionEvent(const am_MainConnectionType_s& mainConnection) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_MainConnectionType_s>>
            ::sendSignal(
                *this,
                "newMainConnection",
                "(qqqni)",
                mainConnection
        );
}
/**
 * Callback that is called when the number of connections change
 */
void CommandControlDBusStubAdapter::fireRemovedMainConnectionEvent(const am_mainConnectionID_t& mainConnection) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t>>
            ::sendSignal(
                *this,
                "removedMainConnection",
                "q",
                mainConnection
        );
}
/**
 * Callback that is called when the number of sinks change
 */
void CommandControlDBusStubAdapter::fireNewSinkEvent(const am_SinkType_s& sink) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_SinkType_s>>
            ::sendSignal(
                *this,
                "newSink",
                "(qs(iq)niq)",
                sink
        );
}
/**
 * Callback that is called when the number of sinks change
 */
void CommandControlDBusStubAdapter::fireRemovedSinkEvent(const am_sinkID_t& sinkID) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t>>
            ::sendSignal(
                *this,
                "removedSink",
                "q",
                sinkID
        );
}
/**
 * Callback that is called when the number of sources change
 */
void CommandControlDBusStubAdapter::fireNewSourceEvent(const am_SourceType_s& source) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_SourceType_s>>
            ::sendSignal(
                *this,
                "newSource",
                "(qs(iq)q)",
                source
        );
}
/**
 * Callback that is called when the number of sources change
 */
void CommandControlDBusStubAdapter::fireRemovedSourceEvent(const am_sourceID_t& source) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t>>
            ::sendSignal(
                *this,
                "removedSource",
                "q",
                source
        );
}
/**
 * this callback is fired if the number of sink classes changed
 */
void CommandControlDBusStubAdapter::fireNumberOfSinkClassesChangedEvent() {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<>>
            ::sendSignal(
                *this,
                "numberOfSinkClassesChanged",
                ""
        );
}
/**
 * this callback is fired if the number of source classes changed
 */
void CommandControlDBusStubAdapter::fireNumberOfSourceClassesChangedEvent() {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<>>
            ::sendSignal(
                *this,
                "numberOfSourceClassesChanged",
                ""
        );
}
/**
 * This callback is called when the ConnectionState of a connection changed.
 */
void CommandControlDBusStubAdapter::fireMainConnectionStateChangedEvent(const am_mainConnectionID_t& connectionID, const am_ConnectionState_e& connectionState) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t, am_ConnectionState_e>>
            ::sendSignal(
                *this,
                "mainConnectionStateChanged",
                "qi",
                connectionID, connectionState
        );
}
/**
 * this callback indicates that a sinkSoundProperty has changed.
 */
void CommandControlDBusStubAdapter::fireMainSinkSoundPropertyChangedEvent(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_MainSoundProperty_s>>
            ::sendSignal(
                *this,
                "mainSinkSoundPropertyChanged",
                "q(qn)",
                sinkID, soundProperty
        );
}
/**
 * this callback indicates that a sourceSoundProperty has changed.
 */
void CommandControlDBusStubAdapter::fireMainSourceSoundPropertyChangedEvent(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_MainSoundProperty_s>>
            ::sendSignal(
                *this,
                "mainSourceSoundPropertyChanged",
                "q(qn)",
                sourceID, soundProperty
        );
}
/**
 * this callback is called when the availability of a sink has changed
 */
void CommandControlDBusStubAdapter::fireSinkAvailabilityChangedEvent(const am_sinkID_t& sinkID, const am_Availability_s& availability) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_Availability_s>>
            ::sendSignal(
                *this,
                "sinkAvailabilityChanged",
                "q(iq)",
                sinkID, availability
        );
}
/**
 * this callback is called when the availability of source has changed.
 */
void CommandControlDBusStubAdapter::fireSourceAvailabilityChangedEvent(const am_sourceID_t& sourceID, const am_Availability_s& availability) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_Availability_s>>
            ::sendSignal(
                *this,
                "sourceAvailabilityChanged",
                "q(iq)",
                sourceID, availability
        );
}
/**
 * this callback indicates a volume change on the indicated sink
 */
void CommandControlDBusStubAdapter::fireVolumeChangedEvent(const am_sinkID_t& sinkID, const am_mainVolume_t& volume) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_mainVolume_t>>
            ::sendSignal(
                *this,
                "volumeChanged",
                "qn",
                sinkID, volume
        );
}
/**
 * this callback indicates a mute state change on a sink.
 */
void CommandControlDBusStubAdapter::fireSinkMuteStateChangedEvent(const am_sinkID_t& sinkID, const am_MuteState_e& muteState) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_MuteState_e>>
            ::sendSignal(
                *this,
                "sinkMuteStateChanged",
                "qi",
                sinkID, muteState
        );
}
/**
 * is fired if a systemProperty changed
 */
void CommandControlDBusStubAdapter::fireSystemPropertyChangedEvent(const am_SystemProperty_s& systemProperty) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_SystemProperty_s>>
            ::sendSignal(
                *this,
                "systemPropertyChanged",
                "(qn)",
                systemProperty
        );
}
/**
 * This callback is fired if the timinginformation for a mainConnectionID changed
 */
void CommandControlDBusStubAdapter::fireTimingInformationChangedEvent(const am_mainConnectionID_t& mainConnectionID, const am_timeSync_t& time) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_mainConnectionID_t, am_timeSync_t>>
            ::sendSignal(
                *this,
                "timingInformationChanged",
                "qn",
                mainConnectionID, time
        );
}
/**
 * This callback is called when a sink is updated.
 */
void CommandControlDBusStubAdapter::fireSinkUpdatedEvent(const am_sinkID_t& sinkID, const am_sinkClass_t& sinkClassID, const am_MainSoundProperty_L& listMainSoundProperties) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_sinkClass_t, am_MainSoundProperty_L>>
            ::sendSignal(
                *this,
                "sinkUpdated",
                "qqa(qn)",
                sinkID, sinkClassID, listMainSoundProperties
        );
}
/**
 * This callback is called when a source is updated.
 */
void CommandControlDBusStubAdapter::fireSourceUpdatedEvent(const am_sourceID_t& sourceID, const am_sourceClass_t& sourceClassID, const am_MainSoundProperty_L& listMainSoundProperties) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_sourceClass_t, am_MainSoundProperty_L>>
            ::sendSignal(
                *this,
                "sourceUpdated",
                "qqa(qn)",
                sourceID, sourceClassID, listMainSoundProperties
        );
}
/**
 * This callback is called when a notificated value of a sink changes.
 */
void CommandControlDBusStubAdapter::fireSinkNotificationEvent(const am_sinkID_t& sinkID, const am_NotificationPayload_s& notification) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationPayload_s>>
            ::sendSignal(
                *this,
                "sinkNotification",
                "q(qn)",
                sinkID, notification
        );
}
/**
 * This callback is called when a notifcated value of a source changes.
 */
void CommandControlDBusStubAdapter::fireSourceNotificationEvent(const am_sourceID_t& sourceID, const am_NotificationPayload_s& notification) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationPayload_s>>
            ::sendSignal(
                *this,
                "sourceNotification",
                "q(qn)",
                sourceID, notification
        );
}
/**
 * This callback is triggered when a mainNotificationConfiguration is changed.
 */
void CommandControlDBusStubAdapter::fireMainSinkNotificationConfigurationChangedEvent(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sinkID_t, am_NotificationConfiguration_s>>
            ::sendSignal(
                *this,
                "mainSinkNotificationConfigurationChanged",
                "q(qin)",
                sinkID, mainNotificationConfiguration
        );
}
/**
 * This callback is triggered when a mainNotificationConfiguration is changed.
 */
void CommandControlDBusStubAdapter::fireMainSourceNotificationConfigurationChangedEvent(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<am_sourceID_t, am_NotificationConfiguration_s>>
            ::sendSignal(
                *this,
                "mainSourceNotificationConfigurationChanged",
                "q(qin)",
                sourceID, mainNotificationConfiguration
        );
}

const CommandControlDBusStubAdapter::StubDispatcherTable& CommandControlDBusStubAdapter::getStubDispatcherTable() {
    static const CommandControlDBusStubAdapter::StubDispatcherTable stubDispatcherTable = {
            /**
             * connects a source to sink
            (at)return E_OK on success, E_NOT_POSSIBLE on
             *  failure, E_ALREADY_EXISTS if the connection does already exists
             */
            { { "connect", "qq" }, &org::genivi::am::connectStubDispatcher },
            /**
             * disconnects a mainConnection
            (at)return E_OK on successes, E_NON_EXISTENT if
             *  the connection does not exist, E_NOT_POSSIBLE on error.
             */
            { { "disconnect", "q" }, &org::genivi::am::disconnectStubDispatcher },
            /**
             * sets the volume for a sink
            (at)return E_OK on success, E_UNKOWN on error,
             *  E_OUT_OF_RANGE in case the value is out of range
             */
            { { "setVolume", "qn" }, &org::genivi::am::setVolumeStubDispatcher },
            /**
             * This function is used to increment or decrement the current volume for a
             *  sink.
            (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
             *  the value is not in the given volume range.
             */
            { { "volumeStep", "qn" }, &org::genivi::am::volumeStepStubDispatcher },
            /**
             * sets the mute state of a sink
            (at)return E_OK on success, E_UNKNOWN on error.
             *  If the mute state is already the desired one, the Daemon will return E_OK.
             */
            { { "setSinkMuteState", "qi" }, &org::genivi::am::setSinkMuteStateStubDispatcher },
            /**
             * This method is used to set sound properties, e.g. Equalizer Values. Since the
             *  capabilities of the system can differ, the exact key value pairs can be
             *  extended in each product
            (at)return E_OK on success, E_OUT_OF_RANGE if value
             *  exceeds range, E_UNKNOWN in case of an error
             */
            { { "setMainSinkSoundProperty", "q(qn)" }, &org::genivi::am::setMainSinkSoundPropertyStubDispatcher },
            /**
             * This method is used to set sound properties, e.g. Equalizer Values. Since the
             *  capabilities of the system can differ, the exact key value pairs can be
             *  extended in each product
            (at)return E_OK on success, E_OUT_OF_RANGE if value
             *  exceeds range, E_UNKNOWN in case of an error
             */
            { { "setMainSourceSoundProperty", "q(qn)" }, &org::genivi::am::setMainSourceSoundPropertyStubDispatcher },
            /**
             * is used to set a specific system property.
            (at)return E_OK on success,
             *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
             */
            { { "setSystemProperty", "(qn)" }, &org::genivi::am::setSystemPropertyStubDispatcher },
            /**
             * returns the actual list of MainConnections
            (at)return E_OK on success,
             *  E_DATABASE_ERROR on error
             */
            { { "getListMainConnections", "" }, &org::genivi::am::getListMainConnectionsStubDispatcher },
            /**
             * returns the actual list of Sinks
            (at)return E_OK on success, E_DATABASE_ERROR
             *  on error
             */
            { { "getListMainSinks", "" }, &org::genivi::am::getListMainSinksStubDispatcher },
            /**
             * returns the actual list of Sources
            (at)return E_OK on success,
             *  E_DATABASE_ERROR on error
             */
            { { "getListMainSources", "" }, &org::genivi::am::getListMainSourcesStubDispatcher },
            /**
             * This is used to retrieve all source sound properties related to a source.
             *  Returns a vector of the sound properties and values as pair
            (at)return E_OK
             *  on success, E_DATABASE_ERROR on error
             */
            { { "getListMainSinkSoundProperties", "q" }, &org::genivi::am::getListMainSinkSoundPropertiesStubDispatcher },
            /**
             * This is used to retrieve all source sound properties related to a
             *  source.
            (at)return E_OK on success, E_DATABASE_ERROR on error
             */
            { { "getListMainSourceSoundProperties", "q" }, &org::genivi::am::getListMainSourceSoundPropertiesStubDispatcher },
            /**
             * This is used to retrieve SourceClass Information of all source classes
             *  
            (at)return E_OK on success, E_DATABASE_ERROR on error
             */
            { { "getListSourceClasses", "" }, &org::genivi::am::getListSourceClassesStubDispatcher },
            /**
             * This is used to retrieve SinkClass Information of all sink classes 
            (at)return
             *  E_OK on success, E_DATABASE_ERROR on error
             */
            { { "getListSinkClasses", "" }, &org::genivi::am::getListSinkClassesStubDispatcher },
            /**
             * Retrieves a complete list of all systemProperties.
            (at)return E_OK on success,
             *  E_DATABASE_ERROR on error
             */
            { { "getListSystemProperties", "" }, &org::genivi::am::getListSystemPropertiesStubDispatcher },
            /**
             * returns the delay in ms that the audiopath for the given mainConnection
             *  has
            (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
             *  yet retrieved, E_DATABASE_ERROR on read error on the database
             */
            { { "getTimingInformation", "q" }, &org::genivi::am::getTimingInformationStubDispatcher },
            /**
             * Retrieves the list of MainNotifications for a sink. Does not return the
             *  possible ones.
             */
            { { "getListMainSinkNotificationConfigurations", "q" }, &org::genivi::am::getListMainSinkNotificationConfigurationsStubDispatcher },
            /**
             * Retrieves the list of MainNotifications for a source. Does not return the
             *  possible ones.
             */
            { { "getListMainSourceNotificationConfigurations", "q" }, &org::genivi::am::getListMainSourceNotificationConfigurationsStubDispatcher },
            /**
             * sets a MainNotificationConfiuration. This can be used to turn on an off
             *  notifications an to change the mode of the configuration.
            (at)return E_OK on
             *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
             */
            { { "setMainSinkNotificationConfiguration", "q(qin)" }, &org::genivi::am::setMainSinkNotificationConfigurationStubDispatcher },
            /**
             * sets a MainNotificationConfiuration. This can be used to turn on an off
             *  notifications an to change the mode of the configuration.
            (at)return E_OK on
             *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
             */
            { { "setMainSourceNotificationConfiguration", "q(qin)" }, &org::genivi::am::setMainSourceNotificationConfigurationStubDispatcher }
            };
    return stubDispatcherTable;
}


} // namespace am
} // namespace genivi
} // namespace org

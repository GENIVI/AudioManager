/*
* This file was generated by the CommonAPI Generators. 
* Used org.genivi.commonapi.core 2.1.2.201309301424.
* Used org.franca.core 0.8.9.201308271211.
*
*  Copyright (c) 2012 BMW
*  
*   \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
*  
*   \copyright
*   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
*   including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
*   subject to the following conditions:
*   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
*   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
*   THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*    For further information see http://www.genivi.org/.
*  
*/
/**
 * The interface towards the Controlling Instance (e.g HMI). It handles the
 *  communication towards the HMI and other system components who need to interact
 *  with the audiomanagement.
There are two rules that have to be kept in mind
 *  when implementing against this interface:
 * @author Christian Mueller
 */
#ifndef ORG_GENIVI_AM_Command_Control_PROXY_H_
#define ORG_GENIVI_AM_Command_Control_PROXY_H_

#include "CommandControlProxyBase.h"

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace am {

template <typename ... _AttributeExtensions>
class CommandControlProxy: virtual public CommandControl, virtual public CommandControlProxyBase, public _AttributeExtensions... {
 public:
    CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~CommandControlProxy();


    /**
     * Callback that is called when the number of connections change
     */
    /**
     * Returns the wrapper class that provides access to the broadcast newMainConnection.
     */
    virtual NewMainConnectionEvent& getNewMainConnectionEvent() {
        return delegate_->getNewMainConnectionEvent();
    }
    /**
     * Callback that is called when the number of connections change
     */
    /**
     * Returns the wrapper class that provides access to the broadcast removedMainConnection.
     */
    virtual RemovedMainConnectionEvent& getRemovedMainConnectionEvent() {
        return delegate_->getRemovedMainConnectionEvent();
    }
    /**
     * Callback that is called when the number of sinks change
     */
    /**
     * Returns the wrapper class that provides access to the broadcast newSink.
     */
    virtual NewSinkEvent& getNewSinkEvent() {
        return delegate_->getNewSinkEvent();
    }
    /**
     * Callback that is called when the number of sinks change
     */
    /**
     * Returns the wrapper class that provides access to the broadcast removedSink.
     */
    virtual RemovedSinkEvent& getRemovedSinkEvent() {
        return delegate_->getRemovedSinkEvent();
    }
    /**
     * Callback that is called when the number of sources change
     */
    /**
     * Returns the wrapper class that provides access to the broadcast newSource.
     */
    virtual NewSourceEvent& getNewSourceEvent() {
        return delegate_->getNewSourceEvent();
    }
    /**
     * Callback that is called when the number of sources change
     */
    /**
     * Returns the wrapper class that provides access to the broadcast removedSource.
     */
    virtual RemovedSourceEvent& getRemovedSourceEvent() {
        return delegate_->getRemovedSourceEvent();
    }
    /**
     * this callback is fired if the number of sink classes changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast numberOfSinkClassesChanged.
     */
    virtual NumberOfSinkClassesChangedEvent& getNumberOfSinkClassesChangedEvent() {
        return delegate_->getNumberOfSinkClassesChangedEvent();
    }
    /**
     * this callback is fired if the number of source classes changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast numberOfSourceClassesChanged.
     */
    virtual NumberOfSourceClassesChangedEvent& getNumberOfSourceClassesChangedEvent() {
        return delegate_->getNumberOfSourceClassesChangedEvent();
    }
    /**
     * This callback is called when the ConnectionState of a connection changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainConnectionStateChanged.
     */
    virtual MainConnectionStateChangedEvent& getMainConnectionStateChangedEvent() {
        return delegate_->getMainConnectionStateChangedEvent();
    }
    /**
     * this callback indicates that a sinkSoundProperty has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainSinkSoundPropertyChanged.
     */
    virtual MainSinkSoundPropertyChangedEvent& getMainSinkSoundPropertyChangedEvent() {
        return delegate_->getMainSinkSoundPropertyChangedEvent();
    }
    /**
     * this callback indicates that a sourceSoundProperty has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainSourceSoundPropertyChanged.
     */
    virtual MainSourceSoundPropertyChangedEvent& getMainSourceSoundPropertyChangedEvent() {
        return delegate_->getMainSourceSoundPropertyChangedEvent();
    }
    /**
     * this callback is called when the availability of a sink has changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sinkAvailabilityChanged.
     */
    virtual SinkAvailabilityChangedEvent& getSinkAvailabilityChangedEvent() {
        return delegate_->getSinkAvailabilityChangedEvent();
    }
    /**
     * this callback is called when the availability of source has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sourceAvailabilityChanged.
     */
    virtual SourceAvailabilityChangedEvent& getSourceAvailabilityChangedEvent() {
        return delegate_->getSourceAvailabilityChangedEvent();
    }
    /**
     * this callback indicates a volume change on the indicated sink
     */
    /**
     * Returns the wrapper class that provides access to the broadcast volumeChanged.
     */
    virtual VolumeChangedEvent& getVolumeChangedEvent() {
        return delegate_->getVolumeChangedEvent();
    }
    /**
     * this callback indicates a mute state change on a sink.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sinkMuteStateChanged.
     */
    virtual SinkMuteStateChangedEvent& getSinkMuteStateChangedEvent() {
        return delegate_->getSinkMuteStateChangedEvent();
    }
    /**
     * is fired if a systemProperty changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast systemPropertyChanged.
     */
    virtual SystemPropertyChangedEvent& getSystemPropertyChangedEvent() {
        return delegate_->getSystemPropertyChangedEvent();
    }
    /**
     * This callback is fired if the timinginformation for a mainConnectionID changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast timingInformationChanged.
     */
    virtual TimingInformationChangedEvent& getTimingInformationChangedEvent() {
        return delegate_->getTimingInformationChangedEvent();
    }
    /**
     * This callback is called when a sink is updated.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sinkUpdated.
     */
    virtual SinkUpdatedEvent& getSinkUpdatedEvent() {
        return delegate_->getSinkUpdatedEvent();
    }
    /**
     * This callback is called when a source is updated.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sourceUpdated.
     */
    virtual SourceUpdatedEvent& getSourceUpdatedEvent() {
        return delegate_->getSourceUpdatedEvent();
    }
    /**
     * This callback is called when a notificated value of a sink changes.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sinkNotification.
     */
    virtual SinkNotificationEvent& getSinkNotificationEvent() {
        return delegate_->getSinkNotificationEvent();
    }
    /**
     * This callback is called when a notifcated value of a source changes.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sourceNotification.
     */
    virtual SourceNotificationEvent& getSourceNotificationEvent() {
        return delegate_->getSourceNotificationEvent();
    }
    /**
     * This callback is triggered when a mainNotificationConfiguration is changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainSinkNotificationConfigurationChanged.
     */
    virtual MainSinkNotificationConfigurationChangedEvent& getMainSinkNotificationConfigurationChangedEvent() {
        return delegate_->getMainSinkNotificationConfigurationChangedEvent();
    }
    /**
     * This callback is triggered when a mainNotificationConfiguration is changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainSourceNotificationConfigurationChanged.
     */
    virtual MainSourceNotificationConfigurationChangedEvent& getMainSourceNotificationConfigurationChangedEvent() {
        return delegate_->getMainSourceNotificationConfigurationChangedEvent();
    }

    /**
     * connects a source to sink
    (at)return E_OK on success, E_NOT_POSSIBLE on
     *  failure, E_ALREADY_EXISTS if the connection does already exists
     * 
     * Calls connect with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error);
    /**
     * Calls connect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback);
    /**
     * disconnects a mainConnection
    (at)return E_OK on successes, E_NON_EXISTENT if
     *  the connection does not exist, E_NOT_POSSIBLE on error.
     * 
     * Calls disconnect with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls disconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback);
    /**
     * sets the volume for a sink
    (at)return E_OK on success, E_UNKOWN on error,
     *  E_OUT_OF_RANGE in case the value is out of range
     * 
     * Calls setVolume with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback);
    /**
     * This function is used to increment or decrement the current volume for a
     *  sink.
    (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
     *  the value is not in the given volume range.
     * 
     * Calls volumeStep with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep_, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls volumeStep with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep_, VolumeStepAsyncCallback callback);
    /**
     * sets the mute state of a sink
    (at)return E_OK on success, E_UNKNOWN on error.
     *  If the mute state is already the desired one, the Daemon will return E_OK.
     * 
     * Calls setSinkMuteState with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setSinkMuteState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback);
    /**
     * This method is used to set sound properties, e.g. Equalizer Values. Since the
     *  capabilities of the system can differ, the exact key value pairs can be
     *  extended in each product
    (at)return E_OK on success, E_OUT_OF_RANGE if value
     *  exceeds range, E_UNKNOWN in case of an error
     * 
     * Calls setMainSinkSoundProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setMainSinkSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback);
    /**
     * This method is used to set sound properties, e.g. Equalizer Values. Since the
     *  capabilities of the system can differ, the exact key value pairs can be
     *  extended in each product
    (at)return E_OK on success, E_OUT_OF_RANGE if value
     *  exceeds range, E_UNKNOWN in case of an error
     * 
     * Calls setMainSourceSoundProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setMainSourceSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback);
    /**
     * is used to set a specific system property.
    (at)return E_OK on success,
     *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
     * 
     * Calls setSystemProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setSystemProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback);
    /**
     * returns the actual list of MainConnections
    (at)return E_OK on success,
     *  E_DATABASE_ERROR on error
     * 
     * Calls getListMainConnections with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error);
    /**
     * Calls getListMainConnections with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback);
    /**
     * returns the actual list of Sinks
    (at)return E_OK on success, E_DATABASE_ERROR
     *  on error
     * 
     * Calls getListMainSinks with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error);
    /**
     * Calls getListMainSinks with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback callback);
    /**
     * returns the actual list of Sources
    (at)return E_OK on success,
     *  E_DATABASE_ERROR on error
     * 
     * Calls getListMainSources with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error);
    /**
     * Calls getListMainSources with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback);
    /**
     * This is used to retrieve all source sound properties related to a source.
     *  Returns a vector of the sound properties and values as pair
    (at)return E_OK
     *  on success, E_DATABASE_ERROR on error
     * 
     * Calls getListMainSinkSoundProperties with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
    /**
     * Calls getListMainSinkSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback);
    /**
     * This is used to retrieve all source sound properties related to a
     *  source.
    (at)return E_OK on success, E_DATABASE_ERROR on error
     * 
     * Calls getListMainSourceSoundProperties with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error);
    /**
     * Calls getListMainSourceSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback);
    /**
     * This is used to retrieve SourceClass Information of all source classes
     *  
    (at)return E_OK on success, E_DATABASE_ERROR on error
     * 
     * Calls getListSourceClasses with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error);
    /**
     * Calls getListSourceClasses with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback);
    /**
     * This is used to retrieve SinkClass Information of all sink classes 
    (at)return
     *  E_OK on success, E_DATABASE_ERROR on error
     * 
     * Calls getListSinkClasses with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error);
    /**
     * Calls getListSinkClasses with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback);
    /**
     * Retrieves a complete list of all systemProperties.
    (at)return E_OK on success,
     *  E_DATABASE_ERROR on error
     * 
     * Calls getListSystemProperties with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error);
    /**
     * Calls getListSystemProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback);
    /**
     * returns the delay in ms that the audiopath for the given mainConnection
     *  has
    (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
     *  yet retrieved, E_DATABASE_ERROR on read error on the database
     * 
     * Calls getTimingInformation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error);
    /**
     * Calls getTimingInformation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback);
    /**
     * Retrieves the list of MainNotifications for a sink. Does not return the
     *  possible ones.
     * 
     * Calls getListMainSinkNotificationConfigurations with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
    /**
     * Calls getListMainSinkNotificationConfigurations with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback);
    /**
     * Retrieves the list of MainNotifications for a source. Does not return the
     *  possible ones.
     * 
     * Calls getListMainSourceNotificationConfigurations with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
    /**
     * Calls getListMainSourceNotificationConfigurations with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback);
    /**
     * sets a MainNotificationConfiuration. This can be used to turn on an off
     *  notifications an to change the mode of the configuration.
    (at)return E_OK on
     *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
     * 
     * Calls setMainSinkNotificationConfiguration with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setMainSinkNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback);
    /**
     * sets a MainNotificationConfiuration. This can be used to turn on an off
     *  notifications an to change the mode of the configuration.
    (at)return E_OK on
     *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
     * 
     * Calls setMainSourceNotificationConfiguration with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setMainSourceNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback);
    

    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual std::string getAddress() const;

    /**
     * Returns the domain of the remote partner this proxy communicates with.
     */
    virtual const std::string& getDomain() const;

    /** 
     * Returns the service ID of the remote partner this proxy communicates with.
     */
    virtual const std::string& getServiceId() const;

    /**
     * Returns the instance ID of the remote partner this proxy communicates with.
     */
    virtual const std::string& getInstanceId() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<CommandControlProxyBase> delegate_;
};


//
// CommandControlProxy Implementation
//
template <typename ... _AttributeExtensions>
CommandControlProxy<_AttributeExtensions...>::CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        delegate_(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)),
        _AttributeExtensions(*(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)))... {
}

template <typename ... _AttributeExtensions>
CommandControlProxy<_AttributeExtensions...>::~CommandControlProxy() {
}

/**
 * connects a source to sink
(at)return E_OK on success, E_NOT_POSSIBLE on
 *  failure, E_ALREADY_EXISTS if the connection does already exists
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error) {
    delegate_->connect(sourceID, sinkID, callStatus, mainConnectionID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback) {
    return delegate_->connectAsync(sourceID, sinkID, callback);
}
/**
 * disconnects a mainConnection
(at)return E_OK on successes, E_NON_EXISTENT if
 *  the connection does not exist, E_NOT_POSSIBLE on error.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->disconnect(mainConnectionID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback) {
    return delegate_->disconnectAsync(mainConnectionID, callback);
}
/**
 * sets the volume for a sink
(at)return E_OK on success, E_UNKOWN on error,
 *  E_OUT_OF_RANGE in case the value is out of range
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setVolume(sinkID, volume, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback) {
    return delegate_->setVolumeAsync(sinkID, volume, callback);
}
/**
 * This function is used to increment or decrement the current volume for a
 *  sink.
(at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if
 *  the value is not in the given volume range.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep_, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->volumeStep(sinkID, volumeStep_, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep_, VolumeStepAsyncCallback callback) {
    return delegate_->volumeStepAsync(sinkID, volumeStep_, callback);
}
/**
 * sets the mute state of a sink
(at)return E_OK on success, E_UNKNOWN on error.
 *  If the mute state is already the desired one, the Daemon will return E_OK.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setSinkMuteState(sinkID, muteState, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback) {
    return delegate_->setSinkMuteStateAsync(sinkID, muteState, callback);
}
/**
 * This method is used to set sound properties, e.g. Equalizer Values. Since the
 *  capabilities of the system can differ, the exact key value pairs can be
 *  extended in each product
(at)return E_OK on success, E_OUT_OF_RANGE if value
 *  exceeds range, E_UNKNOWN in case of an error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setMainSinkSoundProperty(sinkID, soundProperty, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback) {
    return delegate_->setMainSinkSoundPropertyAsync(sinkID, soundProperty, callback);
}
/**
 * This method is used to set sound properties, e.g. Equalizer Values. Since the
 *  capabilities of the system can differ, the exact key value pairs can be
 *  extended in each product
(at)return E_OK on success, E_OUT_OF_RANGE if value
 *  exceeds range, E_UNKNOWN in case of an error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setMainSourceSoundProperty(sourceID, soundProperty, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback) {
    return delegate_->setMainSourceSoundPropertyAsync(sourceID, soundProperty, callback);
}
/**
 * is used to set a specific system property.
(at)return E_OK on success,
 *  E_OUT_OF_RANGE if value exceeds range, E_UNKNOWN in case of an error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setSystemProperty(property, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback) {
    return delegate_->setSystemPropertyAsync(property, callback);
}
/**
 * returns the actual list of MainConnections
(at)return E_OK on success,
 *  E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error) {
    delegate_->getListMainConnections(callStatus, listConnections, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback) {
    return delegate_->getListMainConnectionsAsync(callback);
}
/**
 * returns the actual list of Sinks
(at)return E_OK on success, E_DATABASE_ERROR
 *  on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error) {
    delegate_->getListMainSinks(callStatus, listMainSinks, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinksAsync(GetListMainSinksAsyncCallback callback) {
    return delegate_->getListMainSinksAsync(callback);
}
/**
 * returns the actual list of Sources
(at)return E_OK on success,
 *  E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error) {
    delegate_->getListMainSources(callStatus, listMainSources, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback) {
    return delegate_->getListMainSourcesAsync(callback);
}
/**
 * This is used to retrieve all source sound properties related to a source.
 *  Returns a vector of the sound properties and values as pair
(at)return E_OK
 *  on success, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
    delegate_->getListMainSinkSoundProperties(sinkID, callStatus, listSoundProperties, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback) {
    return delegate_->getListMainSinkSoundPropertiesAsync(sinkID, callback);
}
/**
 * This is used to retrieve all source sound properties related to a
 *  source.
(at)return E_OK on success, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error) {
    delegate_->getListMainSourceSoundProperties(sourceID, callStatus, listSourceProperties, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback) {
    return delegate_->getListMainSourceSoundPropertiesAsync(sourceID, callback);
}
/**
 * This is used to retrieve SourceClass Information of all source classes
 *  
(at)return E_OK on success, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error) {
    delegate_->getListSourceClasses(callStatus, listSourceClasses, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback) {
    return delegate_->getListSourceClassesAsync(callback);
}
/**
 * This is used to retrieve SinkClass Information of all sink classes 
(at)return
 *  E_OK on success, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error) {
    delegate_->getListSinkClasses(callStatus, listSinkClasses, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback) {
    return delegate_->getListSinkClassesAsync(callback);
}
/**
 * Retrieves a complete list of all systemProperties.
(at)return E_OK on success,
 *  E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error) {
    delegate_->getListSystemProperties(callStatus, listSystemProperties, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback) {
    return delegate_->getListSystemPropertiesAsync(callback);
}
/**
 * returns the delay in ms that the audiopath for the given mainConnection
 *  has
(at)return E_OK on success, E_NOT_POSSIBLE if timing information is not
 *  yet retrieved, E_DATABASE_ERROR on read error on the database
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error) {
    delegate_->getTimingInformation(mainConnectionID, callStatus, delay, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback) {
    return delegate_->getTimingInformationAsync(mainConnectionID, callback);
}
/**
 * Retrieves the list of MainNotifications for a sink. Does not return the
 *  possible ones.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
    delegate_->getListMainSinkNotificationConfigurations(sinkID, callStatus, listMainNotificationConfigurations, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback) {
    return delegate_->getListMainSinkNotificationConfigurationsAsync(sinkID, callback);
}
/**
 * Retrieves the list of MainNotifications for a source. Does not return the
 *  possible ones.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
    delegate_->getListMainSourceNotificationConfigurations(sourceID, callStatus, listMainNotificationConfigurations, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback) {
    return delegate_->getListMainSourceNotificationConfigurationsAsync(sourceID, callback);
}
/**
 * sets a MainNotificationConfiuration. This can be used to turn on an off
 *  notifications an to change the mode of the configuration.
(at)return E_OK on
 *  success, E_NON_EXISTENT if sinkID does not exists, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setMainSinkNotificationConfiguration(sinkID, mainNotificationConfiguration, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback) {
    return delegate_->setMainSinkNotificationConfigurationAsync(sinkID, mainNotificationConfiguration, callback);
}
/**
 * sets a MainNotificationConfiuration. This can be used to turn on an off
 *  notifications an to change the mode of the configuration.
(at)return E_OK on
 *  success, E_NON_EXISTENT if sourceID does not exists, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setMainSourceNotificationConfiguration(sourceID, mainNotificationConfiguration, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback) {
    return delegate_->setMainSourceNotificationConfigurationAsync(sourceID, mainNotificationConfiguration, callback);
}

template <typename ... _AttributeExtensions>
std::string CommandControlProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& CommandControlProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& CommandControlProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& CommandControlProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool CommandControlProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool CommandControlProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& CommandControlProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& CommandControlProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}

        

} // namespace am
} // namespace genivi
} // namespace org


#endif // ORG_GENIVI_AM_Command_Control_PROXY_H_

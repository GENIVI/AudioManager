/*
* This file was generated by the CommonAPI Generators.
*
* This file was generated by the CommonAPI Generators.
*
* This file was generated by the CommonAPI Generators.
*
* Copyright (C) 2012, BMW AG
*
* This file is part of GENIVI Project AudioManager.
*
* Contributions are licensed to the GENIVI Alliance under one or more
* Contribution License Agreements.
*
* \copyright
* This Source Code Form is subject to the terms of the
* Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
* this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
*
* \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
* \author Christian Linke christian.linke@bmw.de BMW 2013
*
* For further information see http://www.genivi.org/.
*/
#ifndef ORG_GENIVI_AM_Command_Control_PROXY_H_
#define ORG_GENIVI_AM_Command_Control_PROXY_H_

#include "CommandControlProxyBase.h"

#define COMMONAPI_INTERNAL_COMPILATION


#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace am {

template <typename ... _AttributeExtensions>
class CommandControlProxy: virtual public CommandControl, virtual public CommandControlProxyBase, public _AttributeExtensions... {
 public:
    CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~CommandControlProxy();


    /// Returns the wrapper class that provides access to the broadcast newMainConnection.
    virtual NewMainConnectionEvent& getNewMainConnectionEvent() {
        return delegate_->getNewMainConnectionEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast removedMainConnection.
    virtual RemovedMainConnectionEvent& getRemovedMainConnectionEvent() {
        return delegate_->getRemovedMainConnectionEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast newSink.
    virtual NewSinkEvent& getNewSinkEvent() {
        return delegate_->getNewSinkEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast removedSink.
    virtual RemovedSinkEvent& getRemovedSinkEvent() {
        return delegate_->getRemovedSinkEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast newSource.
    virtual NewSourceEvent& getNewSourceEvent() {
        return delegate_->getNewSourceEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast removedSource.
    virtual RemovedSourceEvent& getRemovedSourceEvent() {
        return delegate_->getRemovedSourceEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast numberOfSinkClassesChanged.
    virtual NumberOfSinkClassesChangedEvent& getNumberOfSinkClassesChangedEvent() {
        return delegate_->getNumberOfSinkClassesChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast numberOfSourceClassesChanged.
    virtual NumberOfSourceClassesChangedEvent& getNumberOfSourceClassesChangedEvent() {
        return delegate_->getNumberOfSourceClassesChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast mainConnectionStateChanged.
    virtual MainConnectionStateChangedEvent& getMainConnectionStateChangedEvent() {
        return delegate_->getMainConnectionStateChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast mainSinkSoundPropertyChanged.
    virtual MainSinkSoundPropertyChangedEvent& getMainSinkSoundPropertyChangedEvent() {
        return delegate_->getMainSinkSoundPropertyChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast mainSourceSoundPropertyChanged.
    virtual MainSourceSoundPropertyChangedEvent& getMainSourceSoundPropertyChangedEvent() {
        return delegate_->getMainSourceSoundPropertyChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast sinkAvailabilityChanged.
    virtual SinkAvailabilityChangedEvent& getSinkAvailabilityChangedEvent() {
        return delegate_->getSinkAvailabilityChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast sourceAvailabilityChanged.
    virtual SourceAvailabilityChangedEvent& getSourceAvailabilityChangedEvent() {
        return delegate_->getSourceAvailabilityChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast volumeChanged.
    virtual VolumeChangedEvent& getVolumeChangedEvent() {
        return delegate_->getVolumeChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast sinkMuteStateChanged.
    virtual SinkMuteStateChangedEvent& getSinkMuteStateChangedEvent() {
        return delegate_->getSinkMuteStateChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast systemPropertyChanged.
    virtual SystemPropertyChangedEvent& getSystemPropertyChangedEvent() {
        return delegate_->getSystemPropertyChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast timingInformationChanged.
    virtual TimingInformationChangedEvent& getTimingInformationChangedEvent() {
        return delegate_->getTimingInformationChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast sinkUpdated.
    virtual SinkUpdatedEvent& getSinkUpdatedEvent() {
        return delegate_->getSinkUpdatedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast sourceUpdated.
    virtual SourceUpdatedEvent& getSourceUpdatedEvent() {
        return delegate_->getSourceUpdatedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast sinkNotification.
    virtual SinkNotificationEvent& getSinkNotificationEvent() {
        return delegate_->getSinkNotificationEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast sourceNotification.
    virtual SourceNotificationEvent& getSourceNotificationEvent() {
        return delegate_->getSourceNotificationEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast mainSinkNotificationConfigurationChanged.
    virtual MainSinkNotificationConfigurationChangedEvent& getMainSinkNotificationConfigurationChangedEvent() {
        return delegate_->getMainSinkNotificationConfigurationChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast mainSourceNotificationConfigurationChanged.
    virtual MainSourceNotificationConfigurationChangedEvent& getMainSourceNotificationConfigurationChangedEvent() {
        return delegate_->getMainSourceNotificationConfigurationChangedEvent();
    }



    /**
     * Calls connect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error);
    /**
     * Calls connect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback);

    /**
     * Calls disconnect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls disconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback);

    /**
     * Calls setVolume with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback);

    /**
     * Calls volumeStep with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls volumeStep with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep, VolumeStepAsyncCallback callback);

    /**
     * Calls setSinkMuteState with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setSinkMuteState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback);

    /**
     * Calls setMainSinkSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setMainSinkSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback);

    /**
     * Calls setMainSourceSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setMainSourceSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback);

    /**
     * Calls setSystemProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setSystemProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback);

    /**
     * Calls getListMainConnections with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error);
    /**
     * Calls getListMainConnections with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback);

    /**
     * Calls getListMainSinks with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error);
    /**
     * Calls getListMainSinks with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback callback);

    /**
     * Calls getListMainSources with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error);
    /**
     * Calls getListMainSources with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback);

    /**
     * Calls getListMainSinkSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error);
    /**
     * Calls getListMainSinkSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback);

    /**
     * Calls getListMainSourceSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error);
    /**
     * Calls getListMainSourceSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback);

    /**
     * Calls getListSourceClasses with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error);
    /**
     * Calls getListSourceClasses with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback);

    /**
     * Calls getListSinkClasses with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error);
    /**
     * Calls getListSinkClasses with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback);

    /**
     * Calls getListSystemProperties with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error);
    /**
     * Calls getListSystemProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback);

    /**
     * Calls getTimingInformation with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error);
    /**
     * Calls getTimingInformation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback);

    /**
     * Calls getListMainSinkNotificationConfigurations with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
    /**
     * Calls getListMainSinkNotificationConfigurations with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback);

    /**
     * Calls getListMainSourceNotificationConfigurations with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error);
    /**
     * Calls getListMainSourceNotificationConfigurations with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback);

    /**
     * Calls setMainSinkNotificationConfiguration with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setMainSinkNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback);

    /**
     * Calls setMainSourceNotificationConfiguration with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error);
    /**
     * Calls setMainSourceNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback);

    /// Returns the CommonAPI address of the remote partner this proxy communicates with.
    virtual std::string getAddress() const;

    /// Returns the domain of the remote partner this proxy communicates with.
    virtual const std::string& getDomain() const;

    /// Returns the service ID of the remote partner this proxy communicates with.
    virtual const std::string& getServiceId() const;

    /// Returns the instance ID of the remote partner this proxy communicates with.
    virtual const std::string& getInstanceId() const;

    /// Returns true if the remote partner for this proxy is available.
    virtual bool isAvailable() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<CommandControlProxyBase> delegate_;
};


//
// CommandControlProxy Implementation
//
template <typename ... _AttributeExtensions>
CommandControlProxy<_AttributeExtensions...>::CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        delegate_(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)),
        _AttributeExtensions(*(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)))... {
}

template <typename ... _AttributeExtensions>
CommandControlProxy<_AttributeExtensions...>::~CommandControlProxy() {
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::connect(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_mainConnectionID_t& mainConnectionID, am_Error_e& error) {
    delegate_->connect(sourceID, sinkID, callStatus, mainConnectionID, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::connectAsync(const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, ConnectAsyncCallback callback) {
    return delegate_->connectAsync(sourceID, sinkID, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::disconnect(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->disconnect(mainConnectionID, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::disconnectAsync(const am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback) {
    return delegate_->disconnectAsync(mainConnectionID, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setVolume(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setVolume(sinkID, volume, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setVolumeAsync(const am_sinkID_t& sinkID, const am_mainVolume_t& volume, SetVolumeAsyncCallback callback) {
    return delegate_->setVolumeAsync(sinkID, volume, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::volumeStep(const am_sinkID_t& sinkID, const int16_t& volumeStep, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->volumeStep(sinkID, volumeStep, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::volumeStepAsync(const am_sinkID_t& sinkID, const int16_t& volumeStep, VolumeStepAsyncCallback callback) {
    return delegate_->volumeStepAsync(sinkID, volumeStep, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setSinkMuteState(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setSinkMuteState(sinkID, muteState, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setSinkMuteStateAsync(const am_sinkID_t& sinkID, const am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback) {
    return delegate_->setSinkMuteStateAsync(sinkID, muteState, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSinkSoundProperty(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setMainSinkSoundProperty(sinkID, soundProperty, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSinkSoundPropertyAsync(const am_sinkID_t& sinkID, const am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback) {
    return delegate_->setMainSinkSoundPropertyAsync(sinkID, soundProperty, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSourceSoundProperty(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setMainSourceSoundProperty(sourceID, soundProperty, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSourceSoundPropertyAsync(const am_sourceID_t& sourceID, const am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback) {
    return delegate_->setMainSourceSoundPropertyAsync(sourceID, soundProperty, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setSystemProperty(const am_SystemProperty_s& property, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setSystemProperty(property, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setSystemPropertyAsync(const am_SystemProperty_s& property, SetSystemPropertyAsyncCallback callback) {
    return delegate_->setSystemPropertyAsync(property, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainConnections(CommonAPI::CallStatus& callStatus, am_MainConnection_L& listConnections, am_Error_e& error) {
    delegate_->getListMainConnections(callStatus, listConnections, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback) {
    return delegate_->getListMainConnectionsAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinks(CommonAPI::CallStatus& callStatus, am_SinkType_L& listMainSinks, am_Error_e& error) {
    delegate_->getListMainSinks(callStatus, listMainSinks, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinksAsync(GetListMainSinksAsyncCallback callback) {
    return delegate_->getListMainSinksAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSources(CommonAPI::CallStatus& callStatus, am_SourceType_L& listMainSources, am_Error_e& error) {
    delegate_->getListMainSources(callStatus, listMainSources, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourcesAsync(GetListMainSourcesAsyncCallback callback) {
    return delegate_->getListMainSourcesAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundProperties(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSoundProperties, am_Error_e& error) {
    delegate_->getListMainSinkSoundProperties(sinkID, callStatus, listSoundProperties, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundPropertiesAsync(const am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback) {
    return delegate_->getListMainSinkSoundPropertiesAsync(sinkID, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSourceSoundProperties(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_MainSoundProperty_L& listSourceProperties, am_Error_e& error) {
    delegate_->getListMainSourceSoundProperties(sourceID, callStatus, listSourceProperties, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourceSoundPropertiesAsync(const am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback) {
    return delegate_->getListMainSourceSoundPropertiesAsync(sourceID, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSourceClasses(CommonAPI::CallStatus& callStatus, am_SourceClass_L& listSourceClasses, am_Error_e& error) {
    delegate_->getListSourceClasses(callStatus, listSourceClasses, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSourceClassesAsync(GetListSourceClassesAsyncCallback callback) {
    return delegate_->getListSourceClassesAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSinkClasses(CommonAPI::CallStatus& callStatus, am_SinkClass_L& listSinkClasses, am_Error_e& error) {
    delegate_->getListSinkClasses(callStatus, listSinkClasses, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSinkClassesAsync(GetListSinkClassesAsyncCallback callback) {
    return delegate_->getListSinkClassesAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSystemProperties(CommonAPI::CallStatus& callStatus, am_SystemProperty_L& listSystemProperties, am_Error_e& error) {
    delegate_->getListSystemProperties(callStatus, listSystemProperties, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback) {
    return delegate_->getListSystemPropertiesAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getTimingInformation(const am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, am_timeSync_t& delay, am_Error_e& error) {
    delegate_->getTimingInformation(mainConnectionID, callStatus, delay, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getTimingInformationAsync(const am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback) {
    return delegate_->getTimingInformationAsync(mainConnectionID, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinkNotificationConfigurations(const am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
    delegate_->getListMainSinkNotificationConfigurations(sinkID, callStatus, listMainNotificationConfigurations, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinkNotificationConfigurationsAsync(const am_sinkID_t& sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback callback) {
    return delegate_->getListMainSinkNotificationConfigurationsAsync(sinkID, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSourceNotificationConfigurations(const am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, am_NotificationConfiguration_L& listMainNotificationConfigurations, am_Error_e& error) {
    delegate_->getListMainSourceNotificationConfigurations(sourceID, callStatus, listMainNotificationConfigurations, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourceNotificationConfigurationsAsync(const am_sourceID_t& sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback callback) {
    return delegate_->getListMainSourceNotificationConfigurationsAsync(sourceID, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSinkNotificationConfiguration(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setMainSinkNotificationConfiguration(sinkID, mainNotificationConfiguration, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSinkNotificationConfigurationAsync(const am_sinkID_t& sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback callback) {
    return delegate_->setMainSinkNotificationConfigurationAsync(sinkID, mainNotificationConfiguration, callback);
}

template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSourceNotificationConfiguration(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, CommonAPI::CallStatus& callStatus, am_Error_e& error) {
    delegate_->setMainSourceNotificationConfiguration(sourceID, mainNotificationConfiguration, callStatus, error);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSourceNotificationConfigurationAsync(const am_sourceID_t& sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback callback) {
    return delegate_->setMainSourceNotificationConfigurationAsync(sourceID, mainNotificationConfiguration, callback);
}


template <typename ... _AttributeExtensions>
std::string CommandControlProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& CommandControlProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& CommandControlProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& CommandControlProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool CommandControlProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& CommandControlProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& CommandControlProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}

} // namespace am
} // namespace genivi
} // namespace org



#endif // ORG_GENIVI_AM_Command_Control_PROXY_H_

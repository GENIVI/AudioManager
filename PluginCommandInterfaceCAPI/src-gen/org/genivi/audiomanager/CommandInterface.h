/*
* This file was generated by the CommonAPI Generators.
*
 *  Copyright (c) 2012 BMW
 *
 *  \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
 *
 *  \copyright
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
 *  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  For further information see http://www.genivi.org/.
*/
#ifndef ORG_GENIVI_AUDIOMANAGER_Command_Interface_H_
#define ORG_GENIVI_AUDIOMANAGER_Command_Interface_H_


#include <org/genivi/audiomanager/am.h>

#define COMMONAPI_INTERNAL_COMPILATION

#include <CommonAPI/InputStream.h>
#include <CommonAPI/OutputStream.h>
#include <CommonAPI/SerializableStruct.h>
#include <CommonAPI/types.h>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace audiomanager {

class CommandInterface {
 public:
    virtual ~CommandInterface() { }

    static inline const char* getInterfaceId();
    static inline CommonAPI::Version getInterfaceVersion();
    typedef uint16_t am_sourceID_t;
    
    typedef uint16_t am_sinkID_t;
    
    typedef uint16_t am_mainConnectionID_t;
    
    typedef int16_t am_timeSync_t;
    
    typedef int16_t am_mainVolume_t;
    
    typedef uint16_t am_sourceClass_t;
    
    typedef uint16_t am_sinkClass_t;
    
    enum class am_Error_e: int32_t {
        E_OK = 0x0,
        E_OUT_OF_RANGE = 0x1,
        E_NOT_USED = 0x2,
        E_DATABASE_ERROR = 0x3,
        E_ALREADY_EXISTS = 0x4,
        E_NO_CHANGE = 0x5,
        E_NOT_POSSIBLE = 0x6,
        E_NON_EXISTENT = 0x7,
        E_ABORTED = 0x8,
        E_WRONG_FORMAT = 0x9,
        E_MAX = 0xa
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Error_eComparator;
    
    enum class am_MuteState_e: int32_t {
        MS_UNKNOWN = 0x0,
        MS_MUTED = 0x1,
        MS_UNMUTED = 0x2,
        MS_MAX = 0x3
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_MuteState_eComparator;
    
    enum class am_MainSoundPropertyType_e: int32_t {
        MSP_UNKNOWN = 0x0,
        MSP_EXAMPLE_TREBLE = 0x1,
        MSP_EXAMPLE_MID = 0x2,
        MSP_EXAMPLE_BASS = 0x3,
        MSP_SOURCE_TYPE = 0x4,
        MSP_MAX = 0x5
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_MainSoundPropertyType_eComparator;
    
    enum class am_SystemPropertyType_e: int32_t {
        SYP_UNKNOWN = 0x0,
        SYP_MAX = 0x1
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_SystemPropertyType_eComparator;
    
    enum class am_ConnectionState_e: int32_t {
        CS_UNKNOWN = 0x0,
        CS_CONNECTING = 0x1,
        CS_CONNECTED = 0x2,
        CS_DISCONNECTING = 0x3,
        CS_DISCONNECTED = 0x4,
        CS_SUSPENDED = 0x5,
        CS_MAX = 0x6
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_ConnectionState_eComparator;
    
    enum class am_Availablility_e: int32_t {
        A_UNKNOWN = 0x0,
        A_AVAILABLE = 0x1,
        A_UNAVAILABLE = 0x2,
        A_MAX = 0x3
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Availablility_eComparator;
    
    enum class am_AvailabilityReason_e: int32_t {
        AR_UNKNOWN = 0x0,
        AR_GENIVI_NEWMEDIA = 0x1,
        AR_GENIVI_SAMEMEDIA = 0x2,
        AR_GENIVI_NOMEDIA = 0x3,
        AR_GENIVI_TEMPERATURE = 0x4,
        AR_GENIVI_VOLTAGE = 0x5,
        AR_GENIVI_ERRORMEDIA = 0x6,
        AR_MAX = 0x7
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_AvailabilityReason_eComparator;
    
    enum class am_ClassProperty_e: int32_t {
        CP_UNKNOWN = 0x0,
        CP_GENIVI_SOURCE_TYPE = 0x1,
        CP_GENIVI_SINK_TYPE = 0x2,
        CP_MAX = 0x3
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_ClassProperty_eComparator;
    
    enum class am_InterruptState_e: int32_t {
        IS_UNKNOWN = 0x0,
        IS_OFF = 0x1,
        IS_INTERRUPTED = 0x2,
        IS_MAX = 0x3
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_InterruptState_eComparator;
    
    struct am_MainSoundProperty_s: CommonAPI::SerializableStruct {
        am_MainSoundPropertyType_e type;
        int16_t value;
    
        am_MainSoundProperty_s() = default;
        am_MainSoundProperty_s(const am_MainSoundPropertyType_e& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_MainSoundProperty_s> am_MainSoundProperty_l;
    
    struct am_SystemProperty_s: CommonAPI::SerializableStruct {
        am_SystemPropertyType_e type;
        int16_t value;
    
        am_SystemProperty_s() = default;
        am_SystemProperty_s(const am_SystemPropertyType_e& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_SystemProperty_s> am_SystemProperty_l;
    
    struct am_MainConnectionType_s: CommonAPI::SerializableStruct {
        am_mainConnectionID_t mainConnectionID;
        am_sourceID_t sourceID;
        am_sinkID_t sinkID;
        am_timeSync_t delay;
        am_ConnectionState_e connectionState;
    
        am_MainConnectionType_s() = default;
        am_MainConnectionType_s(const am_mainConnectionID_t& mainConnectionID, const am_sourceID_t& sourceID, const am_sinkID_t& sinkID, const am_timeSync_t& delay, const am_ConnectionState_e& connectionState);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeInt32Type();
        }
    };
    
    typedef std::vector<am_MainConnectionType_s> am_MainConnectionType_l;
    
    struct am_Availability_s: CommonAPI::SerializableStruct {
        am_Availablility_e availability;
        am_AvailabilityReason_e availabilityReason;
    
        am_Availability_s() = default;
        am_Availability_s(const am_Availablility_e& availability, const am_AvailabilityReason_e& availabilityReason);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt32Type();
        }
    };
    
    struct am_SourceType_s: CommonAPI::SerializableStruct {
        am_sourceID_t sourceID;
        std::string name;
        am_Availability_s availability;
        am_sourceClass_t sourceClassID;
    
        am_SourceType_s() = default;
        am_SourceType_s(const am_sourceID_t& sourceID, const std::string& name, const am_Availability_s& availability, const am_sourceClass_t& sourceClassID);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeUInt16Type();
        }
    };
    
    typedef std::vector<am_SourceType_s> am_SourceType_l;
    
    struct am_SinkType_s: CommonAPI::SerializableStruct {
        am_sinkID_t sinkID;
        std::string name;
        am_Availability_s availability;
        am_mainVolume_t volume;
        am_MuteState_e muteState;
        am_sinkClass_t sinkClassID;
    
        am_SinkType_s() = default;
        am_SinkType_s(const am_sinkID_t& sinkID, const std::string& name, const am_Availability_s& availability, const am_mainVolume_t& volume, const am_MuteState_e& muteState, const am_sinkClass_t& sinkClassID);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    
    typedef std::vector<am_SinkType_s> am_SinkType_l;
    
    struct am_ClassProperty_s: CommonAPI::SerializableStruct {
        am_ClassProperty_e classProperty;
        int16_t value;
    
        am_ClassProperty_s() = default;
        am_ClassProperty_s(const am_ClassProperty_e& classProperty, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_ClassProperty_s> am_ClassProperty_l;
    
    struct am_SourceClass_s: CommonAPI::SerializableStruct {
        am_sourceClass_t sourceClassID;
        std::string name;
        am_ClassProperty_l listClassProperties;
    
        am_SourceClass_s() = default;
        am_SourceClass_s(const am_sourceClass_t& sourceClassID, const std::string& name, const am_ClassProperty_l& listClassProperties);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    typedef std::vector<am_SourceClass_s> am_SourceClass_l;
    
    struct am_SinkClass_s: CommonAPI::SerializableStruct {
        am_sinkClass_t sinkClassID;
        std::string name;
        am_ClassProperty_l listClassProperties;
    
        am_SinkClass_s() = default;
        am_SinkClass_s(const am_sinkClass_t& sinkClassID, const std::string& name, const am_ClassProperty_l& listClassProperties);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    typedef std::vector<am_SinkClass_s> am_SinkClass_l;
    
    struct am_NotificationPayload_s: CommonAPI::SerializableStruct {
        am::am_NotificationType_e type;
        int16_t value;
    
        am_NotificationPayload_s() = default;
        am_NotificationPayload_s(const am::am_NotificationType_e& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
};

const char* CommandInterface::getInterfaceId() {
    return "org.genivi.audiomanager.CommandInterface";
}

CommonAPI::Version CommandInterface::getInterfaceVersion() {
    return CommonAPI::Version(0, 1);
}

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_Error_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_Error_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_Error_eComparator {
    inline bool operator()(const am_Error_e& lhs, const am_Error_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_MuteState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_MuteState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_MuteState_eComparator {
    inline bool operator()(const am_MuteState_e& lhs, const am_MuteState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_MainSoundPropertyType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_MainSoundPropertyType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_MainSoundPropertyType_eComparator {
    inline bool operator()(const am_MainSoundPropertyType_e& lhs, const am_MainSoundPropertyType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_SystemPropertyType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_SystemPropertyType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_SystemPropertyType_eComparator {
    inline bool operator()(const am_SystemPropertyType_e& lhs, const am_SystemPropertyType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_ConnectionState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_ConnectionState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_ConnectionState_eComparator {
    inline bool operator()(const am_ConnectionState_e& lhs, const am_ConnectionState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_Availablility_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_Availablility_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_Availablility_eComparator {
    inline bool operator()(const am_Availablility_e& lhs, const am_Availablility_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_AvailabilityReason_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_AvailabilityReason_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_AvailabilityReason_eComparator {
    inline bool operator()(const am_AvailabilityReason_e& lhs, const am_AvailabilityReason_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_ClassProperty_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_ClassProperty_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_ClassProperty_eComparator {
    inline bool operator()(const am_ClassProperty_e& lhs, const am_ClassProperty_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, CommandInterface::am_InterruptState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const CommandInterface::am_InterruptState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct CommandInterface::am_InterruptState_eComparator {
    inline bool operator()(const am_InterruptState_e& lhs, const am_InterruptState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

bool operator==(const CommandInterface::am_MainSoundProperty_s& lhs, const CommandInterface::am_MainSoundProperty_s& rhs);
inline bool operator!=(const CommandInterface::am_MainSoundProperty_s& lhs, const CommandInterface::am_MainSoundProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_SystemProperty_s& lhs, const CommandInterface::am_SystemProperty_s& rhs);
inline bool operator!=(const CommandInterface::am_SystemProperty_s& lhs, const CommandInterface::am_SystemProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_MainConnectionType_s& lhs, const CommandInterface::am_MainConnectionType_s& rhs);
inline bool operator!=(const CommandInterface::am_MainConnectionType_s& lhs, const CommandInterface::am_MainConnectionType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_Availability_s& lhs, const CommandInterface::am_Availability_s& rhs);
inline bool operator!=(const CommandInterface::am_Availability_s& lhs, const CommandInterface::am_Availability_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_SourceType_s& lhs, const CommandInterface::am_SourceType_s& rhs);
inline bool operator!=(const CommandInterface::am_SourceType_s& lhs, const CommandInterface::am_SourceType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_SinkType_s& lhs, const CommandInterface::am_SinkType_s& rhs);
inline bool operator!=(const CommandInterface::am_SinkType_s& lhs, const CommandInterface::am_SinkType_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_ClassProperty_s& lhs, const CommandInterface::am_ClassProperty_s& rhs);
inline bool operator!=(const CommandInterface::am_ClassProperty_s& lhs, const CommandInterface::am_ClassProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_SourceClass_s& lhs, const CommandInterface::am_SourceClass_s& rhs);
inline bool operator!=(const CommandInterface::am_SourceClass_s& lhs, const CommandInterface::am_SourceClass_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_SinkClass_s& lhs, const CommandInterface::am_SinkClass_s& rhs);
inline bool operator!=(const CommandInterface::am_SinkClass_s& lhs, const CommandInterface::am_SinkClass_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CommandInterface::am_NotificationPayload_s& lhs, const CommandInterface::am_NotificationPayload_s& rhs);
inline bool operator!=(const CommandInterface::am_NotificationPayload_s& lhs, const CommandInterface::am_NotificationPayload_s& rhs) {
    return !(lhs == rhs);
}

} // namespace audiomanager
} // namespace genivi
} // namespace org

namespace CommonAPI {
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_Error_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_Error_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_Error_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_Error_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_Error_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_MuteState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_MuteState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_MuteState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_MuteState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_MuteState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_MainSoundPropertyType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_MainSoundPropertyType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_MainSoundPropertyType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_MainSoundPropertyType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_MainSoundPropertyType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_SystemPropertyType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_SystemPropertyType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_SystemPropertyType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_SystemPropertyType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_SystemPropertyType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_ConnectionState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_ConnectionState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_ConnectionState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_ConnectionState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_ConnectionState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_Availablility_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_Availablility_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_Availablility_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_Availablility_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_Availablility_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_AvailabilityReason_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_AvailabilityReason_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_AvailabilityReason_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_AvailabilityReason_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_AvailabilityReason_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_ClassProperty_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_ClassProperty_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_ClassProperty_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_ClassProperty_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_ClassProperty_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::CommandInterface::am_InterruptState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_InterruptState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_InterruptState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::CommandInterface::am_InterruptState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::CommandInterface::am_InterruptState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};

}


namespace std {
    //hashes for types
    //Hash for am_Error_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_Error_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_Error_e& am_Error_e) const {
            return static_cast<int32_t>(am_Error_e);
        }
    };
    //Hash for am_MuteState_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_MuteState_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_MuteState_e& am_MuteState_e) const {
            return static_cast<int32_t>(am_MuteState_e);
        }
    };
    //Hash for am_MainSoundPropertyType_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_MainSoundPropertyType_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_MainSoundPropertyType_e& am_MainSoundPropertyType_e) const {
            return static_cast<int32_t>(am_MainSoundPropertyType_e);
        }
    };
    //Hash for am_SystemPropertyType_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_SystemPropertyType_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_SystemPropertyType_e& am_SystemPropertyType_e) const {
            return static_cast<int32_t>(am_SystemPropertyType_e);
        }
    };
    //Hash for am_ConnectionState_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_ConnectionState_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_ConnectionState_e& am_ConnectionState_e) const {
            return static_cast<int32_t>(am_ConnectionState_e);
        }
    };
    //Hash for am_Availablility_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_Availablility_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_Availablility_e& am_Availablility_e) const {
            return static_cast<int32_t>(am_Availablility_e);
        }
    };
    //Hash for am_AvailabilityReason_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_AvailabilityReason_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_AvailabilityReason_e& am_AvailabilityReason_e) const {
            return static_cast<int32_t>(am_AvailabilityReason_e);
        }
    };
    //Hash for am_ClassProperty_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_ClassProperty_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_ClassProperty_e& am_ClassProperty_e) const {
            return static_cast<int32_t>(am_ClassProperty_e);
        }
    };
    //Hash for am_InterruptState_e
    template<>
    struct hash<org::genivi::audiomanager::CommandInterface::am_InterruptState_e> {
        inline size_t operator()(const org::genivi::audiomanager::CommandInterface::am_InterruptState_e& am_InterruptState_e) const {
            return static_cast<int32_t>(am_InterruptState_e);
        }
    };
    
    //hashes for error types
}

#endif // ORG_GENIVI_AUDIOMANAGER_Command_Interface_H_

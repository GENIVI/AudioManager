/*
* This file was generated by the CommonAPI Generators.
*
 *  Copyright (c) 2012 BMW
 *
 *  \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
 *
 *  \copyright
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
 *  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  For further information see http://www.genivi.org/.
*/
#ifndef ORG_GENIVI_AUDIOMANAGER_am_H_
#define ORG_GENIVI_AUDIOMANAGER_am_H_



#define COMMONAPI_INTERNAL_COMPILATION

#include <CommonAPI/InputStream.h>
#include <CommonAPI/OutputStream.h>
#include <CommonAPI/SerializableStruct.h>
#include <CommonAPI/types.h>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace audiomanager {

namespace am {
    typedef uint16_t am_sourceID_t;
    
    typedef uint16_t am_sinkID_t;
    
    typedef uint16_t am_gatewayID_t;
    
    typedef int16_t gongHandle;
    
    typedef uint16_t am_sourceClass_t;
    
    typedef uint16_t am_sinkClass_t;
    
    typedef int16_t am_volume_t;
    
    typedef int16_t am_mainVolume_t;
    
    typedef uint16_t am_handle_t;
    
    typedef uint16_t am_time_t;
    
    enum class gp_indicatorDirection_e: int32_t {
        INDICATOR_RIGHT = 0x0,
        INDICATOR_LEFT = 0x1,
        INDICATOR_WARNING = 0x2
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct gp_indicatorDirection_eComparator;
    
    enum class am_RampType_e: int32_t {
        RAMP_UNKNOWN = 0x0,
        RAMP_GENIVI_DIRECT = 0x1,
        RAMP_GENIVI_NO_PLOP = 0x2,
        RAMP_GENIVI_EXP_INV = 0x3,
        RAMP_GENIVI_LINEAR = 0x4,
        RAMP_GENIVI_EXP = 0x5,
        RAMP_MAX = 0x6
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_RampType_eComparator;
    
    enum class am_MuteState_e: int32_t {
        MS_UNKNOWN = 0x0,
        MS_MUTED = 0x1,
        MS_UNMUTED = 0x2,
        MS_MAX = 0x3
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_MuteState_eComparator;
    
    enum class am_SourceState_e: int32_t {
        SS_UNKNNOWN = 0x0,
        SS_ON = 0x1,
        SS_OFF = 0x2,
        SS_PAUSED = 0x3,
        SS_MAX = 0x4
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_SourceState_eComparator;
    
    enum class am_Error_e: int32_t {
        E_OK = 0x0,
        E_UNKNOWN = 0x1,
        E_OUT_OF_RANGE = 0x2,
        E_NOT_USED = 0x3,
        E_DATABASE_ERROR = 0x4,
        E_ALREADY_EXISTS = 0x5,
        E_NO_CHANGE = 0x6,
        E_NOT_POSSIBLE = 0x7,
        E_NON_EXISTENT = 0x8,
        E_ABORTED = 0x9,
        E_WRONG_FORMAT = 0xa,
        E_MAX = 0xb
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Error_eComparator;
    
    enum class am_DomainState_e: int32_t {
        DS_UNKNOWN = 0,
        DS_CONTROLLED = 1,
        DS_INDEPENDENT_STARTUP = 2,
        DS_INDEPENDENT_RUNDOWN = 3,
        DS_MAX = 4
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_DomainState_eComparator;
    
    enum class gongType_e: int32_t {
        AT_NUN = 0x1,
        AT_POC = 0x2,
        AT_QUE = 0x3,
        AT_IWA = 0x4,
        AT_WA = 0x5,
        AT_ETC_F = 0x6,
        AT_ETC_F2 = 0x7,
        AT_ETC_ST = 0x8,
        AT_ETC_S = 0x9,
        AT_REV = 0xa,
        AT_ESU = 0xb,
        AT_ESD = 0xc,
        AT_DG = 0xd,
        AT_SG = 0xe,
        AT_IDG = 0xf,
        AT_ION = 0x10,
        AT_IOFF = 0x11,
        AT_FBS = 0x12,
        AT_VFS = 0x13,
        AT_GES = 0x14,
        AT_UEE = 0x15
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct gongType_eComparator;
    
    enum class gp_indicatorStatus_e: int32_t {
        IS_ON = 0x0,
        IS_OFF = 0x1
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct gp_indicatorStatus_eComparator;
    
    enum class gongStatus_e: int32_t {
        NOT_PLAYING = 0x0,
        PLAYING = 0x1,
        INTERRUPTED = 0x2
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct gongStatus_eComparator;
    
    enum class gongError_e: int32_t {
        SUCCESS = 0x0,
        ERROR = 0x1,
        LOW_PRIORITY = 0x2
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct gongError_eComparator;
    
    enum class gongClass_e: int32_t {
        GONGCLASS_1 = 0x1,
        GONGCLASS_2 = 0x2,
        GONGCLASS_PDC = 0x3,
        GONGCLASS_TURN = 0x4,
        GONGCLASS_OBSTACLE = 0x5
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct gongClass_eComparator;
    
    enum class sampleSet_e: int32_t {
        setBMW = 0x0,
        setMini = 0x1,
        setRR = 0x2
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct sampleSet_eComparator;
    
    enum class am_Availability_e: int32_t {
        A_UNKNOWN = 0x0,
        A_AVAILABLE = 0x1,
        A_UNAVAILABLE = 0x2,
        A_MAX = 0x3
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_Availability_eComparator;
    
    enum class am_AvailabilityReason_e: int32_t {
        AR_UNKNOWN = 0x0,
        AR_GENIVI_NEWMEDIA = 0x1,
        AR_GENIVI_SAMEMEDIA = 0x2,
        AR_GENIVI_NOMEDIA = 0x3,
        AR_GENIVI_TEMPERATURE = 0x4,
        AR_GENIVI_VOLTAGE = 0x5,
        AR_GENIVI_ERRORMEDIA = 0x6,
        AR_MAX = 0x7
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_AvailabilityReason_eComparator;
    
    enum class am_InterruptState_e: int32_t {
        IS_UNKNOWN = 0x0,
        IS_OFF = 0x1,
        IS_INTERRUPTED = 0x2,
        IS_MAX = 0x3
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_InterruptState_eComparator;
    
    enum class am_SoundPropertyType_e: int32_t {
        SP_UNKNOWN = 0x0,
        SP_EXAMPLE_TREBLE = 0x1,
        SP_EXAMPLE_MID = 0x2,
        SP_EXAMPLE_BASS = 0x3,
        SP_ENTER_SINKID = 0x4,
        SP_INTERR_SUPERSEEDINGID = 0x5,
        SP_INTERR_OVERLAYID = 0x6,
        SP_PRIORITY = 0x7,
        SP_MAX = 0x8
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_SoundPropertyType_eComparator;
    
    enum class am_ConnectionFormat_e: int32_t {
        CF_UNKNOWN = 0x0,
        CF_GENIVI_MONO = 0x1,
        CF_GENIVI_STEREO = 0x2,
        CF_GENIVI_ANALOG = 0x3,
        CF_GENIVI_AUTO = 0x4,
        CF_MAX = 0x5
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_ConnectionFormat_eComparator;
    
    typedef std::vector<am_ConnectionFormat_e> am_ConnectionFormat_L;
    
    enum class am_MainSoundPropertyType_e: int32_t {
        MSP_UNKNOWN = 0x0,
        MSP_EXAMPLE_TREBLE = 0x1,
        MSP_EXAMPLE_MID = 0x2,
        MSP_EXAMPLE_BASS = 0x3,
        MSP_SOURCE_TYPE = 0x4,
        MSP_MAX = 0x5
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_MainSoundPropertyType_eComparator;
    
    enum class am_NotificationType_e: int32_t {
        NT_UNKNOWN = 0x0,
        NT_LOUDNESS = 0x1,
        NT_MAX = 0x2
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_NotificationType_eComparator;
    
    enum class am_NotificationStatus_e: int32_t {
        NS_UNKNOWN = 0x0,
        NS_OFF = 0x1,
        NS_PERIODIC = 0x2,
        NS_MINIMUM = 0x3,
        NS_MAXIMUM = 0x4,
        NS_CHANGE = 0x5,
        NS_MAX = 0x6
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct am_NotificationStatus_eComparator;
    
    struct distanceInformation_s: CommonAPI::SerializableStruct {
        int32_t FrontLeft;
        int32_t FrontRight;
        int32_t RearLeft;
        int32_t RearRight;
    
        distanceInformation_s() = default;
        distanceInformation_s(const int32_t& FrontLeft, const int32_t& FrontRight, const int32_t& RearLeft, const int32_t& RearRight);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt32Type();
        }
    };
    
    struct sampleNames_s: CommonAPI::SerializableStruct {
        sampleSet_e sample;
        std::string sampleName;
    
        sampleNames_s() = default;
        sampleNames_s(const sampleSet_e& sample, const std::string& sampleName);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeStringType();
        }
    };
    
    typedef std::vector<sampleNames_s> listSampleNamesL;
    
    typedef uint16_t am_domainID_t;
    
    struct am_Domain_s: CommonAPI::SerializableStruct {
        am_domainID_t domainID;
        std::string name;
        std::string busname;
        std::string nodename;
        bool early;
        bool complete;
        am_DomainState_e state;
    
        am_Domain_s() = default;
        am_Domain_s(const am_domainID_t& domainID, const std::string& name, const std::string& busname, const std::string& nodename, const bool& early, const bool& complete, const am_DomainState_e& state);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeBoolType();
            typeOutputStream.writeBoolType();
            typeOutputStream.writeInt32Type();
        }
    };
    
    struct notificationPayload_s: CommonAPI::SerializableStruct {
        int16_t type;
        int16_t payload;
    
        notificationPayload_s() = default;
        notificationPayload_s(const int16_t& type, const int16_t& payload);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    struct am_Availability_s: CommonAPI::SerializableStruct {
        am_Availability_e availability;
        am_AvailabilityReason_e availabilityReason;
    
        am_Availability_s() = default;
        am_Availability_s(const am_Availability_e& availability, const am_AvailabilityReason_e& availabilityReason);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt32Type();
        }
    };
    
    struct am_SoundProperty_s: CommonAPI::SerializableStruct {
        am_SoundPropertyType_e type;
        int16_t value;
    
        am_SoundProperty_s() = default;
        am_SoundProperty_s(const am_SoundPropertyType_e& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_SoundProperty_s> am_SoundProperty_L;
    
    struct am_MainSoundProperty_s: CommonAPI::SerializableStruct {
        am_MainSoundPropertyType_e type;
        int16_t value;
    
        am_MainSoundProperty_s() = default;
        am_MainSoundProperty_s(const am_MainSoundPropertyType_e& type, const int16_t& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_MainSoundProperty_s> am_MainSoundProperty_L;
    
    struct am_NotificationConfiguration_s: CommonAPI::SerializableStruct {
        am_NotificationType_e type;
        am_NotificationStatus_e status;
        int16_t parameter;
    
        am_NotificationConfiguration_s() = default;
        am_NotificationConfiguration_s(const am_NotificationType_e& type, const am_NotificationStatus_e& status, const int16_t& parameter);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
        }
    };
    
    typedef std::vector<am_NotificationConfiguration_s> am_NotificationConfiguration_L;
    
    typedef std::vector<bool> bool_L;
    
    struct sourceData_s: CommonAPI::SerializableStruct {
        am_sourceID_t sourceID;
        am_domainID_t domainID;
        std::string name;
        am_sourceClass_t sourceClassID;
        am_SourceState_e sourceState;
        am_volume_t volume;
        bool visible;
        am_Availability_s available;
        am_InterruptState_e interruptState;
        am_SoundProperty_L listSoundProperties;
        am_ConnectionFormat_L listConnectionFormats;
        am_MainSoundProperty_L listMainSoundProperties;
        am_NotificationConfiguration_L listMainNotificationConfigurations;
        am_NotificationConfiguration_L listNotificationConfigurations;
    
        sourceData_s() = default;
        sourceData_s(const am_sourceID_t& sourceID, const am_domainID_t& domainID, const std::string& name, const am_sourceClass_t& sourceClassID, const am_SourceState_e& sourceState, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_InterruptState_e& interruptState, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeBoolType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    struct sinkData_s: CommonAPI::SerializableStruct {
        am_sinkID_t sinkID;
        std::string name;
        am_domainID_t domainID;
        am_sinkClass_t sinkClassID;
        am_volume_t volume;
        bool visible;
        am_Availability_s available;
        am_MuteState_e muteState;
        am_mainVolume_t mainVolume;
        am_SoundProperty_L listSoundProperties;
        am_ConnectionFormat_L listConnectionFormats;
        am_MainSoundProperty_L listMainSoundProperties;
        am_NotificationConfiguration_L listMainNotificationConfigurations;
        am_NotificationConfiguration_L listNotificationConfigurations;
    
        sinkData_s() = default;
        sinkData_s(const am_sinkID_t& sinkID, const std::string& name, const am_domainID_t& domainID, const am_sinkClass_t& sinkClassID, const am_volume_t& volume, const bool& visible, const am_Availability_s& available, const am_MuteState_e& muteState, const am_mainVolume_t& mainVolume, const am_SoundProperty_L& listSoundProperties, const am_ConnectionFormat_L& listConnectionFormats, const am_MainSoundProperty_L& listMainSoundProperties, const am_NotificationConfiguration_L& listMainNotificationConfigurations, const am_NotificationConfiguration_L& listNotificationConfigurations);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.writeBoolType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeInt32Type();typeOutputStream.writeInt16Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
        }
    };
    
    struct am_Gateway_s: CommonAPI::SerializableStruct {
        am_gatewayID_t gatewayID;
        std::string name;
        am_sinkID_t sinkID;
        am_sourceID_t sourceID;
        am_domainID_t domainSinkID;
        am_domainID_t domainSourceID;
        am_domainID_t controlDomainID;
        am_ConnectionFormat_L listSourceFormats;
        am_ConnectionFormat_L listSinkFormats;
        bool_L convertionMatrix;
    
        am_Gateway_s() = default;
        am_Gateway_s(const am_gatewayID_t& gatewayID, const std::string& name, const am_sinkID_t& sinkID, const am_sourceID_t& sourceID, const am_domainID_t& domainSinkID, const am_domainID_t& domainSourceID, const am_domainID_t& controlDomainID, const am_ConnectionFormat_L& listSourceFormats, const am_ConnectionFormat_L& listSinkFormats, const bool_L& convertionMatrix);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeBoolType();
            typeOutputStream.endWriteVectorType();
        }
    };
    

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, gp_indicatorDirection_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const gp_indicatorDirection_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct gp_indicatorDirection_eComparator {
    inline bool operator()(const gp_indicatorDirection_e& lhs, const gp_indicatorDirection_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_RampType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_RampType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_RampType_eComparator {
    inline bool operator()(const am_RampType_e& lhs, const am_RampType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_MuteState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_MuteState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_MuteState_eComparator {
    inline bool operator()(const am_MuteState_e& lhs, const am_MuteState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_SourceState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_SourceState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_SourceState_eComparator {
    inline bool operator()(const am_SourceState_e& lhs, const am_SourceState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Error_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Error_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_Error_eComparator {
    inline bool operator()(const am_Error_e& lhs, const am_Error_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_DomainState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_DomainState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_DomainState_eComparator {
    inline bool operator()(const am_DomainState_e& lhs, const am_DomainState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, gongType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const gongType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct gongType_eComparator {
    inline bool operator()(const gongType_e& lhs, const gongType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, gp_indicatorStatus_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const gp_indicatorStatus_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct gp_indicatorStatus_eComparator {
    inline bool operator()(const gp_indicatorStatus_e& lhs, const gp_indicatorStatus_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, gongStatus_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const gongStatus_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct gongStatus_eComparator {
    inline bool operator()(const gongStatus_e& lhs, const gongStatus_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, gongError_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const gongError_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct gongError_eComparator {
    inline bool operator()(const gongError_e& lhs, const gongError_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, gongClass_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const gongClass_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct gongClass_eComparator {
    inline bool operator()(const gongClass_e& lhs, const gongClass_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, sampleSet_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const sampleSet_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct sampleSet_eComparator {
    inline bool operator()(const sampleSet_e& lhs, const sampleSet_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_Availability_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_Availability_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_Availability_eComparator {
    inline bool operator()(const am_Availability_e& lhs, const am_Availability_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_AvailabilityReason_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_AvailabilityReason_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_AvailabilityReason_eComparator {
    inline bool operator()(const am_AvailabilityReason_e& lhs, const am_AvailabilityReason_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_InterruptState_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_InterruptState_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_InterruptState_eComparator {
    inline bool operator()(const am_InterruptState_e& lhs, const am_InterruptState_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_SoundPropertyType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_SoundPropertyType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_SoundPropertyType_eComparator {
    inline bool operator()(const am_SoundPropertyType_e& lhs, const am_SoundPropertyType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_ConnectionFormat_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_ConnectionFormat_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_ConnectionFormat_eComparator {
    inline bool operator()(const am_ConnectionFormat_e& lhs, const am_ConnectionFormat_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_MainSoundPropertyType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_MainSoundPropertyType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_MainSoundPropertyType_eComparator {
    inline bool operator()(const am_MainSoundPropertyType_e& lhs, const am_MainSoundPropertyType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_NotificationType_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_NotificationType_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_NotificationType_eComparator {
    inline bool operator()(const am_NotificationType_e& lhs, const am_NotificationType_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, am_NotificationStatus_e& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const am_NotificationStatus_e& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct am_NotificationStatus_eComparator {
    inline bool operator()(const am_NotificationStatus_e& lhs, const am_NotificationStatus_e& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

bool operator==(const distanceInformation_s& lhs, const distanceInformation_s& rhs);
inline bool operator!=(const distanceInformation_s& lhs, const distanceInformation_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const sampleNames_s& lhs, const sampleNames_s& rhs);
inline bool operator!=(const sampleNames_s& lhs, const sampleNames_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Domain_s& lhs, const am_Domain_s& rhs);
inline bool operator!=(const am_Domain_s& lhs, const am_Domain_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const notificationPayload_s& lhs, const notificationPayload_s& rhs);
inline bool operator!=(const notificationPayload_s& lhs, const notificationPayload_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Availability_s& lhs, const am_Availability_s& rhs);
inline bool operator!=(const am_Availability_s& lhs, const am_Availability_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs);
inline bool operator!=(const am_SoundProperty_s& lhs, const am_SoundProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs);
inline bool operator!=(const am_MainSoundProperty_s& lhs, const am_MainSoundProperty_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs);
inline bool operator!=(const am_NotificationConfiguration_s& lhs, const am_NotificationConfiguration_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const sourceData_s& lhs, const sourceData_s& rhs);
inline bool operator!=(const sourceData_s& lhs, const sourceData_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const sinkData_s& lhs, const sinkData_s& rhs);
inline bool operator!=(const sinkData_s& lhs, const sinkData_s& rhs) {
    return !(lhs == rhs);
}
bool operator==(const am_Gateway_s& lhs, const am_Gateway_s& rhs);
inline bool operator!=(const am_Gateway_s& lhs, const am_Gateway_s& rhs) {
    return !(lhs == rhs);
}


static inline const char* getTypeCollectionName() {
    return "org.genivi.audiomanager.am";
}


} // namespace am

} // namespace audiomanager
} // namespace genivi
} // namespace org

namespace CommonAPI {
	
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::gp_indicatorDirection_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::gp_indicatorDirection_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::gp_indicatorDirection_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::gp_indicatorDirection_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::gp_indicatorDirection_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_RampType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_RampType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_RampType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_RampType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_RampType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_MuteState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_MuteState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_MuteState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_MuteState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_MuteState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_SourceState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_SourceState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_SourceState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_SourceState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_SourceState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_Error_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_Error_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_Error_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_Error_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_Error_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_DomainState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_DomainState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_DomainState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_DomainState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_DomainState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::gongType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::gongType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::gongType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::gongType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::gongType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::gp_indicatorStatus_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::gp_indicatorStatus_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::gp_indicatorStatus_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::gp_indicatorStatus_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::gp_indicatorStatus_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::gongStatus_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::gongStatus_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::gongStatus_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::gongStatus_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::gongStatus_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::gongError_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::gongError_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::gongError_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::gongError_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::gongError_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::gongClass_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::gongClass_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::gongClass_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::gongClass_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::gongClass_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::sampleSet_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::sampleSet_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::sampleSet_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::sampleSet_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::sampleSet_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_Availability_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_Availability_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_Availability_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_Availability_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_Availability_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_AvailabilityReason_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_AvailabilityReason_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_AvailabilityReason_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_AvailabilityReason_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_AvailabilityReason_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_InterruptState_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_InterruptState_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_InterruptState_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_InterruptState_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_InterruptState_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_SoundPropertyType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_SoundPropertyType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_SoundPropertyType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_SoundPropertyType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_SoundPropertyType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_ConnectionFormat_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_ConnectionFormat_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_ConnectionFormat_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_ConnectionFormat_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_ConnectionFormat_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_MainSoundPropertyType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_MainSoundPropertyType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_MainSoundPropertyType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_MainSoundPropertyType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_MainSoundPropertyType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_NotificationType_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_NotificationType_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_NotificationType_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_NotificationType_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_NotificationType_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<org::genivi::audiomanager::am::am_NotificationStatus_e> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<org::genivi::audiomanager::am::am_NotificationStatus_e> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::audiomanager::am::am_NotificationStatus_e>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<org::genivi::audiomanager::am::am_NotificationStatus_e> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::audiomanager::am::am_NotificationStatus_e>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	
}


namespace std {
    //Hash for gp_indicatorDirection_e
    template<>
    struct hash<org::genivi::audiomanager::am::gp_indicatorDirection_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::gp_indicatorDirection_e& gp_indicatorDirection_e) const {
            return static_cast<int32_t>(gp_indicatorDirection_e);
        }
    };
    //Hash for am_RampType_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_RampType_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_RampType_e& am_RampType_e) const {
            return static_cast<int32_t>(am_RampType_e);
        }
    };
    //Hash for am_MuteState_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_MuteState_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_MuteState_e& am_MuteState_e) const {
            return static_cast<int32_t>(am_MuteState_e);
        }
    };
    //Hash for am_SourceState_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_SourceState_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_SourceState_e& am_SourceState_e) const {
            return static_cast<int32_t>(am_SourceState_e);
        }
    };
    //Hash for am_Error_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_Error_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_Error_e& am_Error_e) const {
            return static_cast<int32_t>(am_Error_e);
        }
    };
    //Hash for am_DomainState_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_DomainState_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_DomainState_e& am_DomainState_e) const {
            return static_cast<int32_t>(am_DomainState_e);
        }
    };
    //Hash for gongType_e
    template<>
    struct hash<org::genivi::audiomanager::am::gongType_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::gongType_e& gongType_e) const {
            return static_cast<int32_t>(gongType_e);
        }
    };
    //Hash for gp_indicatorStatus_e
    template<>
    struct hash<org::genivi::audiomanager::am::gp_indicatorStatus_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::gp_indicatorStatus_e& gp_indicatorStatus_e) const {
            return static_cast<int32_t>(gp_indicatorStatus_e);
        }
    };
    //Hash for gongStatus_e
    template<>
    struct hash<org::genivi::audiomanager::am::gongStatus_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::gongStatus_e& gongStatus_e) const {
            return static_cast<int32_t>(gongStatus_e);
        }
    };
    //Hash for gongError_e
    template<>
    struct hash<org::genivi::audiomanager::am::gongError_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::gongError_e& gongError_e) const {
            return static_cast<int32_t>(gongError_e);
        }
    };
    //Hash for gongClass_e
    template<>
    struct hash<org::genivi::audiomanager::am::gongClass_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::gongClass_e& gongClass_e) const {
            return static_cast<int32_t>(gongClass_e);
        }
    };
    //Hash for sampleSet_e
    template<>
    struct hash<org::genivi::audiomanager::am::sampleSet_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::sampleSet_e& sampleSet_e) const {
            return static_cast<int32_t>(sampleSet_e);
        }
    };
    //Hash for am_Availability_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_Availability_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_Availability_e& am_Availability_e) const {
            return static_cast<int32_t>(am_Availability_e);
        }
    };
    //Hash for am_AvailabilityReason_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_AvailabilityReason_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_AvailabilityReason_e& am_AvailabilityReason_e) const {
            return static_cast<int32_t>(am_AvailabilityReason_e);
        }
    };
    //Hash for am_InterruptState_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_InterruptState_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_InterruptState_e& am_InterruptState_e) const {
            return static_cast<int32_t>(am_InterruptState_e);
        }
    };
    //Hash for am_SoundPropertyType_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_SoundPropertyType_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_SoundPropertyType_e& am_SoundPropertyType_e) const {
            return static_cast<int32_t>(am_SoundPropertyType_e);
        }
    };
    //Hash for am_ConnectionFormat_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_ConnectionFormat_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_ConnectionFormat_e& am_ConnectionFormat_e) const {
            return static_cast<int32_t>(am_ConnectionFormat_e);
        }
    };
    //Hash for am_MainSoundPropertyType_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_MainSoundPropertyType_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_MainSoundPropertyType_e& am_MainSoundPropertyType_e) const {
            return static_cast<int32_t>(am_MainSoundPropertyType_e);
        }
    };
    //Hash for am_NotificationType_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_NotificationType_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_NotificationType_e& am_NotificationType_e) const {
            return static_cast<int32_t>(am_NotificationType_e);
        }
    };
    //Hash for am_NotificationStatus_e
    template<>
    struct hash<org::genivi::audiomanager::am::am_NotificationStatus_e> {
        inline size_t operator()(const org::genivi::audiomanager::am::am_NotificationStatus_e& am_NotificationStatus_e) const {
            return static_cast<int32_t>(am_NotificationStatus_e);
        }
    };
}

#endif // ORG_GENIVI_AUDIOMANAGER_am_H_

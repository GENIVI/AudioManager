/*
* This file was generated by the CommonAPI Generators.
*
 *  Copyright (c) 2012 BMW
 *
 *  \author Aleksandar Donchev, aleksander.donchev@partner.bmw.de BMW 2013
 *
 *  \copyright
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
 *  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  For further information see http://www.genivi.org/.
*/
#ifndef ORG_GENIVI_AUDIOMANAGER_Command_Interface_PROXY_H_
#define ORG_GENIVI_AUDIOMANAGER_Command_Interface_PROXY_H_

#include "CommandInterfaceProxyBase.h"

#define COMMONAPI_INTERNAL_COMPILATION


#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace audiomanager {

template <typename ... _AttributeExtensions>
class CommandInterfaceProxy: virtual public CommandInterface, virtual public CommandInterfaceProxyBase, public _AttributeExtensions... {
 public:
    CommandInterfaceProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~CommandInterfaceProxy();


    /// Returns the wrapper class that provides access to the broadcast NumberOfMainConnectionsChanged.
    virtual NumberOfMainConnectionsChangedEvent& getNumberOfMainConnectionsChangedEvent() {
        return delegate_->getNumberOfMainConnectionsChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast MainConnectionStateChanged.
    virtual MainConnectionStateChangedEvent& getMainConnectionStateChangedEvent() {
        return delegate_->getMainConnectionStateChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast NumberOfSourceClassesChanged.
    virtual NumberOfSourceClassesChangedEvent& getNumberOfSourceClassesChangedEvent() {
        return delegate_->getNumberOfSourceClassesChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SourceAdded.
    virtual SourceAddedEvent& getSourceAddedEvent() {
        return delegate_->getSourceAddedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SourceRemoved.
    virtual SourceRemovedEvent& getSourceRemovedEvent() {
        return delegate_->getSourceRemovedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast MainSourceSoundPropertyChanged.
    virtual MainSourceSoundPropertyChangedEvent& getMainSourceSoundPropertyChangedEvent() {
        return delegate_->getMainSourceSoundPropertyChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SourceAvailabilityChanged.
    virtual SourceAvailabilityChangedEvent& getSourceAvailabilityChangedEvent() {
        return delegate_->getSourceAvailabilityChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast NumberOfSinkClassesChanged.
    virtual NumberOfSinkClassesChangedEvent& getNumberOfSinkClassesChangedEvent() {
        return delegate_->getNumberOfSinkClassesChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SinkAdded.
    virtual SinkAddedEvent& getSinkAddedEvent() {
        return delegate_->getSinkAddedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SinkRemoved.
    virtual SinkRemovedEvent& getSinkRemovedEvent() {
        return delegate_->getSinkRemovedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast MainSinkSoundPropertyChanged.
    virtual MainSinkSoundPropertyChangedEvent& getMainSinkSoundPropertyChangedEvent() {
        return delegate_->getMainSinkSoundPropertyChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SinkAvailabilityChanged.
    virtual SinkAvailabilityChangedEvent& getSinkAvailabilityChangedEvent() {
        return delegate_->getSinkAvailabilityChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast VolumeChanged.
    virtual VolumeChangedEvent& getVolumeChangedEvent() {
        return delegate_->getVolumeChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SinkMuteStateChanged.
    virtual SinkMuteStateChangedEvent& getSinkMuteStateChangedEvent() {
        return delegate_->getSinkMuteStateChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SystemPropertyChanged.
    virtual SystemPropertyChangedEvent& getSystemPropertyChangedEvent() {
        return delegate_->getSystemPropertyChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast TimingInformationChanged.
    virtual TimingInformationChangedEvent& getTimingInformationChangedEvent() {
        return delegate_->getTimingInformationChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SinkUpdated.
    virtual SinkUpdatedEvent& getSinkUpdatedEvent() {
        return delegate_->getSinkUpdatedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SourceUpdated.
    virtual SourceUpdatedEvent& getSourceUpdatedEvent() {
        return delegate_->getSourceUpdatedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SinkNotification.
    virtual SinkNotificationEvent& getSinkNotificationEvent() {
        return delegate_->getSinkNotificationEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast SourceNotification.
    virtual SourceNotificationEvent& getSourceNotificationEvent() {
        return delegate_->getSourceNotificationEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast MainSinkNotificationConfigurationChanged.
    virtual MainSinkNotificationConfigurationChangedEvent& getMainSinkNotificationConfigurationChangedEvent() {
        return delegate_->getMainSinkNotificationConfigurationChangedEvent();
    }

    /// Returns the wrapper class that provides access to the broadcast MainSourceNotificationConfigurationChanged.
    virtual MainSourceNotificationConfigurationChangedEvent& getMainSourceNotificationConfigurationChangedEvent() {
        return delegate_->getMainSourceNotificationConfigurationChangedEvent();
    }



    /**
     * Calls Connect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void Connect(const CommandInterface::am_sourceID_t& sourceID, const CommandInterface::am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_mainConnectionID_t& mainConnectionID);
    /**
     * Calls Connect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ConnectAsync(const CommandInterface::am_sourceID_t& sourceID, const CommandInterface::am_sinkID_t& sinkID, ConnectAsyncCallback callback);

    /**
     * Calls Disconnect with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void Disconnect(const CommandInterface::am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result);
    /**
     * Calls Disconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> DisconnectAsync(const CommandInterface::am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback);

    /**
     * Calls SetVolume with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void SetVolume(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result);
    /**
     * Calls SetVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetVolumeAsync(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_mainVolume_t& volume, SetVolumeAsyncCallback callback);

    /**
     * Calls VolumeStep with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void VolumeStep(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_mainVolume_t& volumeStep, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result);
    /**
     * Calls VolumeStep with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> VolumeStepAsync(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_mainVolume_t& volumeStep, VolumeStepAsyncCallback callback);

    /**
     * Calls SetSinkMuteState with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void SetSinkMuteState(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result);
    /**
     * Calls SetSinkMuteState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetSinkMuteStateAsync(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback);

    /**
     * Calls SetMainSinkSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void SetMainSinkSoundProperty(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result);
    /**
     * Calls SetMainSinkSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetMainSinkSoundPropertyAsync(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback);

    /**
     * Calls SetMainSourceSoundProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void SetMainSourceSoundProperty(const CommandInterface::am_sourceID_t& sourceID, const CommandInterface::am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result);
    /**
     * Calls SetMainSourceSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetMainSourceSoundPropertyAsync(const CommandInterface::am_sourceID_t& sourceID, const CommandInterface::am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback);

    /**
     * Calls SetSystemProperty with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void SetSystemProperty(const CommandInterface::am_SystemProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result);
    /**
     * Calls SetSystemProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetSystemPropertyAsync(const CommandInterface::am_SystemProperty_s& soundProperty, SetSystemPropertyAsyncCallback callback);

    /**
     * Calls GetListMainConnections with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetListMainConnections(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_MainConnectionType_l& listConnections);
    /**
     * Calls GetListMainConnections with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback);

    /**
     * Calls GetListMainSinks with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetListMainSinks(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SinkType_l& listMainSinks);
    /**
     * Calls GetListMainSinks with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListMainSinksAsync(GetListMainSinksAsyncCallback callback);

    /**
     * Calls GetListMainSources with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetListMainSources(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SourceType_l& listMainSources);
    /**
     * Calls GetListMainSources with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListMainSourcesAsync(GetListMainSourcesAsyncCallback callback);

    /**
     * Calls GetListMainSinkSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetListMainSinkSoundProperties(const CommandInterface::am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_MainSoundProperty_l& listSoundProperties);
    /**
     * Calls GetListMainSinkSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListMainSinkSoundPropertiesAsync(const CommandInterface::am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback);

    /**
     * Calls GetListMainSourceSoundProperties with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetListMainSourceSoundProperties(const CommandInterface::am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_MainSoundProperty_l& listSourceProperties);
    /**
     * Calls GetListMainSourceSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListMainSourceSoundPropertiesAsync(const CommandInterface::am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback);

    /**
     * Calls GetListSourceClasses with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetListSourceClasses(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SourceClass_l& listSourceClasses);
    /**
     * Calls GetListSourceClasses with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListSourceClassesAsync(GetListSourceClassesAsyncCallback callback);

    /**
     * Calls GetListSinkClasses with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetListSinkClasses(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SinkClass_l& listSinkClasses);
    /**
     * Calls GetListSinkClasses with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListSinkClassesAsync(GetListSinkClassesAsyncCallback callback);

    /**
     * Calls GetListSystemProperties with synchronous semantics.
     * 
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetListSystemProperties(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SystemProperty_l& listSystemProperties);
    /**
     * Calls GetListSystemProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback);

    /**
     * Calls GetTimingInformation with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void GetTimingInformation(const CommandInterface::am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_timeSync_t& delay);
    /**
     * Calls GetTimingInformation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetTimingInformationAsync(const CommandInterface::am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback);

    /// Returns the CommonAPI address of the remote partner this proxy communicates with.
    virtual std::string getAddress() const;

    /// Returns the domain of the remote partner this proxy communicates with.
    virtual const std::string& getDomain() const;

    /// Returns the service ID of the remote partner this proxy communicates with.
    virtual const std::string& getServiceId() const;

    /// Returns the instance ID of the remote partner this proxy communicates with.
    virtual const std::string& getInstanceId() const;

    /// Returns true if the remote partner for this proxy is available.
    virtual bool isAvailable() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<CommandInterfaceProxyBase> delegate_;
};


//
// CommandInterfaceProxy Implementation
//
template <typename ... _AttributeExtensions>
CommandInterfaceProxy<_AttributeExtensions...>::CommandInterfaceProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        delegate_(std::dynamic_pointer_cast<CommandInterfaceProxyBase>(delegate)),
        _AttributeExtensions(*(std::dynamic_pointer_cast<CommandInterfaceProxyBase>(delegate)))... {
}

template <typename ... _AttributeExtensions>
CommandInterfaceProxy<_AttributeExtensions...>::~CommandInterfaceProxy() {
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::Connect(const CommandInterface::am_sourceID_t& sourceID, const CommandInterface::am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_mainConnectionID_t& mainConnectionID) {
    delegate_->Connect(sourceID, sinkID, callStatus, result, mainConnectionID);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::ConnectAsync(const CommandInterface::am_sourceID_t& sourceID, const CommandInterface::am_sinkID_t& sinkID, ConnectAsyncCallback callback) {
    return delegate_->ConnectAsync(sourceID, sinkID, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::Disconnect(const CommandInterface::am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result) {
    delegate_->Disconnect(mainConnectionID, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::DisconnectAsync(const CommandInterface::am_mainConnectionID_t& mainConnectionID, DisconnectAsyncCallback callback) {
    return delegate_->DisconnectAsync(mainConnectionID, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::SetVolume(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_mainVolume_t& volume, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result) {
    delegate_->SetVolume(sinkID, volume, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::SetVolumeAsync(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_mainVolume_t& volume, SetVolumeAsyncCallback callback) {
    return delegate_->SetVolumeAsync(sinkID, volume, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::VolumeStep(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_mainVolume_t& volumeStep, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result) {
    delegate_->VolumeStep(sinkID, volumeStep, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::VolumeStepAsync(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_mainVolume_t& volumeStep, VolumeStepAsyncCallback callback) {
    return delegate_->VolumeStepAsync(sinkID, volumeStep, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::SetSinkMuteState(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_MuteState_e& muteState, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result) {
    delegate_->SetSinkMuteState(sinkID, muteState, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::SetSinkMuteStateAsync(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_MuteState_e& muteState, SetSinkMuteStateAsyncCallback callback) {
    return delegate_->SetSinkMuteStateAsync(sinkID, muteState, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::SetMainSinkSoundProperty(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result) {
    delegate_->SetMainSinkSoundProperty(sinkID, soundProperty, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::SetMainSinkSoundPropertyAsync(const CommandInterface::am_sinkID_t& sinkID, const CommandInterface::am_MainSoundProperty_s& soundProperty, SetMainSinkSoundPropertyAsyncCallback callback) {
    return delegate_->SetMainSinkSoundPropertyAsync(sinkID, soundProperty, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::SetMainSourceSoundProperty(const CommandInterface::am_sourceID_t& sourceID, const CommandInterface::am_MainSoundProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result) {
    delegate_->SetMainSourceSoundProperty(sourceID, soundProperty, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::SetMainSourceSoundPropertyAsync(const CommandInterface::am_sourceID_t& sourceID, const CommandInterface::am_MainSoundProperty_s& soundProperty, SetMainSourceSoundPropertyAsyncCallback callback) {
    return delegate_->SetMainSourceSoundPropertyAsync(sourceID, soundProperty, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::SetSystemProperty(const CommandInterface::am_SystemProperty_s& soundProperty, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result) {
    delegate_->SetSystemProperty(soundProperty, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::SetSystemPropertyAsync(const CommandInterface::am_SystemProperty_s& soundProperty, SetSystemPropertyAsyncCallback callback) {
    return delegate_->SetSystemPropertyAsync(soundProperty, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetListMainConnections(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_MainConnectionType_l& listConnections) {
    delegate_->GetListMainConnections(callStatus, result, listConnections);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetListMainConnectionsAsync(GetListMainConnectionsAsyncCallback callback) {
    return delegate_->GetListMainConnectionsAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetListMainSinks(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SinkType_l& listMainSinks) {
    delegate_->GetListMainSinks(callStatus, result, listMainSinks);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetListMainSinksAsync(GetListMainSinksAsyncCallback callback) {
    return delegate_->GetListMainSinksAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetListMainSources(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SourceType_l& listMainSources) {
    delegate_->GetListMainSources(callStatus, result, listMainSources);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetListMainSourcesAsync(GetListMainSourcesAsyncCallback callback) {
    return delegate_->GetListMainSourcesAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetListMainSinkSoundProperties(const CommandInterface::am_sinkID_t& sinkID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_MainSoundProperty_l& listSoundProperties) {
    delegate_->GetListMainSinkSoundProperties(sinkID, callStatus, result, listSoundProperties);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetListMainSinkSoundPropertiesAsync(const CommandInterface::am_sinkID_t& sinkID, GetListMainSinkSoundPropertiesAsyncCallback callback) {
    return delegate_->GetListMainSinkSoundPropertiesAsync(sinkID, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetListMainSourceSoundProperties(const CommandInterface::am_sourceID_t& sourceID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_MainSoundProperty_l& listSourceProperties) {
    delegate_->GetListMainSourceSoundProperties(sourceID, callStatus, result, listSourceProperties);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetListMainSourceSoundPropertiesAsync(const CommandInterface::am_sourceID_t& sourceID, GetListMainSourceSoundPropertiesAsyncCallback callback) {
    return delegate_->GetListMainSourceSoundPropertiesAsync(sourceID, callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetListSourceClasses(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SourceClass_l& listSourceClasses) {
    delegate_->GetListSourceClasses(callStatus, result, listSourceClasses);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetListSourceClassesAsync(GetListSourceClassesAsyncCallback callback) {
    return delegate_->GetListSourceClassesAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetListSinkClasses(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SinkClass_l& listSinkClasses) {
    delegate_->GetListSinkClasses(callStatus, result, listSinkClasses);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetListSinkClassesAsync(GetListSinkClassesAsyncCallback callback) {
    return delegate_->GetListSinkClassesAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetListSystemProperties(CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_SystemProperty_l& listSystemProperties) {
    delegate_->GetListSystemProperties(callStatus, result, listSystemProperties);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback callback) {
    return delegate_->GetListSystemPropertiesAsync(callback);
}

template <typename ... _AttributeExtensions>
void CommandInterfaceProxy<_AttributeExtensions...>::GetTimingInformation(const CommandInterface::am_mainConnectionID_t& mainConnectionID, CommonAPI::CallStatus& callStatus, CommandInterface::am_Error_e& result, CommandInterface::am_timeSync_t& delay) {
    delegate_->GetTimingInformation(mainConnectionID, callStatus, result, delay);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandInterfaceProxy<_AttributeExtensions...>::GetTimingInformationAsync(const CommandInterface::am_mainConnectionID_t& mainConnectionID, GetTimingInformationAsyncCallback callback) {
    return delegate_->GetTimingInformationAsync(mainConnectionID, callback);
}


template <typename ... _AttributeExtensions>
std::string CommandInterfaceProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& CommandInterfaceProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& CommandInterfaceProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& CommandInterfaceProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool CommandInterfaceProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& CommandInterfaceProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& CommandInterfaceProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}

} // namespace audiomanager
} // namespace genivi
} // namespace org



#endif // ORG_GENIVI_AUDIOMANAGER_Command_Interface_PROXY_H_

/**
 * Copyright (C) 2012 - 2014, BMW AG
 *
 * This file is part of GENIVI Project AudioManager.
 *
 * Contributions are licensed to the GENIVI Alliance under one or more
 * Contribution License Agreements.
 *
 * \copyright
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
 * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 *
 * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
 *
 * \file
 * For further information see http://projects.genivi.org/audio-manager
 *
 * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
 * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
 */
#if !defined(EA_68F78255_5C2E_4b32_A21C_E8CEDD4641B3__INCLUDED_)
#define EA_68F78255_5C2E_4b32_A21C_E8CEDD4641B3__INCLUDED_

#include <vector>
#include <string>
#include "audiomanagertypes.h"

namespace am {
class IAmCommandReceive;
}

#include "IAmCommandReceive.h"
#include "audiomanagertypes.h"

#define CommandSendVersion "2.0" 
namespace am {

/**
 * This interface handles all communication from the AudioManagerDaemon towards
 * the system. It is designed in such a way that only callbacks with no return
 * types are implemented. So when the CommandInterfacePlugins are designed in such
 * a way that they broadcast signals to any node who is interested in the
 * particular information (like signals on Dbus for example), more information can
 * be retrieved via the CommandReceiveInterface.
 * There are two rules that have to be kept in mind when implementing against this
 * interface:\n
 * \warning
 * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
 * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
 * CALL THAT EXPECTS A RETURN VALUE.\n
 * \details
 * Violation these rules may lead to unexpected behavior! Nevertheless you can
 * implement thread safe by using the deferred-call pattern described on the wiki
 * which also helps to implement calls that are forbidden.\n
 * For more information, please check CAmSerializer
 */
class IAmCommandSend
{

public:
	IAmCommandSend() {

	}

	virtual ~IAmCommandSend() {

	}

	virtual void getInterfaceVersion(std::string& version) const =0;
	virtual am_Error_e startupInterface(IAmCommandReceive* commandreceiveinterface) =0;
	virtual void setCommandReady(const uint16_t handle) =0;
	virtual void setCommandRundown(const uint16_t handle) =0;
	virtual void cbNewMainConnection(const am_MainConnectionType_s& mainConnection) =0;
	virtual void cbRemovedMainConnection(const am_mainConnectionID_t mainConnection) =0;
	virtual void cbNewSink(const am_SinkType_s& sink) =0;
	virtual void cbRemovedSink(const am_sinkID_t sinkID) =0;
	virtual void cbNewSource(const am_SourceType_s& source) =0;
	virtual void cbRemovedSource(const am_sourceID_t source) =0;
	virtual void cbNumberOfSinkClassesChanged() =0;
	virtual void cbNumberOfSourceClassesChanged() =0;
	virtual void cbMainConnectionStateChanged(const am_mainConnectionID_t connectionID, const am_ConnectionState_e connectionState) =0;
	virtual void cbMainSinkSoundPropertyChanged(const am_sinkID_t sinkID, const am_MainSoundProperty_s& soundProperty) =0;
	virtual void cbMainSourceSoundPropertyChanged(const am_sourceID_t sourceID, const am_MainSoundProperty_s& soundProperty) =0;
	virtual void cbSinkAvailabilityChanged(const am_sinkID_t sinkID, const am_Availability_s& availability) =0;
	virtual void cbSourceAvailabilityChanged(const am_sourceID_t sourceID, const am_Availability_s& availability) =0;
	virtual void cbVolumeChanged(const am_sinkID_t sinkID, const am_mainVolume_t volume) =0;
	virtual void cbSinkMuteStateChanged(const am_sinkID_t sinkID, const am_MuteState_e muteState) =0;
	virtual void cbSystemPropertyChanged(const am_SystemProperty_s& systemProperty) =0;
	virtual void cbTimingInformationChanged(const am_mainConnectionID_t mainConnectionID, const am_timeSync_t time) =0;
	virtual void cbSinkUpdated(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
	virtual void cbSourceUpdated(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
	virtual void cbSinkNotification(const am_sinkID_t sinkID, const am_NotificationPayload_s& notification) =0;
	virtual void cbSourceNotification(const am_sourceID_t sourceID, const am_NotificationPayload_s& notification) =0;
	virtual void cbMainSinkNotificationConfigurationChanged(const am_sinkID_t sinkID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;
	virtual void cbMainSourceNotificationConfigurationChanged(const am_sourceID_t sourceID, const am_NotificationConfiguration_s& mainNotificationConfiguration) =0;

};
}
#endif // !defined(EA_68F78255_5C2E_4b32_A21C_E8CEDD4641B3__INCLUDED_)

/** Copyright (c) 2012 GENIVI Alliance
 *  Copyright (c) 2012 BMW
 *
 *  @author Christian Mueller, BMW
 *
 *  @copyright
 *  {
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction,
 *  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 *  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *  }
 *
 * 
 * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN
 */
#if !defined(EA_1F9A0AD1_FF28_4de6_A5C7_2F570F618734__INCLUDED_)
#define EA_1F9A0AD1_FF28_4de6_A5C7_2F570F618734__INCLUDED_

#include <stdint.h>
#include "projecttypes.h"
#include <string>
#include <vector>

#define AM_MUTE -3000

namespace am {
	/**
	 * a domain ID
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_domainID_t;

	/**
	 * a source ID
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_sourceID_t;

	/**
	 * a sink ID 
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_sinkID_t;

	/**
	 * a gateway ID
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_gatewayID_t;

	/**
	 * a crossfader ID
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_crossfaderID_t;

	/**
	 * a connection ID 
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_connectionID_t;

	/**
	 * a mainConnection ID
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_mainConnectionID_t;

	/**
	 * speed
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_speed_t;

	/**
	 * The unit is 0.1 db steps,The smallest value -3000 (=AM_MUTE). The minimum and maximum can be limited by actual project.
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef int16_t am_volume_t;

	/**
	 * This is the volume presented on the command interface. It is in the duty of the Controller to change the volumes given here into meaningful values on the routing interface.
	 * The range of this type is customer specific.
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef int16_t am_mainVolume_t;

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_sourceClass_t;

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_sinkClass_t;

	/**
	 * time in ms!
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef uint16_t am_time_t;

	/**
	 * offset time that is introduced in milli seconds.
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	typedef int16_t am_timeSync_t;

	/**
	 * with the help of this enum, sinks and sources can report their availability state
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_Availablility_e
	{
		/**
		 * default
		 */
		A_UNKNOWN = 0,
		/**
		 * The source / sink is available
		 */
		A_AVAILABLE = 1,
		/**
		 * the source / sink is not available
		 */
		A_UNAVAILABLE = 2,
		A_MAX
	};

	/**
	 * represents the connection state
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_ConnectionState_e
	{
		CS_UNKNOWN = 0,
		/**
		 * This means the connection is just building up
		 */
		CS_CONNECTING = 1,
		/**
		 * the connection is ready to be used
		 */
		CS_CONNECTED = 2,
		/**
		 * the connection is in the course to be knocked down
		 */
		CS_DISCONNECTING = 3,
		/**
		 * only relevant for connectionStatechanged. Is send after the connection was removed
		 */
		CS_DISCONNECTED = 4,
		/**
		 * this means the connection is still build up but unused at the moment
		 */
		CS_SUSPENDED = 5,
		CS_MAX
	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_DomainState_e
	{
		/**
		 * default
		 */
		DS_UNKNOWN = 0,
		/**
		 * the domain is controlled by the daemon
		 */
		DS_CONTROLLED = 1,
		/**
		 * the domain is independent starting up
		 */
		DS_INDEPENDENT_STARTUP = 1,
		/**
		 * the domain is independent running down
		 */
		DS_INDEPENDENT_RUNDOWN = 2,
		DS_MAX
	};

	/**
	 * This enum characterizes the data of the EarlyData_t
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_EarlyDataType_e
	{
		/**
		 * default
		 */
		ES_UNKNOWN = 0,
		/**
		 * the source volume
		 */
		ED_SOURCE_VOLUME = 1,
		/**
		 * the sink volume
		 */
		ED_SINK_VOLUME = 2,
		/**
		 * a source property
		 */
		ED_SOURCE_PROPERTY = 3,
		/**
		 * a sink property
		 */
		ED_SINK_PROPERTY = 4,
		ED_MAX
	};

	/**
	 * the errors of the audiomanager. All possible errors are in here. This enum is used widely as return parameter.
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_Error_e
	{
		/**
		 * default
		 */
		E_UNKNOWN = 0,
		/**
		 * no error - positive reply
		 */
		E_OK = 1,
		/**
		 * value out of range
		 */
		E_OUT_OF_RANGE = 2,
		/**
		 * not used
		 */
		E_NOT_USED = 3,
		/**
		 * a database error occurred 
		 */
		E_DATABASE_ERROR = 4,
		/**
		 * the desired object already exists
		 */
		E_ALREADY_EXISTS = 5,
		/**
		 * there is no change
		 */
		E_NO_CHANGE = 6,
		/**
		 * the desired action is not possible
		 */
		E_NOT_POSSIBLE = 7,
		/**
		 * the desired object is non existent
		 */
		E_NON_EXISTENT = 8,
		/**
		 * the asynchronous action was aborted
		 */
		E_ABORTED = 9,
		/**
		 * This error is returned in case a connect is issued with a connectionFormat that cannot be selected for the connection. This could be either due to the capabilities of a source or a sink or gateway compatibilities for example
		 */
		E_WRONG_FORMAT = 10,
		E_MAX
	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_MuteState_e
	{
		/**
		 * default
		 */
		MS_UNKNOWN = 0,
		/**
		 * the source / sink is muted
		 */
		MS_MUTED = 1,
		/**
		 * the source / sink is unmuted
		 */
		MS_UNMUTED = 2,
		MS_MAX
	};

	/**
	 * The source state reflects the state of the source
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_SourceState_e
	{
		SS_UNKNNOWN = 0,
		/**
		 * The source can be activly heared
		 */
		SS_ON = 1,
		/**
		 * The source cannot be heared
		 */
		SS_OFF = 2,
		/**
		 * The source is paused. Meaning it cannot be heared but should be prepared to play again soon.
		 */
		SS_PAUSED = 3,
		SS_MAX
	};

	/**
	 * This enumeration is used to define the type of the action that is correlated to a handle.
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_Handle_e
	{
		H_UNKNOWN = 0,
		H_CONNECT = 1,
		H_DISCONNECT = 2,
		H_SETSOURCESTATE = 3,
		H_SETSINKVOLUME = 4,
		H_SETSOURCEVOLUME = 5,
		H_SETSINKSOUNDPROPERTY = 6,
		H_SETSOURCESOUNDPROPERTY = 7,
		H_SETSINKSOUNDPROPERTIES = 8,
		H_SETSOURCESOUNDPROPERTIES = 9,
		H_CROSSFADE = 10,
		H_MAX
	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_InterruptState_e
	{
		/**
		 * default
		 */
		IS_UNKNOWN = 0,
		/**
		 * the interrupt state is off - no interrupt 
		 */
		IS_OFF = 1,
		/**
		 * the interrupt state is interrupted - the interrupt is active
		 */
		IS_INTERRUPTED = 2,
		IS_MAX
	};

	/**
	 * describes the active sink of a crossfader.
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:36 PM
	 */
	enum am_HotSink_e
	{
		/**
		 * default
		 */
		HS_UNKNOWN = 0,
		/**
		 * sinkA is active
		 */
		HS_SINKA = 1,
		/**
		 * sinkB is active
		 */
		HS_SINKB = 2,
		/**
		 * the crossfader is in the transition state
		 */
		HS_INTERMEDIATE = 3,
		HS_MAX
	};

	/**
	 * this describes the availability of a sink or a source together with the latest change
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:37 PM
	 */
	struct am_Availability_s
	{

	public:
		/**
		 * the current availability state
		 */
		am_Availablility_e availability;
		/**
		 * the reason for the last change. This can be used to trigger events that deal with state changes.
		 */
		am_AvailabilityReason_e availabilityReason;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:37 PM
	 */
	struct am_ClassProperty_s
	{

	public:
		am_ClassProperty_e classProperty;
		int16_t value;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:37 PM
	 */
	struct am_Crossfader_s
	{

	public:
		am_crossfaderID_t crossfaderID;
		std::string name;
		am_sinkID_t sinkID_A;
		am_sinkID_t sinkID_B;
		am_sourceID_t sourceID;
		am_HotSink_e hotSink;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:37 PM
	 */
	struct am_Gateway_s
	{

	public:
		am_gatewayID_t gatewayID;
		std::string name;
		am_sinkID_t sinkID;
		am_sourceID_t sourceID;
		am_domainID_t domainSinkID;
		am_domainID_t domainSourceID;
		am_domainID_t controlDomainID;
		std::vector<am_ConnectionFormat_e> listSourceFormats;
		std::vector<am_ConnectionFormat_e> listSinkFormats;
		/**
		 * This is matrix holding information about the conversion capability of the gateway, it's length is defined by the length(listSinkFormats) x length(listSourceFormats).
		 * If a SinkFormat can be converted into a SourceFormat, the vector will hold a 1, if no conversion is possible, a 0.
		 * The data is stored row orientated, where the rows are related to the sinksFormats and the columns to the sourceFormats. The first value will hold the conversion information from the first sourceFormat to the first sinkFormat for example and the seventh value the information about the 3rd sinkFormat to the 1st sourceFormat in case we would have 3 sourceFormats.
		 * 
		 * This matrix 
		 * 110 011 000 111 001
		 * 
		 * reads as this:
		 *           Source
		 * 	**  1  2  3 
		 * *********************
		 * S	1*  1  1  0 
		 * i	2*  0  1  1
		 * n	3*  0  0  0
		 * k	4*  1  1  1
		 * 	5*  0  0  1
		 */
		std::vector<bool> convertionMatrix;

	};

	/**
	 * This represents one "hopp" in a route
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:37 PM
	 */
	struct am_RoutingElement_s
	{

	public:
		am_sourceID_t sourceID;
		am_sinkID_t sinkID;
		am_domainID_t domainID;
		am_ConnectionFormat_e connectionFormat;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:37 PM
	 */
	struct am_Route_s
	{

	public:
		am_sourceID_t sourceID;
		am_sinkID_t sinkID;
		std::vector<am_RoutingElement_s> route;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:37 PM
	 */
	struct am_SoundProperty_s
	{

	public:
		am_SoundPropertyType_e type;
		int16_t value;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:37 PM
	 */
	struct am_SystemProperty_s
	{

	public:
		/**
		 * the type that is set
		 */
		am_SystemPropertyType_e type;
		/**
		 * the value
		 */
		int16_t value;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:38 PM
	 */
	struct am_SinkClass_s
	{

	public:
		am_sinkClass_t sinkClassID;
		std::string name;
		std::vector<am_ClassProperty_s> listClassProperties;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:38 PM
	 */
	struct am_SourceClass_s
	{

	public:
		/**
		 * the source ID
		 */
		am_sourceClass_t sourceClassID;
		std::string name;
		std::vector<am_ClassProperty_s> listClassProperties;

	};

	/**
	 * this type holds all information of sources relevant to the HMI
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:38 PM
	 */
	struct am_SourceType_s
	{

	public:
		am_sourceID_t sourceID;
		std::string name;
		am_Availability_s availability;
		am_sourceClass_t sourceClassID;

	};

	/**
	 * this type holds all information of sinks relevant to the HMI
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:38 PM
	 */
	struct am_SinkType_s
	{

	public:
		am_sinkID_t sinkID;
		std::string name;
		am_Availability_s availability;
		am_mainVolume_t volume;
		am_MuteState_e muteState;
		am_sinkClass_t sinkClassID;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:38 PM
	 */
	struct am_Handle_s
	{

	public:
		am_Handle_e handleType:4;
		uint16_t handle:12;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:38 PM
	 */
	struct am_MainSoundProperty_s
	{

	public:
		am_MainSoundPropertyType_e type;
		int16_t value;

	};

	/**
	 * this type holds all information of connections relevant to the HMI
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:38 PM
	 */
	struct am_MainConnectionType_s
	{

	public:
		am_mainConnectionID_t mainConnectionID;
		am_sourceID_t sourceID;
		am_sinkID_t sinkID;
		am_timeSync_t delay;
		am_ConnectionState_e connectionState;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:39 PM
	 */
	struct am_MainConnection_s
	{

	public:
		am_mainConnectionID_t mainConnectionID;
		am_ConnectionState_e connectionState;
		/**
		 * the sinkID
		 */
		am_sinkID_t sinkID;
		/**
		 * the sourceID
		 */
		am_sourceID_t sourceID;
		am_timeSync_t delay;
		std::vector<am_connectionID_t> listConnectionID;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:39 PM
	 */
	struct am_Sink_s
	{

	public:
		am_sinkID_t sinkID;
		std::string name;
		am_domainID_t domainID;
		am_sinkClass_t sinkClassID;
		am_volume_t volume;
		bool visible;
		am_Availability_s available;
		am_MuteState_e muteState;
		am_mainVolume_t mainVolume;
		std::vector<am_SoundProperty_s> listSoundProperties;
		std::vector<am_ConnectionFormat_e> listConnectionFormats;
		std::vector<am_MainSoundProperty_s> listMainSoundProperties;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:39 PM
	 */
	struct am_Source_s
	{

	public:
		am_sourceID_t sourceID;
		am_domainID_t domainID;
		std::string name;
		am_sourceClass_t sourceClassID;
		am_SourceState_e sourceState;
		am_volume_t volume;
		bool visible;
		am_Availability_s available;
		am_InterruptState_e interruptState;
		/**
		 * This list holds all soundProperties of the source
		 */
		std::vector<am_SoundProperty_s> listSoundProperties;
		/**
		 * list of the supported ConnectionFormats
		 */
		std::vector<am_ConnectionFormat_e> listConnectionFormats;
		/**
		 * This list holds all MainSoundProperties of the source (all the ones that can be set via the HMI)
		 */
		std::vector<am_MainSoundProperty_s> listMainSoundProperties;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:39 PM
	 */
	struct am_Domain_s
	{

	public:
		am_domainID_t domainID;
		std::string name;
		std::string busname;
		std::string nodename;
		bool early;
		bool complete;
		am_DomainState_e state;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:39 PM
	 */
	struct am_Connection_s
	{

	public:
		am_connectionID_t connectionID;
		am_sourceID_t sourceID;
		am_sinkID_t sinkID;
		am_timeSync_t delay;
		am_ConnectionFormat_e connectionFormat;

	};

	/**
	 * data type depends of am_EarlyDataType_e:
	 * volume_t in case of ED_SOURCE_VOLUME, ED_SINK_VOLUME 
	 * soundProperty_t in case of ED_SOURCE_PROPERTY, ED_SINK_PROPERTY 
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:39 PM
	 */
	union am_EarlyData_u
	{

	public:
		am_volume_t volume;
		am_SoundProperty_s soundProperty;

	};

	/**
	 * data type depends of am_EarlyDataType_e:
	 * sourceID in case of ED_SOURCE_VOLUME, ED_SOURCE_PROPERTY
	 * sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY 
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:39 PM
	 */
	union am_DataType_u
	{

	public:
		am_sinkID_t sink;
		am_sourceID_t source;

	};

	/**
	 * @author Christian Mueller
	 * @created 29-Feb-2012 6:16:40 PM
	 */
	struct am_EarlyData_s
	{

	public:
		am_EarlyDataType_e type;
		am_DataType_u sinksource;
		am_EarlyData_u data;

	};
}
#endif // !defined(EA_1F9A0AD1_FF28_4de6_A5C7_2F570F618734__INCLUDED_)

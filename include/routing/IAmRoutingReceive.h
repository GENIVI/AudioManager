/**
 * Copyright (C) 2012 - 2014, BMW AG
 *
 * This file is part of GENIVI Project AudioManager.
 *
 * Contributions are licensed to the GENIVI Alliance under one or more
 * Contribution License Agreements.
 *
 * \copyright
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
 * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 *
 * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
 *
 * \file
 * For further information see http://projects.genivi.org/audio-manager
 *
 * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
 * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
 */
#if !defined(EA_6ECD9991_3219_4bf4_B9F7_DDE15D8683C6__INCLUDED_)
#define EA_6ECD9991_3219_4bf4_B9F7_DDE15D8683C6__INCLUDED_

#include <vector>
#include <string>
#include "audiomanagertypes.h"

namespace am {
class CAmDbusWrapper;
class CAmSocketHandler;
}


#include "audiomanagertypes.h"

#define RoutingReceiveVersion "2.0" 
namespace am {

/**
 * Routing Receive sendInterface description. This class implements everything
 * from RoutingAdapter -> Audiomanager
 * There are two rules that have to be kept in mind when implementing against this
 * interface:\n
 * \warning
 * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
 * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
 * CALL THAT EXPECTS A RETURN VALUE.\n
 * \details
 * Violation these rules may lead to unexpected behavior! Nevertheless you can
 * implement thread safe by using the deferred-call pattern described on the wiki
 * which also helps to implement calls that are forbidden.\n
 * For more information, please check CAmSerializer
 */
class IAmRoutingReceive
{

public:
	IAmRoutingReceive() {

	}

	virtual ~IAmRoutingReceive() {

	}

	virtual void  getInterfaceVersion(std::string& version) const =0;
	virtual void ackConnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_Error_e error) =0;
	virtual void ackDisconnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_Error_e error) =0;
	virtual void ackSetSinkVolumeChange(const am_Handle_s handle, const am_volume_t volume, const am_Error_e error) =0;
	virtual void ackSetSourceVolumeChange(const am_Handle_s handle, const am_volume_t volume, const am_Error_e error) =0;
	virtual void ackSetSourceState(const am_Handle_s handle, const am_Error_e error) =0;
	virtual void ackSetSinkSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
	virtual void ackSetSinkSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
	virtual void ackSetSourceSoundProperties(const am_Handle_s handle, const am_Error_e error) =0;
	virtual void ackSetSourceSoundProperty(const am_Handle_s handle, const am_Error_e error) =0;
	virtual void ackCrossFading(const am_Handle_s handle, const am_HotSink_e hotSink, const am_Error_e error) =0;
	virtual void ackSourceVolumeTick(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume) =0;
	virtual void ackSinkVolumeTick(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume) =0;
	virtual am_Error_e peekDomain(const std::string& name, am_domainID_t& domainID) =0;
	virtual am_Error_e registerDomain(const am_Domain_s& domainData, am_domainID_t& domainID) =0;
	virtual am_Error_e deregisterDomain(const am_domainID_t domainID) =0;
	virtual am_Error_e registerGateway(const am_Gateway_s& gatewayData, am_gatewayID_t& gatewayID) =0;
	virtual am_Error_e deregisterGateway(const am_gatewayID_t gatewayID) =0;
	virtual am_Error_e peekSink(const std::string& name, am_sinkID_t& sinkID) =0;
	virtual am_Error_e registerSink(const am_Sink_s& sinkData, am_sinkID_t& sinkID) =0;
	virtual am_Error_e deregisterSink(const am_sinkID_t sinkID) =0;
	virtual am_Error_e peekSource(const std::string& name, am_sourceID_t& sourceID) =0;
	virtual am_Error_e registerSource(const am_Source_s& sourceData, am_sourceID_t& sourceID) =0;
	virtual am_Error_e deregisterSource(const am_sourceID_t sourceID) =0;
	virtual am_Error_e registerCrossfader(const am_Crossfader_s& crossfaderData, am_crossfaderID_t& crossfaderID) =0;
	virtual am_Error_e deregisterCrossfader(const am_crossfaderID_t crossfaderID) =0;
	virtual am_Error_e peekSourceClassID(const std::string& name, am_sourceClass_t& sourceClassID) =0;
	virtual am_Error_e peekSinkClassID(const std::string& name, am_sinkClass_t& sinkClassID) =0;
	virtual void hookInterruptStatusChange(const am_sourceID_t sourceID, const am_InterruptState_e interruptState) =0;
	virtual void hookDomainRegistrationComplete(const am_domainID_t domainID) =0;
	virtual void hookSinkAvailablityStatusChange(const am_sinkID_t sinkID, const am_Availability_s& availability) =0;
	virtual void hookSourceAvailablityStatusChange(const am_sourceID_t sourceID, const am_Availability_s& availability) =0;
	virtual void hookDomainStateChange(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
	virtual void hookTimingInformationChanged(const am_connectionID_t connectionID, const am_timeSync_t delay) =0;
	virtual void sendChangedData(const std::vector<am_EarlyData_s>& earlyData) =0;
	virtual am_Error_e getDBusConnectionWrapper(CAmDbusWrapper*& dbusConnectionWrapper) const =0;
	virtual am_Error_e getSocketHandler(CAmSocketHandler*& socketHandler) const =0;
	virtual void  confirmRoutingReady(const uint16_t handle, const am_Error_e error) =0;
	virtual void  confirmRoutingRundown(const uint16_t handle, const am_Error_e error) =0;
	virtual am_Error_e updateGateway(const am_gatewayID_t gatewayID, const std::vector<am_CustomConnectionFormat_t>& listSourceFormats, const std::vector<am_CustomConnectionFormat_t>& listSinkFormats, const std::vector<bool>& convertionMatrix) =0;
	virtual am_Error_e updateSink(const am_sinkID_t sinkID, const am_sinkClass_t sinkClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
	virtual am_Error_e updateSource(const am_sourceID_t sourceID, const am_sourceClass_t sourceClassID, const std::vector<am_SoundProperty_s>& listSoundProperties, const std::vector<am_CustomConnectionFormat_t>& listConnectionFormats, const std::vector<am_MainSoundProperty_s>& listMainSoundProperties) =0;
	virtual void ackSetVolumes(const am_Handle_s handle, const std::vector<am_Volumes_s>& listvolumes, const am_Error_e error) =0;
	virtual void ackSinkNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
	virtual void ackSourceNotificationConfiguration(const am_Handle_s handle, const am_Error_e error) =0;
	virtual void hookSinkNotificationDataChange(const am_sinkID_t sinkID, const am_NotificationPayload_s& payload) =0;
	virtual void hookSourceNotificationDataChange(const am_sourceID_t sourceID, const am_NotificationPayload_s& payload) =0;

};
}
#endif // !defined(EA_6ECD9991_3219_4bf4_B9F7_DDE15D8683C6__INCLUDED_)

/**
 * Copyright (C) 2012 - 2014, BMW AG
 *
 * This file is part of GENIVI Project AudioManager.
 *
 * Contributions are licensed to the GENIVI Alliance under one or more
 * Contribution License Agreements.
 *
 * \copyright
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a  copy of the MPL was not distributed with
 * this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 *
 * \author Christian Linke, christian.linke@bmw.de BMW 2011 - 2014
 *
 * \file
 * For further information see http://projects.genivi.org/audio-manager
 *
 * THIS CODE HAS BEEN GENERATED BY ENTERPRISE ARCHITECT GENIVI MODEL. 
 * PLEASE CHANGE ONLY IN ENTERPRISE ARCHITECT AND GENERATE AGAIN.
 */
#if !defined(EA_3AD07676_42DA_4ba9_A6E8_DA06F23BC8EB__INCLUDED_)
#define EA_3AD07676_42DA_4ba9_A6E8_DA06F23BC8EB__INCLUDED_

#include <vector>
#include <string>
#include "audiomanagertypes.h"

namespace am {
class IAmRoutingReceive;
}

#include "audiomanagertypes.h"
#include "IAmRoutingReceive.h"

#define RoutingSendVersion "2.0" 
namespace am {

/**
 * This class implements everything from Audiomanager -> RoutingAdapter
 * There are two rules that have to be kept in mind when implementing against this
 * interface:\n
 * \warning
 * 1. CALLS TO THIS INTERFACE ARE NOT THREAD SAFE !!!! \n
 * 2. YOU MAY NOT CALL THE CALLING INTERFACE DURING AN SYNCHRONOUS OR ASYNCHRONOUS
 * CALL THAT EXPECTS A RETURN VALUE.\n
 * \details
 * Violation these rules may lead to unexpected behavior! Nevertheless you can
 * implement thread safe by using the deferred-call pattern described on the wiki
 * which also helps to implement calls that are forbidden.\n
 * For more information, please check CAmSerializer
 */
class IAmRoutingSend
{

public:
	IAmRoutingSend() {

	}

	virtual ~IAmRoutingSend() {

	}

	virtual void getInterfaceVersion(std::string& version) const =0;
	virtual am_Error_e startupInterface(IAmRoutingReceive* routingreceiveinterface) =0;
	virtual void setRoutingReady(const uint16_t handle) =0;
	virtual void setRoutingRundown(const uint16_t handle) =0;
	virtual am_Error_e asyncAbort(const am_Handle_s handle) =0;
	virtual am_Error_e asyncConnect(const am_Handle_s handle, const am_connectionID_t connectionID, const am_sourceID_t sourceID, const am_sinkID_t sinkID, const am_CustomConnectionFormat_t connectionFormat) =0;
	virtual am_Error_e asyncDisconnect(const am_Handle_s handle, const am_connectionID_t connectionID) =0;
	virtual am_Error_e asyncSetSinkVolume(const am_Handle_s handle, const am_sinkID_t sinkID, const am_volume_t volume, const am_CustomRampType_t ramp, const am_time_t time) =0;
	virtual am_Error_e asyncSetSourceVolume(const am_Handle_s handle, const am_sourceID_t sourceID, const am_volume_t volume, const am_CustomRampType_t ramp, const am_time_t time) =0;
	virtual am_Error_e asyncSetSourceState(const am_Handle_s handle, const am_sourceID_t sourceID, const am_SourceState_e state) =0;
	virtual am_Error_e asyncSetSinkSoundProperties(const am_Handle_s handle, const am_sinkID_t sinkID, const std::vector<am_SoundProperty_s>& listSoundProperties) =0;
	virtual am_Error_e asyncSetSinkSoundProperty(const am_Handle_s handle, const am_sinkID_t sinkID, const am_SoundProperty_s& soundProperty) =0;
	virtual am_Error_e asyncSetSourceSoundProperties(const am_Handle_s handle, const am_sourceID_t sourceID, const std::vector<am_SoundProperty_s>& listSoundProperties) =0;
	virtual am_Error_e asyncSetSourceSoundProperty(const am_Handle_s handle, const am_sourceID_t sourceID, const am_SoundProperty_s& soundProperty) =0;
	virtual am_Error_e asyncCrossFade(const am_Handle_s handle, const am_crossfaderID_t crossfaderID, const am_HotSink_e hotSink, const am_CustomRampType_t rampType, const am_time_t time) =0;
	virtual am_Error_e setDomainState(const am_domainID_t domainID, const am_DomainState_e domainState) =0;
	virtual am_Error_e returnBusName(std::string& BusName) const =0;
	virtual am_Error_e asyncSetVolumes(const am_Handle_s handle, const std::vector<am_Volumes_s>& listVolumes) =0;
	virtual am_Error_e asyncSetSinkNotificationConfiguration(const am_Handle_s handle, const am_sinkID_t sinkID, const am_NotificationConfiguration_s& notificationConfiguration) =0;
	virtual am_Error_e asyncSetSourceNotificationConfiguration(const am_Handle_s handle, const am_sourceID_t sourceID, const am_NotificationConfiguration_s& notificationConfiguration) =0;

};
}
#endif // !defined(EA_3AD07676_42DA_4ba9_A6E8_DA06F23BC8EB__INCLUDED_)
